<h1>About</h1>
<p>這裡是國立虎尾科技大學 - 機械設計工程系 - 計算機程式課程網站.</p>
<p><a href="https://mde.tw">KMOLab</a> 上課的目的: 鼓勵每一位同學都能及早<span style="background-color: #ffff99;">確定努力的目標</span>, 證明自己具備<span style="background-color: #ffff99;">獨立研究與解題能力</span>.</p>
<p>本課程的主要倉儲位於: <a href="https://github.com/mdecourse/cp2021">https://github.com/mdecourse/cp2021</a></p>
<p>與課程相關的訊息, 指定作業與問答區位於: <a href="https://github.com/mdecourse/cp2021/discussions">https://github.com/mdecourse/cp2021/discussions</a> </p>
<p>計算機程式 Zulip:</p>
<p style="padding-left: 30px;"><a href="https://kmolab.zulipchat.com">https://kmolab.zulipchat.com</a></p>
<p style="padding-left: 30px;"><a href="https://kmolab.zulipchat.com/#narrow/stream/292134-2021-Fall/topic/.E8.A8.88.E7.AE.97.E6.A9.9F.E7.A8.8B.E5.BC.8F">計算機程式 Zulip 討論區</a></p>
<p>gitter: <a href="https://gitter.im/mdecourse/cp2021">https://gitter.im/mdecourse/cp2021</a> (<span style="background-color: #ccffcc;">線上課程時段訊息發布區</span>)</p>
<p>若 gitter 無法連線, 將使用 <a href="https://meet.google.com/rcy-zudh-cez">https://meet.google.com/rcy-zudh-cez</a> 當作線上課程網址.</p>
<h4>Homework template:</h4>
<p style="padding-left: 30px;"><a href="https://github.com/mdecourse/cp2021_hw">https://github.com/mdecourse/cp2021_hw</a></p>
<p style="padding-left: 30px;"><a href="https://mde.tw/cp2021_hw">https://mde.tw/cp2021_hw</a></p>
<hr/>
<p>Python 程式語言可以編寫網際內容管理系統 (<a href="https://github.com/mdecourse/cmstemplate">cmstemplate</a>), 可以執行虛實整合系統的強化學習 (<a href="https://github.com/mdecourse/4072pj1">4072pj1</a>), 也能<a href="https://www.youtube.com/watch?v=3EqzMzszMV0">控制</a>數位場景中的機電模擬系統, 並進行機構合成 (<a href="https://github.com/mdecourse/4072pj3">4072pj3</a>), 但在 <a href="https://www.coppeliarobotics.com/">CoppeliaSim</a> 與 <a href="https://cyberbotics.com/">Webots </a>系統模擬過程, 為了開發效率, 使用者需要透過 Lua 程式才能與 C++ 底層溝通, 並且後續的零組件強度分析, 大多依賴 C++ 程式套件完成 (<a href="https://github.com/mdecourse/4072pj2">4072pj2</a>), 而開發者若希望實現機電模擬系統的<a href="http://mde.tw/cd2020/content/Microcontroller.html">控制</a>, 則通常利用 C 程式執行.</p>
<p>隨著雲端部署與隨身裝置的緊密結合下, 假如在十年前, 要編寫 Javascript 的伺服器端 runtime, C++ 會是個不錯的選擇 (<a href="https://nodejs.org">node.js</a>), 但此刻採用 Rust 才比較<a href="https://thenewstack.io/rust-by-the-numbers-the-rust-programming-language-in-2021/">符合潮流</a>, 至於網際前後端若能同時執行最新版的 Javascript 與 <a href="https://www.typescriptlang.org/">Typescript</a>, 可以省去開發者不少麻煩 (<a href="https://deno.land/">Deno</a>). 當然隨身裝置中的各式 App, 若能採用 <a href="https://dart.dev/">Dart</a> 程式語言的 <a href="https://flutter.dev/">Flutter</a> 跨平台架構編寫, 並且依賴 <a href="https://elixir-lang.org/">Elixir</a> 分散式容錯伺服器進行<a href="https://github.com/ukncsc/zero-trust-architecture">零信任</a> (Zero Trust) 與<a href="https://en.wikipedia.org/wiki/Edge_computing">邊緣運算</a> (Edge Computing) 配置, 或許才能進一步有效因應目前各種詭譎多變的數位環境.</p>
<p>各位技職體系大學新鮮人, 歡迎進入二十一世紀第三個十年的計算機程式世代.</p>
<p>關鍵字: Python, Lua, C++, C, Javascript, Rust, Typescript, Dart, Flutter, Elixir.</p>
<h4>有關系列課程:</h4>
<p style="padding-left: 30px;">KMOLab: <a href="https://mde.tw">https://mde.tw</a> 負責開設計算機程式 (大一), 網際內容管理 (五專與大一), 電腦輔助設計實習 (大二) 與協同產品設計實習 (大二) 等四門課, 計算機程式將從網際 Python (<a href="https://brython.info/">Brython</a>) 開始, 透過<a href="https://mde.tw/cp2021/content/%E8%A7%A3%E9%A1%8C%E7%B7%B4%E7%BF%92.html">解題練習</a>頁面, 讓學員利用 Python, <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript">Javascript</a> 與 <a href="https://developer.mozilla.org/zh-TW/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL">WebGL</a> 建立簡單的網際程式, 從中學習如何利用程式解決簡單的工程問題.</p>
<p style="padding-left: 30px;">計算機程式課程所採用的 textbook: <a href="https://link.springer.com/book/10.1007/978-981-10-3277-6">Programming with Python</a>, 2016 by T R Padmanabhan, 學員可以自行從校園網路中下載.</p>
<p style="padding-left: 30px;"><a href="https://mde.tw">KMOLab</a> 課程要求學員利用 <a href="https://github.com">Github</a>, <a href="https://about.gitlab.com/">Gitlab</a>, <a href="https://bitbucket.org/">Bitbucket</a> 與 <a href="https://www.heroku.com/">Heroku</a> 建立同步網站累積個人學習歷程.</p>
<p style="padding-left: 30px;">網際內容管理課程則主要透過 <a href="https://flask.palletsprojects.com/en/2.0.x/">Flask</a> 與 <a href="https://www.fossil-scm.org">Fossil SCM</a> 的結合, 讓學員使用 Python 建立與機械設計流程相關的網際系統.</p>
<p style="padding-left: 30px;">電腦輔助設計實習與協同產品設計實習則從網際 Python 程式與 SolidWorks, Inventor, NX 等系統的 API 應用練習開始, 導引學員了解如何以網際程式方法提升產品設計彈性, 並利用 <a href="https://github.com/solvespace/solvespace">Solvespace</a>, <a href="https://github.com/CoppeliaRobotics">CoppeliaSim</a> 與 <a href="https://github.com/cyberbotics/webots">Webots</a> 等開放源套件, 建立與 <a href="https://en.wikipedia.org/wiki/Flexible_manufacturing_system">Flexible Manufacturing System</a> 相關的機電整合模擬與控制系統.</p>
<p style="padding-left: 30px;"><a href="https://mde.tw">KMOLab</a> 課程同時要求學員建立 <a href="https://tw.linkedin.com/">https://tw.linkedin.com/</a> 帳號, 並持續維護資料, 初期可以採用中文編寫, 大學畢業前則必須將相關履歷資料改以英文編寫.</p>
<h4>開場:</h4>
<p style="padding-left: 30px;">學計算機程式做什麼? 其他人是<a href="https://itw01.com/YHAE5HS.html">如何學習計算機程式</a> (<a href="https://feross.org/how-i-learned-to-program-computers/">原始文章</a>, <a href="https://feross.org/">作者</a>)?</p>
<hr/>
<h4>啟示:</h4>
<p style="padding-left: 30px;"><a href="http://sam-koblenski.blogspot.com/2014/04/the-essence-of-programming.html">http://sam-koblenski.blogspot.com/2014/04/the-essence-of-programming.html</a></p>
<p style="padding-left: 30px;">學會特定計算機程式語言的規定及語法並不會太難, 但是一談到要如何運用計算機程式, 解決機械設計流程碰到的各種問題, 絕大多數的機械設計背景工程師, 卻無法達成. Why?</p>
<hr/>
<h4>深省:</h4>
<p style="padding-left: 30px;">下列是 2005 年 <a href="https://www.eecs.mit.edu/about-us/mit-eecs-department-facts">MIT</a> <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/">Structure and Interpretation of Computer Programs</a> 課程的第一週教學影片, <a href="https://www.youtube.com/watch?v=r8k8o7zkA1o">Harold Abelson</a> 教授一開場便說: computer science is not a science (當時的科系名稱為 Electric Engineering and Computer Science). It's also not really very much about computers. And that is, when some field is just getting started and you don't really understand it very well, it's very easy to confuse the essence of what you're doing with the tools that you use.</p>
<p style="padding-left: 30px;">I think in the future people will look back and say, yes, those primitives in the 20th century were fiddling around with these gadgets called computers, but really what they were doing is starting to <span style="background-color: #ccffcc;">learn how to <a href="https://www.merriam-webster.com/dictionary/formalize">formalize</a> <a href="https://www.merriam-webster.com/dictionary/intuition">intuitions</a> about <a href="https://www.merriam-webster.com/dictionary/process">process</a>,</span> <span style="background-color: #ccffcc;">how to do things, starting to develop a way to talk precisely about how-to knowledge.</span></p>
<p style="padding-left: 30px;">計算機程式在學習<span style="background-color: #ffff99;">如何將做事的過程 (process) 及直覺 (intuitions) </span>予以<span style="background-color: #ffff99;">形式化 (formalize)</span>, 並且著手開發一種方式來<span style="background-color: #ffff99;">準確地 (precisely) 討論如何運用知識 (knowledge)</span>.</p>
<p style="padding-left: 30px;">keywords: process, intuitions, formalize, precisely and knowledge.</p>
<p style="padding-left: 30px;">關鍵字為: 過程, 直覺, 形式化, 精確以及知識.</p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/-J_xL4IGhJA" title="YouTube video player" width="560"></iframe></p>
<p>Overview and Introduction to Lisp (<a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/">source</a>, <a href="http://mde.tw/cad2021/downloads/Overview_Into_to_Lisp.txt">Closed Caption</a>)</p>
<hr/>
<h4>榜樣:</h4>
<p style="padding-left: 30px;">學習利用計算機程式解決問題的年齡<a href="https://www.israel21c.org/israel-to-introduce-stem-studies-in-kindergarten/">愈早越好</a>(<a href="/downloads/Computer Science High School Curriculum in Israel and Lithuania – Comparison and Teachers Views.pdf">觀點</a>), 因為解決問題必須要將能精確運用或搜尋到對的知識, 將直覺過程轉化為電腦能夠處理的格式. 越早針對有興趣解題的領域啟蒙, 便越能及早在求學階段獲取相應的知識, 加入適當的團隊, 逐步透過專案解題, 累積更多經驗. 以下是 Bill Gates 述說其早年與計算機程式學習及應用有關的歷程.</p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/vYXQTrYPenQ" title="YouTube video player" width="560"></iframe></p>
<h4>參考資料:</h4>
<p style="padding-left: 30px;">Repository: <a href="https://github.com/mdecourse/cp2021">https://github.com/mdecourse/cp2021</a></p>
<p style="padding-left: 30px;">Github Pages: <a href="https://mde.tw/cp2021">https://mde.tw/cp2021</a></p>
<p style="padding-left: 30px;">Github 簡介: <a href="https://docs.microsoft.com/zh-tw/learn/modules/introduction-to-github/">https://docs.microsoft.com/zh-tw/learn/modules/introduction-to-github/</a></p>
<p style="padding-left: 30px;">Github Actions: <a href="https://docs.microsoft.com/zh-tw/learn/modules/github-actions-automate-tasks/">https://docs.microsoft.com/zh-tw/learn/modules/github-actions-automate-tasks/</a></p>
<p style="padding-left: 30px;">LaTeX 教學: <a href="https://wdv4758h.github.io/notes/documentation/latex.html">https://wdv4758h.github.io/notes/documentation/latex.html</a></p>
<p style="padding-left: 60px;"><a href="https://github.com/marketplace/actions/latex-action">https://github.com/marketplace/actions/latex-action</a></p>
<p style="padding-left: 30px;">Zulipchat: <a href="https://kmolab.zulipchat.com">https://kmolab.zulipchat.com</a></p>
<p style="padding-left: 30px;">RoboDK: <a href="https://robodk.com">https://robodk.com</a></p>
<p style="padding-left: 30px;">RoboDK API: <a href="https://robodk.com/doc/en/PythonAPI/">https://robodk.com/doc/en/PythonAPI/</a> (<a href="https://github.com/RoboDK/RoboDK-API">RoboDK-API on Github</a>)</p>
<h4>電腦輔助設計室與協同設計室行事曆:</h4>
<p style="padding-left: 30px;"><a href="https://calendar.google.com/calendar/embed?src=mde.nfu.edu.tw_3439313938333136353439%40resource.calendar.google.com&amp;ctz=Asia%2FTaipei&amp;mode=week&amp;src=mde.nfu.edu.tw_35303530373431313438%40resource.calendar.google.com&amp;ctz=Asia%2FTaipei&amp;src=yen%40gm.nfu.edu.tw&amp;ctz=Asia%2FTaipei">全頁檢視</a></p>
<p><iframe height="600" src="https://calendar.google.com/calendar/embed?src=mde.nfu.edu.tw_3439313938333136353439%40resource.calendar.google.com&amp;ctz=Asia%2FTaipei&amp;mode=week&amp;src=mde.nfu.edu.tw_35303530373431313438%40resource.calendar.google.com&amp;ctz=Asia%2FTaipei&amp;src=yen%40gm.nfu.edu.tw&amp;ctz=Asia%2FTaipei" width="800"></iframe></p><h2>學習程式</h2>
<p>機械設計專長的工程師除了熟悉 Windows 操作系統外, 之所以還必須學習操作 Unix 系列的系統, 是因為機械設計流程牽涉許多機電資相關跨領域專長細節, 過程中需要透過集中或分散式架構與多人進行協同, 能夠將編寫程式的平台擴及 Windows 與 Unix 操作系統 (包含 Linux 與 MacOS), 預計可增進配置系統的範圍與彈性, 強化機械設計工作效能.</p>
<p>在學習各種電腦操作系統的過程, 除了一般 GUI 文字編輯器外, 在 Unix terminal 中, 還必須學習利用純文字介面編輯器, <a href="/downloads/Learning_the_vi_Editor.pdf">Learning_the_vi_Editor.pdf</a> 執行文字資料編輯.</p>
<p>以下為與 Unix 及 Windows 操作系統有關的開發年表:</p>
<p><img caption="false" class="add_border" height="463" src="/images/what_is_unix.png" width="600"/></p>
<h4>Windows OS versions:</h4>
<p><img alt="" class="add_border" height="304" src="/images/windows_os_version.png" width="600"/>(Source: <a href="https://en.wikipedia.org/wiki/Microsoft_Windows">https://en.wikipedia.org/wiki/Microsoft_Windows</a>)</p>
<hr/>
<p>學習計算機程式語言的態度建議: <a href="https://learnpythonthehardway.org/book/intro.html">https://learnpythonthehardway.org/book/intro.html</a></p>
<ol>
<li>必得<span style="text-decoration: underline;"><span style="background-color: #ffff99;">花工夫</span></span>才學得來 (The hard way is easier, <a href="https://betterprogramming.pub/why-you-should-learn-to-program-the-hard-way-7961df96c5c5">ref1</a>, <a href="https://www.freecodecamp.org/news/learn-to-code-the-hard-way-65dece5b0005/">ref2</a>)</li>
<li>自己<span style="text-decoration: underline;"><span style="background-color: #ffff99;">讀資料</span></span>自己<span style="text-decoration: underline;"><span style="background-color: #ffff99;">刻每一行程式碼</span></span> (Focus on reading and writing (learn how to touch typing), <a href="https://www.pitman-training.com/advice-hub/pitman-blog/why-is-it-important-to-touch-type/">ref1</a>, <a href="https://www.readandspell.com/why-is-keyboarding-important">ref2</a>, <a href="https://davidzych.com/how-important-is-typing-ability/">ref3</a>)</li>
<li>要<span style="text-decoration: underline;"><span style="background-color: #ffff99;">注重</span></span>每一個<span style="text-decoration: underline;"><span style="background-color: #ffff99;">細節</span></span> (Pay attention to every detail, <a href="http://programmingstage.blogspot.com/2012/05/paying-attention-to-detail.html">ref1</a>, <a href="https://www.eskimo.com/~scs/cclass/progintro/sx1.html">ref2)</a></li>
<li>要能<span style="text-decoration: underline;"><span style="background-color: #ffff99;">發現差異</span></span> (To be able to spot the differences, <a href="https://www.codementor.io/blog/good-vs-great-developers-4ln36zvwhg">ref1</a>, <a href="https://devskiller.com/coder-vs-programmer/">ref2</a>)</li>
<li>千萬<span style="text-decoration: underline;"><span style="background-color: #ffff99;">不要只是複製貼上</span></span> (Do not just copy-paste)</li>
<li>多<span style="text-decoration: underline;"><span style="background-color: #ffff99;">觀看</span></span>相關<span style="text-decoration: underline;"><span style="background-color: #ffff99;">操作示範</span></span>影片 (Watch the related videos)</li>
<li>多<span style="text-decoration: underline;"><span style="background-color: #ffff99;">練習</span></span>而且要<span style="background-color: #ffff99;">不斷<span style="text-decoration: underline;">學習</span></span> (Practice more and keep learning)</li>
<li>學習如何<span style="background-color: #ffff99;"><a href="https://stackoverflow.com/help/how-to-ask" style="background-color: #ffff99;">問一個好問題</a></span> (Learn how to ask a good question)</li>
</ol>
<p>計算機程式學習 Python 目標: 編寫可以用於<span style="text-decoration: underline;"><span style="background-color: #ffff99;">機電資自動化整合系統設計與模擬</span></span>用的<span style="text-decoration: underline;"><span style="background-color: #ffff99;">網際程式</span></span>.</p>
<p><span style="background-color: #ccffcc;">Web Browser &lt;-&gt; Client </span>&lt;-&gt; Brython &lt;-&gt; Flask &lt;-&gt; <span style="background-color: #ccffcc;">Server &lt;-&gt; RoboDK, CoppeliaSim and Webots</span></p>
<h4>Online courses:</h4>
<p style="padding-left: 30px;"><a href="https://kmolyuan.github.io/program-learning/index.html">https://kmolyuan.github.io/program-learning/index.html</a></p>
<p style="padding-left: 30px;"><a href="https://www.youtube.com/watch?v=Ps8jOj7diA0&amp;list=PL8ED50412A17D4C8B">https://www.youtube.com/watch?v=Ps8jOj7diA0&amp;list=PL8ED50412A17D4C8B</a> (Stanford) - 27 lectures<span style="background-color: #ccffcc;"><br/></span></p>
<p style="padding-left: 30px;"><a href="https://www.youtube.com/watch?v=8DvywoWv6fI">https://www.youtube.com/watch?v=8DvywoWv6fI</a> (Michigan) - 13:40:09</p>
<p style="padding-left: 30px;"><a href="https://www.youtube.com/watch?v=rfscVS0vtbw">https://www.youtube.com/watch?v=rfscVS0vtbw</a> (Freecodecamp) - 4:26:51</p>
<h4>Examples:</h4>
<p style="padding-left: 30px;"><a href="https://medium.com/@patrickbfuller/a-simple-flask-app-edeed75dbee2">https://medium.com/@patrickbfuller/a-simple-flask-app-edeed75dbee2</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/Patrickbfuller/simple_flask">https://github.com/Patrickbfuller/simple_flask</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/mileserickson/flask-brython-example">https://github.com/mileserickson/flask-brython-example</a></p>
<p style="padding-left: 30px;"><a href="https://pypi.org/project/brython-server/">https://pypi.org/project/brython-server/</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/andy31lewis/brySVG">https://github.com/andy31lewis/brySVG</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/dunossauro/todo_list_flask_brython">https://github.com/dunossauro/todo_list_flask_brython</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/DarthBayo/Encrypt">https://github.com/DarthBayo/Encrypt</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/chfw/brython-pack">https://github.com/chfw/brython-pack</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/rayluo/brip">https://github.com/rayluo/brip</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/rayluo/brython-project-template">https://github.com/rayluo/brython-project-template</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/rayluo/draggable-svg">https://github.com/rayluo/draggable-svg</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/Shohrab-Hossain/Tic-Tac-Toe-web">https://github.com/Shohrab-Hossain/Tic-Tac-Toe-web</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/denisecase/chapstack">https://github.com/denisecase/chapstack</a></p>
<p style="padding-left: 30px;"><a href="https://gitlab.com/sammdu/bot-tac-toe/">https://gitlab.com/sammdu/bot-tac-toe/</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/mdecourse/lookupdict">https://github.com/mdecourse/lookupdict</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/mdecourse/scissor-rock-paper2">https://github.com/mdecourse/scissor-rock-paper2</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/mdecourse/wcms-scrum1">https://github.com/mdecourse/wcms-scrum1</a></p>
<h4>學習運用 Python:</h4>
<p style="padding-left: 30px;"><a href="https://mde.tw">KMOLab</a> 認為, 機械設計工程師在大一之所以先學習運用 Python, 是因為透過網際 Python 的教學, 可以快速解決一些簡單的工程問題, 加上網際 HTML 與 WebGL 中的 Canvas, 學員可以透過動畫與簡單線上遊戲, 逐步了解變數, 函式, 重複迴圈, 判斷式, 滑鼠事件與基本物件導向程式的概念.</p>
<p style="padding-left: 30px;">接下來若再能透過 Flask 與 SolidWorks (<a href="https://mde.tw/cad2020/content/HW1_SW.html">範例</a>), Inventor (<a href="https://mde.tw/cad2020/content/HW1_INV.html">範例</a>) 及 NX12 (<a href="https://mde.tw/cad2020/content/HW1_NX.html">範例</a>) 的 API 進行互動, 使用者就可以在先前電腦輔助繪圖的技術能力中, 培養參數化與動態系統對於協同產品設計的配置能力.</p>
<p style="padding-left: 30px;">在此一學習程式的過程中, 使用者會先接觸 Python 以及 Javascript, 隨著網際內容管理的需求, HTML 與 CSS 的基本運用就會逐一成為必要能力.</p>
<p style="padding-left: 30px;">由於 Github Pages 不允許伺服 __init__.py 檔案, 因此必須將 <a href="https://github.com/BrythonServer/ggame">ggame</a> 採用 <a href="https://brython.info/static_doc/en/import.html">https://brython.info/static_doc/en/import.html</a> 中 Optimization 的方式轉為 brython_modules.js 後直接以 script 標註導入頁面.</p>
<h4 style="padding-left: 30px;">將 ggame 中的 Brython 程式碼轉為 brython_modules.js 的方法:</h4>
<p style="padding-left: 60px;">在可攜系統中的 Python 安裝 brython 模組: pip install brython</p>
<p style="padding-left: 60px;">將所安裝 brython 模組中的 brython_stdlib.js 複製一份到 ggame 倉儲中, 確定目前 ggame 目錄架構為:</p>
<p style="padding-left: 60px;">brython_stdlib.js</p>
<p style="padding-left: 60px;">ggame</p>
<p style="padding-left: 60px;">意即 ggame 目錄中有 brython_stdlib.js 與 ggame brython 模組原始碼.</p>
<p style="padding-left: 60px;">接下來執行 y:\tmp\github\ggame&gt;python -m brython --modules</p>
<p style="padding-left: 60px;">完成後, 就可以在 y:\tmp\github\ggame&gt; 目錄中建立 brython_modules.js</p>
<p style="padding-left: 60px;">以本頁面的作法是將 ggame 所需的 graphics 檔案放至 images 目錄中, 而 brython_modules.js 則放至 downloads 目錄後, 以 /downloads/brython_modules.js 放入 script 標註中引用.</p>
<p style="padding-left: 30px;">Python 3 官方教材: <a href="https://docs.python.org/3/index.html">https://docs.python.org/3/index.html</a></p>
<p style="padding-left: 30px;">Python tutorial: <a href="https://docs.python.org/3/tutorial/index.html">https://docs.python.org/3/tutorial/index.html</a> (英文)</p>
<p style="padding-left: 30px;">Python tutorial: <a href="https://docs.python.org/zh-tw/3/tutorial/">https://docs.python.org/zh-tw/3/tutorial/</a> (中文)</p>
<p style="padding-left: 30px;"><a href="https://link.springer.com/book/10.1007/978-981-10-3277-6">Programming with Python</a> (校園網路下載電子書)</p>
<p style="padding-left: 30px;"><a href="/downloads/ProblemSolvingwithAlgorithmsandDataStructures.pdf">利用演算法 (Algorithms) 與資料結構 (Data Structures) 解題</a> (英文) (<a href="https://www.cs.auckland.ac.nz/compsci105s1c/resources/">來源</a>)</p>
<p style="padding-left: 60px;"><a href="/downloads/Algorithms.pdf">Algorithms.pdf</a></p>
<p style="padding-left: 60px;"><a href="https://link.springer.com/book/10.1007/978-1-84800-070-4">The Algorithm Design Manual</a> (校園網路下載電子書)</p>
<p style="padding-left: 30px;">網頁上的 Python - Brython: <a href="https://www.brython.info/static_doc/en/intro.html">https://www.brython.info/static_doc/en/intro.html</a> (解譯式)</p>
<p style="padding-left: 60px;"><a href="http://brython.info/gallery/?C=M;O=D">Brython Gallery</a></p>
<p style="padding-left: 30px;">網頁上的 Python GUI- Flexx: <a href="https://flexx.readthedocs.io/en/stable/">https://flexx.readthedocs.io/en/stable/</a> (轉譯式)</p>
<h4>學習運用 C:</h4>
<p style="padding-left: 30px;">過去機械設計工程師學習 C, 或許著眼在數值分析, 期望透過 C 程式解微分方程式, 對系統模型進行最佳化分析, 但是現在使用 <a href="https://www.python.org/">Python</a> + <a href="https://numpy.org/">numpy</a> + <a href="https://www.scipy.org/">scipy</a> + <a href="https://matplotlib.org/">matplotlib</a> + <a href="https://cython.org/">Cython</a>, 不僅可以快速建立系統模型, 一旦透過 <a href="https://cython.org/">Cython</a> 轉換為最終的編譯程式, 執行速度也可以很接近 C, 因此目前機械設計工程師之所以仍需要學習 C 的原因, 已經轉為機電系統控制, 期望透過 C 的可攜性, 能夠在各種控制硬體 (晶片) 上進行取捨.</p>
<p style="padding-left: 30px;">尤其現在的個人電腦已經全面採用 <a href="https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface">UEFI</a> 開機, 機械設計工程師在機電資整合產品開發流程中, 對於運用 C 程式編寫電腦底層的軟體元件有較大的空間 (相對於之前的 <a href="https://en.wikipedia.org/wiki/BIOS">BIOS</a> 可能<a href="https://softwareengineering.stackexchange.com/questions/298628/which-programming-language-is-used-to-write-a-bios-program">需要採組合語言編寫</a>).</p>
<p style="padding-left: 30px;"><a href="/downloads/C_Programming.pdf">C_Programming.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/EssentialC.pdf">EssentialC.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/ModernC.pdf">ModernC.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/gnu_c_programming_tutorial.pdf">gnu_c_programming_tutorial.pdf</a></p>
<h3>程式儲存</h3>
<p>利用<a href="https://mde.tw/cp2021/content/%E8%A7%A3%E9%A1%8C%E7%B7%B4%E7%BF%92.html">解題練習</a>頁面可以直接在瀏覽器上練習編寫簡單的 Python 程式, 而寫好的 Python 程式應該存在哪裡?</p>
<p>由於 <a href="https://mde.tw">KMOLab</a> 所開設的課程, 都要求學員要申請 <a href="https://github.com/">Github</a>, <a href="https://gitlab.com">Gitlab</a>, <a href="https://bitbucket.org/">Bitbucket</a> 與 <a href="https://www.heroku.com/">Heroku</a> 帳號, 而且要使用 Github 倉儲與網頁紀錄各自的學習歷程, 因此直接在瀏覽器上編寫的 Python 程式, 可以分別存在倉儲的 downloads 目錄, 以及 Github 帳號下對應的 Gist 區.</p>
<p>亦即:</p>
<ol>
<li>假如採用近端隨身程式系統, 編寫程式後同時維護各自倉儲的動態與靜態網頁, 則所編寫的 Python 程式, 可以同時存在倉儲 downloads 區, 以及將程式複製存入個人 Github 帳號下的 Gist 區.</li>
<li>假如沒有使用近端隨身程式系統, 只有利用電腦瀏覽器或 Chromebook 等硬體, 可以在 Python 程式定版後, 直接複製到個人帳號下的 Gist 區儲存及引用.</li>
</ol>
<p>採用 <a href="https://github.com/mdecourse/cmsimde">CMSiMDE</a> 作為動態與靜態網頁的倉儲, 其 downloads 目錄中的檔案, 可以直接透過 URL 擷取, 雖然也可納入 Git 分散式版次管理, 但是管理與引用沒有 Gist 方便. 因為每一個 Github Gist 中所儲存的程式, 可以根據實習階段將同一組程式集合在同一個版次號下 (帳號下的 Gist 編號), 然後再用該編號下的檔案編號擷取同一組 Gist 下的不同版次程式.</p>
<h4>例如:</h4>
<p style="padding-left: 30px;"><a href="https://gist.githubusercontent.com/mdecourse/e896a4705a95ac8cc4147b355b0e87ef/raw/3f98d46cdf791bd764beca645950a69f90e651c9/three_spur_rotating.py">第一版的 three_spur_rotating.py</a> (<a href="https://mde.tw/cp2021/content/run.html?src=https://gist.githubusercontent.com/mdecourse/e896a4705a95ac8cc4147b355b0e87ef/raw/3f98d46cdf791bd764beca645950a69f90e651c9/three_spur_rotating.py">執行</a>)</p>
<p style="padding-left: 30px;">修正各齒輪中心點位置的<a href="https://gist.githubusercontent.com/mdecourse/e896a4705a95ac8cc4147b355b0e87ef/raw/8954b8280c524c5781dc3c0b3565bc489d3aa3a3/three_spur_rotating.py">第二版 three_spur_rotating.py</a> (<a href="https://mde.tw/cp2021/content/run.html?src=https://gist.githubusercontent.com/mdecourse/e896a4705a95ac8cc4147b355b0e87ef/raw/8954b8280c524c5781dc3c0b3565bc489d3aa3a3/three_spur_rotating.py">執行</a>)</p>
<h4 style="padding-left: 30px;">延伸練習題:</h4>
<p style="padding-left: 60px;">上面這個程式可以設法再利用 Brython 增加三個輸入表單分別設定各齒輪的齒數, 可以在各位對 Brython 與 HTML 更加了解之後當作練習題目.</p>
<p style="padding-left: 60px;">也可以與正齒輪傳動組的<a href="https://wcms-scrum1.herokuapp.com/gear_index">齒面寬設計</a>題目 (<a href="https://github.com/mdecourse/wcms-scrum1">原始碼</a>) 結合. 在設計運算完成後, 利用 SVG (或 DXF) 畫出正齒輪輪廓, 進入 CAD 長出厚度後, 以 3D 列印出所需要的正齒輪零件.</p>
<p>由於每一個 Gist 也是 Repository, 因此利用 Gist 儲存 Python 程式, 可以很清楚查詢每一個改版內容間的差異, 例如: 以 <a href="https://www.arc.id.au/CanvasGraphics.html">Cango 程式庫</a>編寫的<a href="https://gist.github.com/mdecourse/e896a4705a95ac8cc4147b355b0e87ef/revisions">正齒輪模擬範例程式</a> (<a href="https://mde.tw/cp2021/content/run.html?src=https://gist.githubusercontent.com/mdecourse/e896a4705a95ac8cc4147b355b0e87ef/raw/8954b8280c524c5781dc3c0b3565bc489d3aa3a3/cango_gear1.py">執行</a>).</p>
<p>而且如 <a href="https://mde.tw/cp2021/content/Cango.html">Cango 程式範例</a>頁面所示, 使用者將 Python 程式 (或 Brython 程式) 儲存至 Gist 之後, 可以再利用以下的 beditor.py, 在網頁中安排按鈕, 點擊後可將 Gist 中所存放的 Python 程式版本放入網際程式編輯區, 按下 Run 後就可以直接執行.</p>
<p>beditor.py</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import ace
import json
from browser import document as doc

class gist():
    """gist class to get program from Python gist"""
    def __init__(self, id, filename):
        self.id = id
        self.filename = filename
        
    def get_file(self):
        url = 'https://api.github.com/gists/' + self.id
        # info is string
        info = open(url).read()
        gist = json.loads(info)
        return gist["files"][self.filename]["content"]
    
class editor():
    """ace brython editor"""
    def __init__(self, script, editor_id, console_id, container_id, storage_id):
        self.script = script
        self.editor_id = editor_id
        self.console_id = console_id
        self.container_id = container_id
        self.storage_id = storage_id
        self.Ace = ace.Editor(editor_id=self.editor_id
                        , console_id=self.console_id
                        , container_id=self.container_id
                        , storage_id=self.storage_id)
    
    # 所有的 button 程式碼中, 選擇一個執行 setValue(), 可以顯示在對應 id 的程式編輯區
    def setValue(self):
        self.Ace.editor.setValue(self.script)

    def prog(self, ev):
        '''Ace = ace.Editor(editor_id="kw_editor"
                        , console_id="kw_console"
                        , container_id="kw__container"
                        , storage_id="kw_py_src" )
        '''
        '''
        Ace = ace.Editor(editor_id=self.editor_id
                        , console_id=self.console_id
                        , container_id=self.container_id
                        , storage_id=self.storage_id)
        '''
        self.Ace.editor.setValue(self.script)
        self.Ace.editor.scrollToRow(0)
        self.Ace.editor.gotoLine(0)
    
    def run(self, ev):
        self.Ace.run(ev)
        
    def show_console(self, ev):
        self.Ace.show_console(ev)
        
    def clear_console(self, ev):
        self.Ace.clear_console(ev)
        
    def clear_container(self, ev):
        self.Ace.clear_container(ev)
</pre>
<p>所引用的網際編輯程式則是 ace.py, 也就是居中使用了 Javascript 所編寫的 <a href="https://ace.c9.io/">Ace editor</a>.</p>
<p>ace.py</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import sys
import time
import traceback
import javascript

from browser import document as doc, window, alert

if hasattr(window, 'localStorage'):
    from browser.local_storage import storage
else:
    storage = None

class cOutput:

    def __init__(self, target):
        self.target = doc[target]

    def write(self, data):
        self.target.value += str(data)

class Editor():
    
    def __init__(self, editor_id, console_id, container_id, storage_id):
        self.editor_id = editor_id
        self.console_id = console_id
        self.container_id = container_id
        self.storage_id = storage_id
        self.output = ''

        try:
            self.editor = window.ace.edit(self.editor_id)
            session = self.editor.getSession()
            session.setMode("ace/mode/python")

            self.editor.setOptions({
             'enableLiveAutocompletion': True,
             'enableSnippets': True,
             'highlightActiveLine': False,
             'highlightSelectedWord': True,
             'autoScrollEditorIntoView': True,
             # 'maxLines': session.getLength() 可以根據程式長度設定 editor 列數
             # 設定讓使用者最多可以在畫面中顯示 20 行程式碼
             'maxLines': 20,
             'fontSize': '12pt'
            })
        except:
            from browser import html
            self.editor = html.TEXTAREA(rows=20, cols=70)
            doc[self.editor_id] &lt;= self.editor
            def get_value(): return self.editor.value
            def set_value(x): self.editor.value = x
            self.editor.getValue = get_value
            self.editor.setValue = set_value
            
    def run(self, *args):
        sys.stdout = cOutput(self.console_id)
        sys.stderr = cOutput(self.console_id)
        doc[self.console_id].value = ''
        src = self.editor.getValue()
        if storage is not None:
           storage[self.storage_id] = src

        t0 = time.perf_counter()
        try:
            #ns = {'__name__':'__main__'}
            # 以 self.editor_id 名稱執行程式
            #ns = {'__name__': self.editor_id}
            # execute program under the __main__ name
            ns = {'__name__':'__main__'}
            exec(src, ns)
            state = 1
        except Exception as exc:
            traceback.print_exc(file=sys.stderr)
            state = 0
        self.output = doc[self.console_id].value

        print('&lt;completed in %6.2f ms&gt;' % ((time.perf_counter() - t0) * 1000.0))
        return state

    def show_console(self, ev):
        doc[self.console_id].value = self.output
        doc[self.console_id].cols = 60
        doc[self.console_id].rows = 10
        
    def clear_console(self, ev):
        doc[self.console_id].value = ""
        
    def clear_container(self, ev):
        doc[self.container_id].clear()

    # load a Python script
    def load_script(self, evt):
        _name = evt.target.value + '?foo=%s' % time.time()
        self.editor.setValue(open(_name).read())

</pre>
<p></p>
<h3>Canvas</h3>
<h4>參考資料:</h4>
<p style="padding-left: 30px;"><a href="https://milneopentextbooks.org/the-missing-link-an-introduction-to-web-development-and-programming/">The Missing Link: An Introduction to Web Development and Programming</a> (從 page 60 開始 Section2 - Document Markup)</p>
<p style="padding-left: 30px;"><a href="https://link.springer.com/book/10.1007/978-1-4302-3292-6">Foundation HTML5 Canvas</a> (從校園網路中下載)</p>
<p>Typical HTML5 page.</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;This is a basic html page&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!-- 導入 brython Javascript 程式庫 --&gt;
&lt;script src="/static/brython.js"&gt;&lt;/script&gt;
&lt;script src="/static/brython_stdlib.js"&gt;&lt;/script&gt;
&lt;!-- 啟動 Brython, debug 為 True, 模組可放入 /static/ 或 ./../downloads/py/ 目錄中 --&gt;
&lt;script&gt;
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
&lt;/script&gt;
&lt;p&gt;Hello HTML5!&lt;/p&gt;
&lt;!-- 建立一個 id="brython_div" 的 div 元件 --&gt;
&lt;div id="brython_div"&gt;&lt;/div&gt;
&lt;!-- 編寫 Brython 程式 --&gt;
&lt;script type="text/python"&gt;
# 導入 browser 模組中的 html 物件
from browser import html
# 導入 browser 模組中的 document 物件
from browser import document

# 建立輸入用的 DIV 元件
output_div = html.DIV(id="output")
# 將 DIV 元件插入 brython_div 位置
document["brython_div"] &lt;= output_div

# 定義一個 send_text() 函式, 因為是透過 bind 或 addEventListener 事件綁定, 要有輸入變數 ev
count = 0
def send_text(ev):
    global count
    # 因為 count 在外部宣告, 且在函式內更動對應, 因此要設為 global
    count += 1
    # 利用 document[]指定 id="output" 的元件, 令其 html 為 html.H1() 物件的 text 內容
    document["output"].innerHTML = html.H1("my button clicked!" + " 按第 " + str(count) + " 次.").text

# 建立一個標示 "my button" 且 id="my_button" 的 button 元件
document["brython_div"] &lt;= html.BUTTON("my button", id="my_button")
# 將 id="my_button" 的元件透過事件 listener 與 send_text 函式綁定
# 可以使用 bind 或 addEventListener 等方法進行綁定
document["my_button"].bind("click", send_text)
#document["my_button"].addEventListener("click", send_text)
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial">https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial</a></p>
<p style="padding-left: 30px;"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Basic_usage">Basic Usage</a></p>
<p style="padding-left: 30px;"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes">Drawing Shapes</a></p>
<p><a href="https://www.w3schools.com/html/html5_canvas.asp">https://www.w3schools.com/html/html5_canvas.asp</a></p>
<!-- 導入 brython Javascript 程式庫 -->
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
<!-- 啟動 Brython, debug 為 True, 模組可放入 /static/ 或 ./../downloads/py/ 目錄中 -->
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
<p>Hello HTML5!</p>
<!-- 建立一個 id="brython_div" 的 div 元件 -->
<div id="brython_div"></div>
<!-- 編寫 Brython 程式 -->
<script type="text/python">
# 導入 browser 模組中的 html 物件
from browser import html
# 導入 browser 模組中的 document 物件
from browser import document

# 建立輸入用的 DIV 元件
output_div = html.DIV(id="output")
# 將 DIV 元件插入 brython_div 位置
document["brython_div"] <= output_div

# 定義一個 send_text() 函式, 因為是透過 bind 或 addEventListener 事件綁定, 要有輸入變數 ev
count = 0
def send_text(ev):
    global count
    # 因為 count 在外部宣告, 且在函式內更動對應, 因此要設為 global
    count += 1
    # 利用 document[]指定 id="output" 的元件, 令其 html 為 html.H1() 物件的 text 內容
    document["output"].innerHTML = html.H1("my button clicked!" + " 按第 " + str(count) + " 次.").text

# 建立一個標示 "my button" 且 id="my_button" 的 button 元件
document["brython_div"] <= html.BUTTON("my button", id="my_button")
# 將 id="my_button" 的元件透過事件 listener 與 send_text 函式綁定
# 可以使用 bind 或 addEventListener 等方法進行綁定
document["my_button"].bind("click", send_text)
#document["my_button"].addEventListener("click", send_text)
</script><h3>Zulip</h3>
<p><a href="https://mde.tw">KMOLab</a> 自 2021 Fall 起, 開始試用 Zulip.</p>
<p>Zulip (<a href="https://zulip.com/history/">發展歷史</a>) 為一套以 Python 編寫, 用於 team chat 的開源套件:</p>
<p style="padding-left: 30px;"><a href="https://en.wikipedia.org/wiki/Zulip">https://en.wikipedia.org/wiki/Zulip</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/zulip/zulip">https://github.com/zulip/zulip</a></p>
<p style="padding-left: 30px;"><a href="https://kmolab.zulipchat.com">https://kmolab.zulipchat.com</a></p>
<p style="padding-left: 30px;"><a href="https://buildmedia.readthedocs.org/media/pdf/zulip/1.7.0/zulip.pdf">Zulip Documentation</a></p>
<p style="padding-left: 30px;"><a href="https://zulip.readthedocs.io/en/stable/production/install.html">Zulip Installation Guide</a></p>
<p style="padding-left: 30px;"><a href="https://www.atlantic.net/vps-hosting/install-zulip-chat-server-on-ubuntu-20-04/">在 Ubuntu 20.04 安裝 Zulip</a></p>
<p>使用官方免費 Zulip 限制 (<a href="https://zulip.com/plans/">來源</a>):</p>
<ol>
<li>10,000 messages of search history (只能搜尋<span style="background-color: #ffff99;">一萬筆</span>留言訊息)</li>
<li>File storage up to 5 GB total (總檔案容量至多 <span style="background-color: #ffff99;">5GB</span>)</li>
<li>Full-featured team chat service (全功能團隊對話服務)</li>
<li>Hundreds of integrations (幾百種整合功能)</li>
<li>Advanced roles and permissions (高階角色與權限許可)</li>
<li>Guest accounts (支援訪客帳號)</li>
</ol>
<p>Zulip 以 Stream (對談串) 來命名聊天室, 而在每一個對談串可以建立對談主題 (Topics).</p>
<p>例如:</p>
<p style="padding-left: 30px;"><a href="https://kmolab.zulipchat.com/#narrow/stream/292134-2021-Fall">2021 Fall</a> 是一個由 <a href="https://mde.tw">KMOLab</a> 所建立的 Zulip 對談串, 其中包含兩個對談主題:</p>
<p style="padding-left: 60px;"><a href="https://kmolab.zulipchat.com/#narrow/stream/292134-2021-Fall/topic/.E9.9B.BB.E8.85.A6.E8.BC.94.E5.8A.A9.E8.A8.AD.E8.A8.88.E5.AF.A6.E7.BF.92">電腦輔助設計實習主題</a>與<a href="https://kmolab.zulipchat.com/#narrow/stream/292134-2021-Fall/topic/.E8.A8.88.E7.AE.97.E6.A9.9F.E7.A8.8B.E5.BC.8F">計算機程式主題</a></p>
<p>Zulip 與 Gitter 最大的差別:</p>
<ol>
<li><a href="https://github.com/zulip/zulip">Zulip server</a> 以 Python 編寫, <a href="https://gitlab.com/gitterHQ/webapp">Gitter server</a> 以 node.js 編寫.</li>
<li>Zulip 支援較多的 <a href="https://zulip.com/help/format-your-message-using-markdown">Markdown</a> 語法功能.</li>
<li>Zulip 可以在對談串間搬動討論主題內容.</li>
<li>Zulip 支援以 Python 編寫的<a href="https://github.com/zulip/zulip-terminal">命令列介面</a>工具.</li>
</ol><h2>機械設計知識</h2>
<p><a href="https://brython.info/">Brython</a> (Browser Python) 在網頁的執行速度並不很快, 因此比較適合初學者用來學習 Python 語法. 或者透過 WebGL 編寫架構較為簡單的機械設計模擬程式. 也可以與 Server 端的 Python + Flask 結合, 將功能較為完整的 Javascript 導入為程式庫.</p>
<p>對於機械設計相關, 運算較複雜的流程, 可以採用 Python + <a href="https://cython.org/">Cython</a> 寫為動態連結程式庫. 或者利用 Rust 編寫可以讓 Python 呼叫的動態連結程式庫 (有人甚至認為: <a href="https://towardsdatascience.com/thought-you-loved-python-wait-until-you-meet-rust-64a06d976ce">以為喜歡 Python? 等遇見 Rust 之後再說</a> (<a href="https://github.com/KmolYuan?tab=repositories">呈堂見證</a>, 以 Rust 寫的 Python 解譯器: <a href="https://github.com/RustPython/RustPython">RustPython</a>). 有興趣請參閱, <a href="https://stackoverflow.blog/2020/01/20/what-is-rust-and-why-is-it-so-popular/">為何 Rust 如此受歡迎</a>?). 至於前端運算較複雜的程式, 則可以採用 <a href="https://www.typescriptlang.org/">Typescript</a> 或 <a href="https://www.rust-lang.org/">Rust</a> + <a href="https://webassembly.org/">Wasm</a> 的方式編寫.</p>
<h4>以下是與機械設計有關的內容, 大部分電子書可以從校園網路中下載:</h4>
<p><a href="https://pythonnumericalmethods.berkeley.edu/notebooks/Index.html">Python Programming And Numerical Methods: A Guide For Engineers And Scientists</a></p>
<p><a href="https://www.algorist.com/algorist.html">Algorithm Design Manual</a></p>
<p><a href="http://mde.tw/cad2020/content/%E8%A8%AD%E8%A8%88%E6%9C%80%E4%BD%B3%E5%8C%96.html">設計最佳化</a></p>
<p><a href="https://link.springer.com/book/10.1007/978-3-030-15195-9">Fundamental University Physics</a> (在校園網路下載電子書)</p>
<p><a href="https://link.springer.com/book/10.1007/978-1-4615-0487-0">Optimal Synthesis Methods for MEMS</a> (在校園網路下載電子書)</p>
<p><a href="https://link.springer.com/book/10.1007/978-3-642-22938-1">Wind Power Plants</a> (在校園網路下載電子書)</p>
<p><a href="https://link.springer.com/book/10.1007/978-3-642-23026-4">Principles of Physics</a> (在校園網路下載電子書)</p>
<p><a href="https://link.springer.com/book/10.1007/978-3-642-30319-7">Statics</a> 靜力學 (在校園網路下載電子書)</p>
<p><a href="https://link.springer.com/book/10.1007/978-3-662-56272-7">Mechanics of Materials</a> 材料力學 (在校園網路下載電子書)</p>
<p><a href="https://link.springer.com/book/10.1007/978-3-319-01851-5">Fundamentals of Robotic Mechanical Systems</a> (在校園網路下載電子書)</p>
<p><a href="https://link.springer.com/referencework/10.1007/978-3-540-30738-9">Springer Handbook of Mechanical Engineering</a> (在校園網路下載電子書)</p>
<p><a href="https://link.springer.com/book/10.1007/978-0-387-68208-2">Precision Manufacturing</a> (在校園網路下載電子書)</p>
<p><a href="https://link.springer.com/book/10.1007/978-1-84800-336-1">Theory and Design of CNC Systems</a> (在校園網路下載電子書)</p>
<p><a href="https://link.springer.com/book/10.1007/b138168">Multibody Mechanics and Visualization</a> (在校園網路下載電子書)</p>
<p><a href="https://link.springer.com/book/10.1007/b137216">Screw Compressors</a> (在校園網路下載電子書)</p>
<p><a href="https://link.springer.com/book/10.1007/978-3-662-05086-6">Topology Optimization</a> (在校園網路下載電子書)</p>
<p><a href="https://link.springer.com/book/10.1007/978-1-4020-2110-7">Fundamentals of Mechanicsof Robotic Manipulation</a> (在校園網路下載電子書)</p>
<p><a href="https://link.springer.com/book/10.1007/978-0-85729-394-7">Managing Engineering Design</a> (在校園網路下載電子書)</p>
<p><a href="https://link.springer.com/book/10.1007/978-3-662-05302-7">General Spatial Involute Gearing</a> (在校園網路下載電子書)</p>
<p><a href="https://link.springer.com/book/10.1007/978-3-662-08013-9">Inventive Thinking through TRIZ</a> (在校園網路下載電子書)</p>
<p><a href="https://link.springer.com/book/10.1007/978-1-4757-2872-9">A Mathematical Theory of Design</a> (在校園網路下載電子書)</p><h3>RL</h3>
<p>將 <a href="https://mde.tw/cp2021/content/run.html?src=https://gist.githubusercontent.com/mdecourse/3db55f124185def5aac8e5d51579c484/raw/181374bcd9a1e74f0701635131e5cf0a52259af6/snake_slope.py">snake_slope.py</a> 與 <a href="https://mde.tw/cp2021/content/run.html?src=https://gist.githubusercontent.com/mdecourse/3db55f124185def5aac8e5d51579c484/raw/9f1df758ac7fe40d0c83f9a59d38c9f5d62cddda/snake_xy.py">snake_xy.py</a> 透過 Q-learning 演算法進行修改.</p>
<p>From <a href="https://en.wikipedia.org/wiki/Model-free_(reinforcement_learning):">https://en.wikipedia.org/wiki/Model-free_(reinforcement_learning):</a></p>
<p style="padding-left: 30px;">In reinforcement learning (RL), a <span style="background-color: #ffff99;">model-free algorithm</span> (as opposed to a model-based one) is an algorithm which does not use the <span style="background-color: #ffff99;">transition probability distribution</span> (and the reward function) associated with the <span style="background-color: #ffff99;">Markov decision process</span> (MDP), which, in RL, represents the problem to be solved.</p>
<p style="padding-left: 30px;">The transition probability distribution (or transition model) and the reward function are often collectively called the "model" of the environment (or MDP), hence the name "model-free".</p>
<p style="padding-left: 30px;">A model-free RL algorithm can be thought of as an "explicit" trial-and-error algorithm. An example of a model-free algorithm is Q-learning.</p>
<p style="padding-left: 30px;">在強化學習領域, 所謂<span style="background-color: #ffff99;">無模型演算法</span> (相對於模型導向演算法), 特指不使用<span style="background-color: #ffff99;">馬可夫決策流程</span>中的<span style="background-color: #ffff99;">過渡隨機分佈</span> (及其獎勵函式) 進行學習解題的一種演算法.</p>
<p style="padding-left: 30px;">由於過渡隨機分佈（或過渡模型）與獎勵函數統稱為受訓環境 (即馬可夫決策流程) 的模型, 因此不使用過渡隨機分佈的強化學習被稱為無模型演算法.</p>
<p style="padding-left: 30px;">無模型強化學習演算法可視為外顯式試誤演算法,  Q-learning 即無模型強化學習演算法的一個範例.</p>
<p><a href="https://en.wikipedia.org/wiki/Q-learning">https://en.wikipedia.org/wiki/Q-learning</a></p>
<p><a href="/downloads/Q-Learning.pdf">Q-Learning.pdf</a></p>
<p><a href="https://italolelis.com/snake">https://italolelis.com/snake</a> (LearnSnake: Teaching an AI to play Snake using Reinforcement Learning (Q-Learning))</p>
<p><a href="https://en.wikipedia.org/wiki/Bellman_equation">https://en.wikipedia.org/wiki/Bellman_equation</a> </p>
<p><a href="https://sid-sr.github.io/Q-Snake/">https://sid-sr.github.io/Q-Snake/</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/sid-sr/Q-Snake">https://github.com/sid-sr/Q-Snake</a></p>
<p>Deep learning in your browser:<a href="https://cs.stanford.edu/people/karpathy/convnetjs/">https://cs.stanford.edu/people/karpathy/convnetjs/</a></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/8cdUree20j4" title="YouTube video player" width="560"></iframe></p>
<h3>LearnSnake</h3>
<p><a href="https://italolelis.com/snake">https://italolelis.com/snake</a> (LearnSnake: Teaching an AI to play Snake using Reinforcement Learning (Q-Learning))</p>
<p>這篇文章說明如何利用 Javascript, 採用 Q-Learning 機器學習原理編寫 Snake 線上遊戲. 程式原始碼: <a href="https://github.com/mdecourse/LearnSnake">https://github.com/mdecourse/LearnSnake</a></p>
<p>作者提到之所以採用 Javascript 而不使用在機器學習領域套件資源更豐富的 Python, 原因是希望在無需安裝任何套件的情況下執行.</p>
<p>有關 Snake 遊戲的規則, 作者如此說明:</p>
<p>Snake is a game in which a snake needs to explore an environment and catch the fruit without hitting any obstacle or itself. Every time the snake catches a fruit, its size increases.</p>
<p>至於 Snake game in Javascript 則是參考下列資料從無到有自行開發:</p>
<p style="padding-left: 30px;"><a href="https://www.youtube.com/watch?v=xGmXxpIj6vs">Coding "Snake" in 4 min 30 sec</a></p>
<p style="padding-left: 30px;"><a href="https://www.youtube.com/watch?v=xGmXxpIj6vs">Mastering the Module Pattern</a> (not really about Snake itself, but a pattern I tried to follow on the project)<br/><br/>See <a href="https://github.com/mdecourse/LearnSnake/blob/master/game.js">game.js</a> for the source code.</p>
<p><a href="https://github.com/mdecourse/q-learning-python-example">https://github.com/mdecourse/q-learning-python-example</a> </p><h2>Python</h2>
<p>機械設計工程系的計算機程式將利用網際 Python 程式 (<a href="https://brython.info/">Brython</a>) 的應用作為開端, 讓使用者練習利用 Python 程式語言解決問題. 由於 <a href="https://brython.info/">Brython</a> 採直接在網頁中, 將 Python 程式碼轉換為 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript">Javascript</a> 後執行, 因此使用者在學習如何利用 <a href="https://brython.info/">Brython</a> 程式語言解決問題時, 必須對 <a href="https://developer.mozilla.org/zh-TW/docs/Glossary/HTML">HTML</a>, <a href="https://developer.mozilla.org/zh-TW/docs/Learn/Getting_started_with_the_web/CSS_basics">CSS</a>, <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript">Javascript</a> 與 <a href="https://developer.mozilla.org/zh-TW/docs/Web/API/WebGL_API">WebGL</a> 有相當程度的認識.</p>
<p>計算機程式預計學員能夠在網際 Python 的引導下, 逐步了解在面臨不同工程問題時, 能夠針對 Javascript, C/C++, <a href="https://www.lua.org/">Lua</a> 等常用電腦程式語言進行學習. 並且對近幾年發展出的 Dart, Typescript 與 Rust 保持高度興趣, 以便因應未來全網際整合的虛實產品開發環境.</p>
<p>本系列課程除了計算機程式, 還包括網際內容管理, 電腦輔助設計實習與協同產品設計實習等三門課程. 課程的規劃是希望能夠透過 <a href="https://www.fossil-scm.org">Fossil SCM</a>, <a href="https://solvespace.com">Solvespace</a>, <a href="https://github.com/Range-Software/range3">Range3</a>, <a href="https://www.coppeliarobotics.com/">CoppeliaSim</a> 與 <a href="https://cyberbotics.com/">Webots</a> 等開源軟體的探究, 讓技職體系機械設計工程專長學子, <span style="background-color: #ffff99;">了解如何運用電腦將做事的過程及直覺形式化, 並各自儘快找到值得投入的目標, 探索如何準確地讓參與協同人員討論並運用既有知識, 從解題過程中累積經驗, 以便衍生出更多能應付未來挑戰的實用知識</span>.</p>
<p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
</p>
<!-- for ggame -->
<p>
<script src="/static/jquery-3.3.1.min.js"></script>
<script src="/static/jquery-ui.1.12.1.min.js"></script>
<script src="/static/pixi-3.0.5.min.js"></script>
<script src="/static/buzz-1.2.1.js"></script>
<script src="/static/bs.js"></script>
<script src="/downloads/brython_modules.js"></script>
</p>
<!-- Cango 程式庫 -->
<p>
<script src="/static/Cango-24v03-min.js"></script>
<script src="/static/CangoAxes-6v01-min.js"></script>
<script src="/static/gearUtils-09.js"></script>
<script src="/static/SVGpathUtils-6v03-min.js"></script>
</p>
<!-- for Konva 程式庫 -->
<p>
<script src="/static/konva.min.js"></script>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/']});
}
</script>
</p>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<h4>請利用下列網際編輯器, 開始學習如何使用 Python 解決問題, 一般機械設計流程會面臨什麼問題?</h4>
<h4><a href="https://resources.saylor.org/wwwresources/archived/site/wp-content/uploads/2012/09/ME101-4.1-Engineering-Design-Process.pdf">Engineering Design Process</a>:</h4>
<p style="padding-left: 30px;"><a href="https://www.nasa.gov/sites/default/files/atoms/files/nasa_systems_engineering_handbook.pdf">NASA system engineering handbook</a></p>
<p style="padding-left: 30px;"><a href="https://www.sciencebuddies.org/science-fair-projects/engineering-design-process/engineering-design-process-steps">https://www.sciencebuddies.org/science-fair-projects/engineering-design-process/engineering-design-process-steps</a></p>
<p style="padding-left: 30px;"><a href="https://www.twi-global.com/technical-knowledge/faqs/engineering-design-process">https://www.twi-global.com/technical-knowledge/faqs/engineering-design-process</a></p>
<p style="padding-left: 30px;">The top five design challenges cited by engineers were (<a href="https://news.aucotec.com/how-to-solve-the-5-top-engineering-design-challenges/">source</a>):</p>
<p style="padding-left: 60px;">Frequent design changes (39%)<br/>Changing design requirements (34%)<br/>Projects are understaffed (29%)<br/>Increased product complexity (25%)<br/>Problems/errors are found too late (19%)</p>
<p><!-- 印出版次與關鍵字程式 --></p>
<p>
<script type="text/python3">
from browser import document as doc
from browser import html
import ace
# 清除畫布
def clear_bd(ev):
    bd = doc["brython_div"]
    bd.clear()
# Brython 3.3.4 內建的 container 名稱為  'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id
Ace = ace.Editor(editor_id="kw_editor", console_id="kw_console", container_id="kw__container", storage_id="kw_py_src" )
Ace.editor.setValue("""# 導入 sys 模組
import sys
# 導入 keyword 模組
import keyword
def helloWorld():
    print("Hello World!")
helloWorld()
# 利用 sys 模組中的 version_info 印出 Python 版次
print("Python version: ", sys.version_info)
# 利用 keyword 模組中的 kwlist 印出關鍵字
print("Python keywords: ", keyword.kwlist)
""")
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)
# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run'].bind('click', Ace.run)
doc['kw_show_console'].bind('click', Ace.show_console)
doc['kw_clear_console'].bind('click', Ace.clear_console)
doc['clear_bd'].bind('click', clear_bd)
</script>
</p>
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src', 'kw_filename');" type="submit" value="Save"/></form>
<p><button id="kw_run">Run</button> <button id="kw_show_console">Output</button> <button id="kw_clear_console">清除輸出區</button><button id="clear_bd">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console"></textarea></div>
<div id="brython_div"></div>
<div class="col-md-0" height="1" id="graphics-column" width="1"></div>
<p><!-- ****************************** keyword start -->
<script type="text/python3">
from browser import document as doc
# 導入位於 static 目錄下的 beditor.py 
import beditor
# 利用 beditor.py 中的 editor 類別建立案例, 對應到 kw1
kw1 = beditor.editor("""# 導入 sys 模組
import sys
# 導入 keyword 模組
import keyword
# 利用 sys 模組中的 version_info 印出 Python 版次
print("Python version: ", sys.version_info)
# 利用 keyword 模組中的 kwlist 印出關鍵字
print("Python keywords: ", keyword.kwlist)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "keyword" 的按鈕點按時, 執行 kw1 物件中的 prog 方法
doc["keyword"].bind('click', kw1.prog)
</script>
</p>
<p><!-- ****************************** keyword end --></p>
<p><!-- ***************************** slide ex1 start --></p>
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Ex1 = beditor.editor("""# 導入 Ex1 原始碼
a = 0
def my_print(n, input_str):
    print("以下將重覆列印 '", input_str + "' " + str(n) + "次")
    for i in range(n):
        print(i, input_str)
my_print(5, "Hello World!")
the_str = "開始學習 Python"
num = input("請輸入要列印的次數!")
my_print(int(num), the_str)
a = a + 1
print("(" + str(a) + ")", "_" * 25)
def myfun():
    yield 1
    yield 2
    yield 3
for i in myfun():
    print(i)
x = iter(myfun())
y = list(myfun())
a = a + 1
print("(" + str(a) + ")", "_" * 25)
print(x.__next__())
print(x.__next__())
print(x.__next__())
print(y)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "ex1" 的按鈕點按時, 執行 Ex1 物件中的 prog 方法
doc["ex1"].bind('click', Ex1.prog)
</script>
</p>
<p><!-- ***************************** slide ex1 end --></p>
<p><!-- ***************************** slide ex2 start --></p>
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Ex2 = beditor.editor("""# Python 的內建資料型別
import math
def f():
    print("This is a user-defined function")
    return 42
print("Some basic types in Python:")
print(type(2))           # int
print(type(2.2))         # float
print(type("2.2"))       # str  (string)
print(type(2 < 2.2))     # bool (boolean)
print(type(math))        # module
print(type(math.tan))    # builtin_function_or_method ("function" in Brython)
print(type(f))           # function (user-defined function)
print(type(type(42)))    # type
print("#####################################################")
print("And some other types we will see later in the course...")
print(type(Exception())) # Exception
print(type(range(5)))    # range
print(type([1,2,3]))     # list
print(type((1,2,3)))     # tuple
print(type({1,2}))       # set
print(type({1:42}))      # dict (dictionary or map)
print(type(2+3j))        # complex  (complex number) (we may not see this type)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "ex2" 的按鈕點按時, 執行 Ex2 物件中的 prog 方法
doc["ex2"].bind('click', Ex2.prog)
</script>
</p>
<p><!-- ***************************** slide ex2 end --></p>
<p><!-- ***************************** slide ex3 start --></p>
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Ex3 = beditor.editor("""# Python 的內建常數與函式
# 內建常數
print("Some builtin constants:")
print(True)
print(False)
print(None)
print("And some more constants in the math module:")
import math
print(math.pi)
print(math.e)
# 內建函式
print("Type conversion functions:")
print(bool(0))   # convert to boolean (True or False)
print(float(42)) # convert to a floating point number
print(int(2.8))  # convert to an integer (int)
print("And some basic math functions:")
print(abs(-5))   # absolute value
print(max(2,3))  # return the max value
print(min(2,3))  # return the min value
print(pow(2,3))  # raise to the given power (pow(x,y) == x**y)
print(round(2.354, 1)) # round with the given number of digits
# other examples
print(3 * 2)
print(3 * "abc")
print(3 + 2)
print("abc" + "def")
print(3 + "def")
# Type Affect Semantics
print(3 * 2)
print(3 * "abc")
print(3 + 2)
print("abc" + "def")
print(3 + "def")
# Integer Division
print("The / operator does 'normal' float division:")
print(" 5/3  =", ( 5/3))
print()
print("The // operator does integer division:")
print(" 5//3 =", ( 5//3))
print(" 2//3 =", ( 2//3))
print("-1//3 =", (-1//3))
print("-4//3 =", (-4//3))
# Modulus or Remainder Operator (%)
print(" 6%3 =", ( 6%3))
print(" 5%3 =", ( 5%3))
print(" 2%3 =", ( 2%3))
print(" 0%3 =", ( 0%3))
print("-4%3 =", (-4%3))
print(" 3%0 =", ( 3%0))
# Verify that (a%b) is equivalent to (a-(a//b)*b)
def mod(a, b):
  return a - (a//b)*b
print(41%14, mod(41,14))
print(14%41, mod(14,41))
print(-32%9, mod(-32,9))
print(32%-9, mod(32,-9))
# Operator Order (Precedence and Associativity)
print("Precedence:")
print(2+3*4)  # prints 14, not 20
print(5+4%3)  # prints  6, not 0 (% has same precedence as *, /, and //)
print(2**3*4) # prints 32, not 4096 (** has higher precedence than *, /, //, and %)
print()
print("Associativity:")
print(5-4-3)   # prints -2, not 4 (- associates left-to-right)
print(4**3**2) # prints 262144, not 4096 (** associates right-to-left)
# Approximate Values of Floating-Point Numbers
print(0.1 + 0.1 == 0.2)        # True, but...
print(0.1 + 0.1 + 0.1 == 0.3)  # False!
print(0.1 + 0.1 + 0.1)         # prints 0.30000000000000004 (uh oh)
print((0.1 + 0.1 + 0.1) - 0.3) # prints 5.55111512313e-17 (tiny, but non-zero!)
# Equality Testing with math.isclose
print("The problem....")
d1 = 0.1 + 0.1 + 0.1
d2 = 0.3
print(d1 == d2)                # False (never use == with floats!)
print()
print("The solution...")
import math
print(math.isclose(d1, d2))  # True!
# math.isclose checks if the two numbers are ALMOST equal, within a small error
# Short-Circuit Evaluation
def yes():
    return True
def no():
    return False
def crash():
    return 1/0 # crashes!
print(no() and crash()) # Works!
print(crash() and no()) # Crashes!
print (yes() and crash()) # Never runs (due to crash), but would also crash (without short-circuiting)
# Or operator
def yes():
    return True
def no():
    return False
def crash():
    return 1/0 # crashes!
print(yes() or crash()) # Works!
print(crash() or yes()) # Crashes!
print(no() or crash())  # Never runs (due to crash), but would also crash (without short-circuiting)
# more examples
def isPositive(n):
    result = (n > 0)
    print("isPositive(",n,") =", result)
    return result
def isEven(n):
    result = (n % 2 == 0)
    print("isEven(",n,") =", result)
    return result
print("Test 1: isEven(-4) and isPositive(-4))")
print(isEven(-4) and isPositive(-4)) # Calls both functions
print("----------")
print("Test 2: isEven(-3) and isPositive(-3)")
print(isEven(-3) and isPositive(-3)) # Calls only one function!
# type vs isinstance
# Both type and isinstance can be used to type-check
# In general, (isinstance(x, T)) will be more robust than (type(x) == T)
print(type("abc") == str)
print(isinstance("abc", str))
# We'll see better reasons for this when we cover OOP + inheritance later
# in the course.  For now, here is one reason:  say you wanted to check
# if a value is any kind of number (int, float, complex, etc). 
# You could do:
def isNumber(x):
    return ((type(x) == int) or
            (type(x) == float)) # are we sure this is ALL kinds of numbers?
print(isNumber(1), isNumber(1.1), isNumber(1+2j), isNumber("wow"))
# But this is cleaner, and works for all kinds of numbers, including
# complex numbers for example:
import numbers
def isNumber(x):
    return isinstance(x, numbers.Number) # works for any kind of number
print(isNumber(1), isNumber(1.1), isNumber(1+2j), isNumber("wow"))
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "ex3" 的按鈕點按時, 執行 Ex3 物件中的 prog 方法
doc["ex3"].bind('click', Ex3.prog)
</script>
</p>
<p><!-- ***************************** slide ex3 end --></p>
<p><!-- ***************************** slide ex4 start --></p>
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Ex4 = beditor.editor("""# Python 函式
# Vocabulary
x = 5
def f(y, z):
    result = x + y + z
    return result
print(f(1, 2)) # 8
print(f(3, 4)) # 12
# Vocabulary:
#   variables: global vs. local
#   statements vs. expressions
#   function definitions vs. function calls
#   parameters vs. arguments
# Return Statements
# Basic example
def isPositive(x):
    return (x > 0)
print(isPositive(5))  # True
print(isPositive(-5)) # False
print(isPositive(0))  # False
# Return ends the function immediately
def isPositive(x):
    print("Hello!")   # runs
    return (x > 0)
    print("Goodbye!") # does not run ("dead code")
print(isPositive(5))  # prints Hello, then True
# No return statement --> return None
def f(x):
    x + 42
print(f(5)) # None
def f2(x):
    result = x + 42
print(f2(5)) # None
# Print versus Return
# This is a common early mistake (confusing print and return):
def cubed(x):
    print(x**3) # Here is the error!
cubed(2)          # seems to work!
print(cubed(3))   # sort of works (but prints None, which is weird)
print(2*cubed(4)) # Error!
# Once again (correctly)
def cubed2(x):
    return (x**3) # That's better!
cubed2(2)          # seems to be ignored (why?)
print(cubed2(3))   # works!
print(2*cubed2(4)) # works!
# Different Parameter and Return Types
def hypotenuse(a, b):
    return ((a**2) + (b**2))**0.5
print(hypotenuse(3, 4)) # 5.0 (not 5)
print("---------------------")
def xor(b1, b2):
    return ((b1 and (not b2)) or (b2 and (not b1)))  # same as (b1 != b2)
print(xor(True,  True))  # False
print(xor(True,  False)) # True
print(xor(False, True))  # True
print(xor(False, False)) # False
print("---------------------")
def isPositive(n):
    return (n > 0)
print(isPositive(10))     # True
print(isPositive(-1.234)) # False
# Function Composition
def f(w):
    return 10*w
def g(x, y):
    return f(3*x) + y
def h(z):
    return f(g(z, f(z+1)))
print(h(1)) # hint: try the "visualize" feature
# Helper Functions 
def onesDigit(n):
    return n%10
def largerOnesDigit(x, y):
    return max(onesDigit(x), onesDigit(y))
print(largerOnesDigit(134, 672)) # 4
print(largerOnesDigit(132, 674)) # Still 4
# Test Functions
# A broken test function
def onesDigit(n):
    return n%10
def testOnesDigit():
    print("Testing onesDigit()...", end="")
    assert(onesDigit(5) == 5)
    assert(onesDigit(123) == 3)
    assert(onesDigit(100) == 0)
    assert(onesDigit(999) == 9)
    print("Passed!")
testOnesDigit() # Passed!  Why is this bad?
# A better version
def onesDigit2(n):
    return n%10
def testOnesDigit2():
    print("Testing onesDigit()...", end="")
    assert(onesDigit2(5) == 5)
    assert(onesDigit2(123) == 3)
    assert(onesDigit2(100) == 0)
    assert(onesDigit2(999) == 9)
    assert(onesDigit2(-123) == 3) # Added this test
    print("Passed!")
testOnesDigit2() # Crashed!  So the test function worked!
# Local Variable Scope
def f(x):
    print("In f, x =", x)
    x += 5
    return x
def g(x):
    return f(x*2) + f(x*3)
print(g(2))
# Another example
def f(x):
    print("In f, x =", x)
    x += 7
    return round(x / 3)
def g(x):
    x *= 10
    return 2 * f(x)
def h(x):
    x += 3
    return f(x+4) + g(x)
print(h(f(1)))
# Global Variable Scope
# In general, you should avoid using global variables.
# You will even lose style points if you use them!
# Still, you need to understand how they work, since others
# will use them, and there may also be some very few occasions
# where you should use them, too!
g = 100
def f(x):
    return x + g
print(f(5)) # 105
print(f(6)) # 106
print(g)    # 100
# Another exampl
g = 100
def f(x):
    # If we modify a global variable, we must declare it as global.
    # Otherwise, Python will assume it is a local variable.
    global g
    g += 1
    return x + g
print(f(5)) # 106
print(f(6)) # 108
print(g)    # 102
# Default arguments
# Sometimes, a function has a parameter that has a natural default
# We can specify that default value in the function definition,
# then choose whether or not to include it in the function call.
def f(x, y=10):
    return x + y
print(f(5))   # 15
print(f(5,1)) # 6
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "ex4" 的按鈕點按時, 執行 Ex4 物件中的 prog 方法
doc["ex4"].bind('click', Ex4.prog)
</script>
</p>
<p><!-- ***************************** slide ex4 end --></p>
<!-- line drawing start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Draw = beditor.editor("""# Line drawing
# 導入 doc
from browser import document as doc
from browser import html
import math
canvas = html.CANVAS(width = 300, height = 200)
canvas.id = "line_drawing"
brython_div = doc["brython_div"]
brython_div <= canvas
# 準備繪圖畫布
canvas = doc["line_drawing"]
ctx = canvas.getContext("2d")
# 進行座標轉換, x 軸不變, y 軸反向且移動 canvas.height 單位光點
# ctx.setTransform(1, 0, 0, -1, 0, canvas.height)
# 以下採用 canvas 原始座標繪圖
# 設定填圖顏色
ctx.fillStyle = "rgb(200,0,0)"
# 設定畫筆顏色
ctx.strokeStyle = "rgb(0,0,200)"
# 乘上 deg 可轉為徑度單位
deg = math.pi / 180
# 建立多邊形定點位置畫線函式
def star(radius, xc, yc, n):
    #radius = 100
    #xc = 200
    #yc = 200
    xi = xc + radius*math.cos((360/n)*deg+90*deg)
    yi = yc - radius*math.sin((360/n)*deg+90*deg)
    ctx.beginPath()
    ctx.moveTo(xi,yi)
    for i in range(2, n+1):
        x = xc + radius*math.cos((360/n)*deg*i+90*deg)
        y = yc - radius*math.sin((360/n)*deg*i+90*deg)
        ctx.lineTo(x,y)
# 以下利用多邊形畫線函式呼叫執行畫框線或填入顏色
# 畫五邊形框線
star(50, 50, 50, 5)
ctx.closePath()
ctx.stroke()
    
# 填三角形色塊
star(50, 150, 50, 3)
ctx.closePath()
ctx.fill()
    
# 改變畫線顏色後, 畫七邊形框線
ctx.strokeStyle = "rgb(0,200,20)"
star(50, 250, 50, 7)
ctx.closePath()
ctx.stroke()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "draw" 的按鈕點按時, 執行 Draw 物件中的 prog 方法
doc["draw"].bind('click', Draw.prog)
</script>
</p>
<!-- line drawing ends -->
<p></p>
<!-- flag ex start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Flag = beditor.editor("""# 畫中華民國國旗
# 導入 doc
from browser import document as doc
from browser import html
import math
canvas = html.CANVAS(width = 300, height = 200)
canvas.style = {"width": "100%"}
canvas.id = "taiwan_flag"
brython_div = doc["brython_div"]
brython_div <= canvas
# 準備繪圖畫布
canvas = doc["taiwan_flag"]
ctx = canvas.getContext("2d")
# 進行座標轉換, x 軸不變, y 軸反向且移動 canvas.height 單位光點
# ctx.setTransform(1, 0, 0, -1, 0, canvas.height)
# 以下採用 canvas 原始座標繪圖
flag_w = canvas.width
flag_h = canvas.height
circle_x = flag_w/4
circle_y = flag_h/4
# 先畫滿地紅
ctx.fillStyle='rgb(255, 0, 0)'
ctx.fillRect(0,0,flag_w,flag_h)
# 再畫青天
ctx.fillStyle='rgb(0, 0, 150)'
ctx.fillRect(0,0,flag_w/2,flag_h/2)
# 畫十二道光芒白日
ctx.beginPath()
star_radius = flag_w/8
angle = 0
for i in range(24):
    angle += 5*math.pi*2/12
    toX = circle_x + math.cos(angle)*star_radius
    toY = circle_y + math.sin(angle)*star_radius
    # 只有 i 為 0 時移動到 toX, toY, 其餘都進行 lineTo
    if (i):
        ctx.lineTo(toX, toY)
    else:
        ctx.moveTo(toX, toY)
ctx.closePath()
# 將填色設為白色
ctx.fillStyle = '#fff'
ctx.fill()
# 白日:藍圈
ctx.beginPath()
ctx.arc(circle_x, circle_y, flag_w*17/240, 0, math.pi*2, True)
ctx.closePath()
# 填色設為藍色
ctx.fillStyle = 'rgb(0, 0, 149)'
ctx.fill()
# 白日:白心
ctx.beginPath()
ctx.arc(circle_x, circle_y, flag_w/16, 0, math.pi*2, True)
ctx.closePath()
# 填色設為白色
ctx.fillStyle = '#fff'
ctx.fill()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "flag" 的按鈕點按時, 執行 Flag 物件中的 prog 方法
doc["flag"].bind('click', Flag.prog)
</script>
</p>
<!-- flag ex ends -->
<p></p>
<!-- bunny starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Bunny = beditor.editor("""# Ggame
from ggame import App, ImageAsset, Sprite, MouseEvent
from random import random, randint
from browser import document as doc
from browser import html
import math
# for site variable to use socket.gethostname() to differentiate execution on localhost or not
import socket
# 引入既有的id="graphics-column" 標註
graphics_column = doc["graphics-column"]
# 建立內定名稱為 "ggame-canvas" 的 canvas 標註
canvas = html.CANVAS(width = 600, height = 400)
canvas.id = "ggame-canvas"
# 將 canvas 插入 gc 標註中
graphics_column <= canvas

# when work with dynamic site
if socket.gethostname() == "localhost":
    site = ""
else:
    # when work with remote site
    site="./.."

class Bunny(Sprite):
    
    asset = ImageAsset(site+"/images/bunny.png")
    
    def __init__(self, position):
        super().__init__(Bunny.asset, position)
        # register mouse events
        App.listenMouseEvent(MouseEvent.mousedown, self.mousedown)
        App.listenMouseEvent(MouseEvent.mouseup, self.mouseup)
        App.listenMouseEvent(MouseEvent.mousemove, self.mousemove)
        self.dragging = True
        self.deltax = 0
        self.deltay = 0
    
    def step(self):
        # Every now and then a bunny hops...
        if random() < 0.01:
            self.x += randint(-20,20)
            self.y += randint(-20,20)
        
        
    def mousedown(self, event):
        # capture any mouse down within 50 pixels
        self.deltax = event.x - (self.x + self.width//2) 
        self.deltay = event.y - (self.y + self.height//2)
        if abs(self.deltax) < 50 and abs(self.deltay) < 50:
            self.dragging = True
            # only drag one bunny at a time - consume the event
            event.consumed = True
            
    def mousemove(self, event):
        if self.dragging:
            self.x = event.x - self.deltax - self.width//2
            self.y = event.y - self.deltay - self.height//2
            event.consumed = True
            
    def mouseup(self, event):
        if self.dragging:
            self.dragging = False
            event.consumed = True
            
        
class DemoApp(App):
    
    def __init__(self):
        super().__init__()
        for i in range(5):
            Bunny((randint(50, 600), randint(50, 400)))
        
    def step(self):
        # Override step to perform action on each frame update
        for bunny in self.spritelist:
            bunny.step()
# Create the app
app = DemoApp()  
# Run the app
app.run()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "bunny" 的按鈕點按時, 執行 Bunny 物件中的 prog 方法
doc["bunny"].bind('click', Bunny.prog)
</script>
</p>
<!-- bunny ends -->
<p></p>
<!-- clear canvas start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Clear = beditor.editor("""# 清除畫布
from browser import document, html
brython_div = document["brython_div"] 
brython_div.clear()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "clear" 的按鈕點按時, 執行 Clear 物件中的 prog 方法
doc["clear"].bind('click', Clear.prog)
</script>
</p>
<!-- clear canvas ends -->
<p></p>
<!-- cango three spur gears starts -->
<script type="text/python3">
from browser import document
import beditor
url = "https://gist.githubusercontent.com/mdecourse/e896a4705a95ac8cc4147b355b0e87ef/raw/8954b8280c524c5781dc3c0b3565bc489d3aa3a3/three_spur_rotating.py"
src = open(url).read()
cango_three_spurs = beditor.editor(src, "kw_editor", "kw_console", "kw__container", "kw_py_src")
document["spur"].bind("click", cango_three_spurs.prog)
</script>
<!-- cango three spur gears ends -->
<p></p>
<!-- temp convert start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Temp = beditor.editor("""# Temperature Conversion
# Temperature Conversion
'''
C to F: Celsius to Fahrenheit Conversion Formula. To convert temperatures in degrees Celsius to Fahrenheit, multiply by 1.8 (or 9/5) and add 32.
To convert temperatures in degrees Fahrenheit to Celsius, subtract 32 and multiply by .5556 (or 5/9).
Fahrenheit = Celsius*9/5 + 32
Celsium = (Fahrenheit - 32)*5/9
'''
from browser import document, html
brython_div = document["brython_div"]
def c2f(c):
    f = round(c*9/5 + 32, 3)
    return "Celsiusc: "+ str(c) +         " degrees = Fahrenheit: " + str(f) + " degrees"
    
def f2c(f):
    c = round((f - 32)*5/9, 3)
    return "Fahrenheit: "+ str(f) +         " degrees = Celsiusc: " + str(c) + " degrees"
    
choice = input("c2f or f2c")
if choice == "c2f":
    '''
    c = float(input("input Celsius in degrees"))
    print(c2f(c))
    '''
    for deg in range(100):
        brython_div <= c2f(deg)
        brython_div <= html.BR()
else:
    '''
    f = float(input("input Fahrenheit in degrees"))
    print(f2c(f))
    '''
    for deg in range(100):
        brython_div <= f2c(deg)
        brython_div <= html.BR()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "temp" 的按鈕點按時, 執行 Temp 物件中的 prog 方法
doc["temp"].bind('click', Temp.prog)
</script>
</p>
<!-- temp convert ends -->
<p></p>
<!-- forloop start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Forloop = beditor.editor("""# For loop
for i in range(5):
    print(i)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "forloop" 的按鈕點按時, 執行 Forloop 物件中的 prog 方法
doc["forloop"].bind('click', Forloop.prog)
</script>
</p>
<!-- forloop ends -->
<p></p>
<!-- ex6 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Class_ex6 = beditor.editor("""# global variable i
i = 2
class myobj:
    # local variable i
    i = 1
    print(i)
    def method1(self):
        # can only access global variable variable i
        # can access local variable i through self.i 
        return i, self.i
def main():
    myinst = myobj()
    print(myinst.method1()) 

print(__name__)

if __name__ == "__main__":
    main()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "class_ex6" 的按鈕點按時, 執行 Class_ex6 物件中的 prog 方法
doc["class_ex6"].bind('click', Class_ex6.prog)
</script>
</p>
<!-- ex6 ends -->
<p></p>
<!-- guess start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Guess = beditor.editor("""# 猜數字遊戲
from browser import document, html, alert
import random
# 跳出文字說明視窗
alert("開始玩猜數字遊戲")
# 利用 random 模組中的 randint 取 1~100 間的亂數
標準答案 = random.randint(1, 100)
# 利用 input 函式視窗, 取使用者所猜的數字, 轉為整數
你猜的數字 = int(input("請輸入您所猜 1~100 間的整數:"))
# 猜測次數起始值設為 1
猜測次數 = 1
# 進入重複迴圈, 直到猜對數字
while 標準答案 != 你猜的數字:
    # 根據使用者所猜的數字, 與答案比較後, 給出提示
    if 標準答案 < 你猜的數字:
        alert("猜第" + str(猜測次數) + "次, 太大了，再猜 :)加油")
    else:
        alert("猜第" + str(猜測次數) + "次, 太小了，再猜 :)加油")
    你猜的數字 = int(input("請輸入您所猜 1~100 間的整數:"))
    # 猜測次數累加
    猜測次數 += 1
# 跳出迴圈表示猜對, 給出最後文字說明視窗
alert("猜對了！答案為" + str(標準答案) + ", 總共猜了" + str(猜測次數) + "次")
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "guess" 的按鈕點按時, 執行 Guess 物件中的 prog 方法
doc["guess"].bind('click', Guess.prog)
</script>
</p>
<!-- guess ends -->
<p></p>
<!-- autoguess start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Autoguess = beditor.editor("""# 程式自動猜數字遊戲
from browser import document, html, alert
import random
 
id4 = document["brython_div"]
執行次數 = 100
總猜測次數 = 0
for i in range(執行次數):
    id4 <= "第" + str(i+1) + "次玩:" + html.BR()
    下限 = 1
    上限 = 100
    標準答案 = random.randint(下限, 上限)
    pc猜的數字 = random.randint(下限, 上限)
    #print(標準答案, pc猜的數字)
    #integer int()
    #string str()
    #float float()
    #你猜的數字 = int(input("請輸入您所猜的整數:"))
    猜測次數 = 1
    while 標準答案 != pc猜的數字:
        if 標準答案 < pc猜的數字:
            #print("太大了，再猜一次 :)加油")
            # 因此已經確定"pc猜的數字"不是答案, 因此 - 1
            id4 <= "電腦猜的數字:" + str(pc猜的數字) + " 太大了!" + html.BR()
            上限 = pc猜的數字 - 1
        else:
            #print("太小了，再猜一次 :)加油")
            # 因此已經確定"pc猜的數字"不是答案, 因此 + 1
            id4 <= "電腦猜的數字:" + str(pc猜的數字) + " 太小了!" + html.BR()
            下限 = pc猜的數字 + 1
        #pc猜的數字 = int(input("請輸入您所猜的整數:"))
        pc猜的數字 = random.randint(下限, 上限)
        猜測次數 += 1
    #print("猜對了！總共猜了", 猜測次數, "次")
    id4 <= "電腦猜對了, 答案為: " + str(標準答案) + ", 總共猜了 "+ str(猜測次數) + "次" + html.BR()
    總猜測次數 += 猜測次數
平均猜測次數 = int(總猜測次數/執行次數)
#print("平均次數", 平均猜測次數)
id4 <= "平均次數: " + str(平均猜測次數)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "autoguess" 的按鈕點按時, 執行 Autoguess 物件中的 prog 方法
doc["autoguess"].bind('click', Autoguess.prog)
</script>
</p>
<!-- autoguess ends -->
<p></p>
<!-- lottery start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Lottery = beditor.editor("""# 大樂透電腦選號
# lottery
from browser import document, html, alert
import random
try:
    total = int(input("請問要出幾張大樂透彩卷號碼?"))
except:
    alert("請輸入要選擇大樂透電腦選號數量的'整數'")
    total = int(input("請問要出幾張大樂透彩卷號碼?"))
# 準備將電腦選出的號碼, 輸出到內定 id="brython_div" 的標註區域
output_div = document["brython_div"]
output_div <= "以下將出 " + str(total) + " 張電腦選號彩卷:" + html.BR()
for i in range(1, total + 1):
    # 利用 list(range()) 產生 1 到 49 的 population list
    # 然後再透過 random.sample(population, k) 
    # 從 population, 產生 k 個不同的數字
    numbers = random.sample(list(range(1, 49)), 6)
    output_div <= str(i) + ". 電腦選號為: " + str(numbers) + html.BR()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "lottery" 的按鈕點按時, 執行 Lottery 物件中的 prog 方法
doc["lottery"].bind('click', Lottery.prog)
</script>
</p>
<!-- lottery ends -->
<p></p>
<!-- 台灣威力彩 start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Weleadlottery = beditor.editor("""# 威力彩電腦選號
# weleadlottery
from browser import document, html, alert
import random
try:
    total = int(input("請問要出幾張威力彩卷號碼?"))
except:
    alert("請輸入要選擇威力彩電腦選號數量的'整數'")
    total = int(input("請問要出幾張威力彩卷號碼?"))
# 準備將電腦選出的號碼, 輸出到內定 id="brython_div" 的標註區域
output_div = document["brython_div"]
output_div <= "以下將出 " + str(total) + " 張威力彩電腦選號彩卷:" + html.BR()
for i in range(1, total + 1):
    # 利用 list(range()) 產生第一區 1 到 38 , 第二區 1 到 8 的 population list
    # 然後再透過 random.sample(population, k) 
    # 從 population, 產生 k 個不同的數字
    section1_numbers = random.sample(list(range(1, 38)), 6)
    section2_number = random.sample(list(range(1, 8)), 1)
    output_div <= str(i) + ". 電腦選號第一區為: " + str(section1_numbers) + html.BR()
    output_div <= ". 電腦選號第二區為: " + str(section2_number) + html.BR()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "lottery" 的按鈕點按時, 執行 Lottery 物件中的 prog 方法
doc["weleadlottery"].bind('click', Weleadlottery.prog)
</script>
</p>
<!-- 台灣威力彩 ends -->
<p></p>
<!-- bezier 開始 -->
<script type="text/python3">
import beditor
from browser import document
url = "https://gist.githubusercontent.com/mdecourse/2089a943b8fc260c2ca3ce4d0c886b1f/raw/e70f973d0b58f9db5fc6932960ef633421792f35/bezier24v3.py"
src = open(url).read()
bezier = beditor.editor(src, "kw_editor", "kw_console", "kw__container", "kw_py_src")
document["bezier"].bind("click", bezier.prog)
</script>
<!-- bezier 結束 -->
<p></p>
<!-- turtle1 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Turtle1 = beditor.editor("""# Turtle1 繪圖
from browser import window, html
from browser import document as doc
import turtle
turtle.set_defaults(
    turtle_canvas_wrapper = doc['brython_div']
)
t = turtle.Turtle()
t.width(5)
for c in ['red', '#00ff00', '#fa0', 'rgb(0,0,200)']:
    t.color(c)
    t.forward(100)
    t.left(90)
# dot() and write() do not require the pen to be down
t.penup()
t.goto(-30, -100)
t.dot(40, 'rgba(255, 0, 0, 0.5')
t.goto(30, -100)
t.dot(40, 'rgba(0, 255, 0, 0.5')
t.goto(0, -70)
t.dot(40, 'rgba(0, 0, 255, 0.5')
t.goto(0, 125)
t.color('purple')
t.write("這就是 Brython, 網頁上的 Python", font=("Arial", 15, "normal"))
turtle.done()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "turtle1" 的按鈕點按時, 執行 Turtle1 物件中的 prog 方法
doc["turtle1"].bind('click', Turtle1.prog)
</script>
</p>
<!-- turtle1 ends -->
<p></p>
<!-- turtle2 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Turtle2 = beditor.editor("""# Turtle2 繪圖
from browser import document as doc
import turtle
turtle.set_defaults(
    turtle_canvas_wrapper = doc['brython_div']
)
star = turtle.Turtle()
for i in range(5):
    star.forward(250)
    star.right(144)
    
turtle.done()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "turtle2" 的按鈕點按時, 執行 Turtle2 物件中的 prog 方法
doc["turtle2"].bind('click', Turtle2.prog)
</script>
</p>
<!-- turtle2 ends -->
<p></p>
<!-- turtle3 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Turtle3 = beditor.editor("""# Turtle3 繪圖
# https://michael0x2a.com/blog/turtle-examples
from browser import document as doc
import turtle
turtle.set_defaults(
    turtle_canvas_wrapper = doc['brython_div']
)
painter = turtle.Turtle()
painter.pencolor("blue")
for i in range(50):
    painter.forward(50)
    painter.left(123) # Let's go counterclockwise this time 
    
painter.pencolor("red")
for i in range(50):
    painter.forward(100)
    painter.left(123)
    
turtle.done()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "turtle3" 的按鈕點按時, 執行 Turtle3 物件中的 prog 方法
doc["turtle3"].bind('click', Turtle3.prog)
</script>
</p>
<!-- turtle3 ends -->
<p></p>
<!-- turtle4 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Turtle4 = beditor.editor("""# Turtle4 繪圖
# https://docs.python.org/3.7/library/turtle.html?highlight=turtle
# https://fiftyexamples.readthedocs.io/en/latest/turtle.html
from browser import document as doc
import turtle
turtle.set_defaults(
    turtle_canvas_wrapper = doc['brython_div']
)
# 輸入 "turtle" 字串, 表示要使用內建的烏龜圖示
t = turtle.Turtle("turtle")
# 設定繪圖尺寸
screen_x = 500-20
screen_y = 300
# 提筆, 將烏龜移動到畫布中心
t.penup()
t.home()
# 內定方向為右, 前進 screen_x/2
t.forward(screen_x / 2)
# 將方向往右轉 90 度
t.right(90)
# 此時方向向下, 前進 screen_y/2
t.forward(screen_y / 2)
# 令烏龜方向轉絕對角度 180, 等同轉相對角度 90 度, 即 t.right(90)
t.setheading(180)
# 將畫筆顏色設為紅色
t.pencolor('red')
# 下筆準備繪圖
t.pendown()
# 設筆寬度為 10
t.pensize(10)
# 進入重複迴圈, 此時方向向右, 分別
# 前進 screen_x, 之後轉 90 度, 方向朝上
# 再前進 screen_y, 之後再轉 90 度, 方向朝右
# 再前進 screen_x, 之後轉 90 度, 方向朝下
# 最後再前進 screen_y 後, 將方向轉為向左
for distance in (screen_x, screen_y, screen_x, screen_y):
    t.forward(distance)
    t.right(90)
# 提筆後, 將烏龜轉回內定方向回到畫布中心
t.penup()
t.home()
# 完成 turtle 繪圖
turtle.done()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "turtle4" 的按鈕點按時, 執行 Turtle4 物件中的 prog 方法
doc["turtle4"].bind('click', Turtle4.prog)
</script>
</p>
<!-- turtle4 ends -->
<p></p>
<!-- turtle5 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Turtle5 = beditor.editor("""# Turtle5 繪圖
# https://brython.info/gallery/turtle.html
from browser import document as doc
import turtle
import math
turtle.set_defaults(
    turtle_canvas_wrapper = doc['brython_div']
)
t = turtle.Turtle("turtle")
t.speed(1)
t.forward(50)
print("Should be (50, 0):", t.position())
print("Should be 50: ", t.xcor())
print("Should be 0: ", t.ycor())
t.left(90)
t.color("blue")
t.speed(2)
t.fd(50)
print("Should be (50, 50):", t.pos())
print("Should be 225: ", t.towards(0, 0))
print("Should be 90: ", t.heading())
print("Should be approximately 71:", t.distance(0, 0))
# Draw the same square in three different angle modes
t.width(4)
print("Drawing using degrees - the default")
print("Heading should be 90: ", t.heading())
for i in range(4):
    t.forward(100)
    t.left(90)
print("Drawing using radians")
t.radians()
print("Heading should be pi/2: ", t.heading())
for i in range(4):
    t.forward(100)
    t.left(math.pi/2)
print("Drawing using gradients")
t.degrees(400)
print("Heading should be 100: ", t.heading())
for i in range(4):
    t.forward(100)
    t.left(100)
t.degrees()
t.width(1)
t.lt(90)
t.color("orange")
t.backward(50)
t.right(90)
t.color("green")
t.back(50)
t.rt(90)
t.color("red")
t.bk(50)
t.stamp()
t.speed(4)
t.color("black", "white")
t.goto(-100, 100)
t.stamp()
t.color("blue", "yellow")
t.setposition(0, 100)
t.stamp()
t.color("green", "white")
t.setpos(100, 100)
t.stamp()
t.speed(10)
t.color("orange")
t.sety(-100)
t.setx(-100)
t.stamp()
t.color("cyan")
t.home()
t.stamp()
t.color("green")
t.width(4)
t.setheading(180)
t.forward(150)
t.seth(90)
t.fd(20)
t.dot(30, "rgba(255, 0, 0, 0.2)")
t.color("red")
t.speed(0)
t.forward(30)
t.left(90)
t.circle(30)
turtle.done()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "turtle5" 的按鈕點按時, 執行 Turtle5 物件中的 prog 方法
doc["turtle5"].bind('click', Turtle5.prog)
</script>
</p>
<!-- turtle5 ends -->
<p></p>
<!-- turtle6 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Turtle6 = beditor.editor("""# Turtle6 繪圖
from browser import document as doc
import turtle
import math
turtle.set_defaults(
    turtle_canvas_wrapper = doc['brython_div']
)
t = turtle.Turtle("turtle")
t.speed(10)
colors = ['red', 'purple', 'blue', 'green', 'orange']
for x in range(150):
    t.pencolor(colors[x % 5])
    t.width(x/10 + 1)
    t.forward(x)
    t.left(59)
turtle.done()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "turtle6" 的按鈕點按時, 執行 Turtle6 物件中的 prog 方法
doc["turtle6"].bind('click', Turtle6.prog)
</script>
</p>
<!-- turtle6 ends -->
<p></p>
<!-- turtle7 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Turtle7 = beditor.editor("""# Turtle7 繪圖
from browser import document as doc
import turtle
import math
turtle.set_defaults(
    turtle_canvas_wrapper = doc['brython_div']
)
screen=turtle.Screen()    #making a canvas for drawing
screen.bgcolor('black')    #making canvas black
trtl=turtle.Turtle()  #making a turtle
trtl.pencolor('red')    #making colour of the pen red
trtl.pensize(5)    #choosing the size of pen nib 
trtl.speed(10)    #choosing the speed of drawing
# shape should be ‘arrow’, ‘classic’, ‘turtle’ or ‘circle’
trtl.shape('turtle')   #choosing the shape of pen nib
trtl.forward(150)    #drawing a line of 150 pixels
trtl.right(90)    #asking turtle to turn 90 degrees
trtl.forward(150)    #drawing a line of 150 pixels
trtl.penup()    # preparing for moving pen without drawing
trtl.setpos(-140,-120)    # making the new position of the turtle
trtl.pendown()   # bringing the pen down for drawing again
trtl.pencolor('green')    # choosin the pen colour as green
trtl.write('Brython 烏龜繪圖', font=("Arial", 20, "bold"))    # chosing the font
trtl.penup()
trtl.ht()    # hiding the turtle from the screen
turtle.done()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "turtle7" 的按鈕點按時, 執行 Turtle7 物件中的 prog 方法
doc["turtle7"].bind('click', Turtle7.prog)
</script>
</p>
<!-- turtle7 ends -->
<p></p>
<!-- turtle8 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Turtle8 = beditor.editor("""# Turtle8 繪圖
from browser import document as doc
import turtle
import math
turtle.set_defaults(
    turtle_canvas_wrapper = doc['brython_div']
)
wn = turtle.Screen() 
wn.bgcolor("black") 
skk = turtle.Turtle() 
skk.speed(10)
skk.shape("circle")
skk.color("blue") 
  
def sqrfunc(size): 
    for i in range(4): 
        skk.fd(size) 
        skk.left(90) 
        size = size-5
  
sqrfunc(146) 
sqrfunc(126) 
sqrfunc(106) 
sqrfunc(86) 
sqrfunc(66) 
sqrfunc(46) 
sqrfunc(26) 
turtle.done()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "turtle8" 的按鈕點按時, 執行 Turtle8 物件中的 prog 方法
doc["turtle8"].bind('click', Turtle8.prog)
</script>
</p>
<!-- turtle8 ends -->
<p></p>
<!-- konva1 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Konva1 = beditor.editor("""# Konva1 繪圖
# 引用 https://konvajs.github.io/ 繪圖
from browser import document, html, window
width = 600
height = 400
konva = window.Konva
# Konva 必須在 canvas 繪圖, 從上方設定,  canvas id 為 "container"
stage = konva.Stage.new({
        "container": 'brython_div',
        "width": width,
        "height": height
    })
layer = konva.Layer.new()
rectX = stage.getWidth() / 2 - 50
rectY = stage.getHeight() / 2 - 25
box = konva.Rect.new({
        "x": rectX,
        "y": rectY,
        "width": 100,
        "height": 50,
        "fill": '#00D2FF',
        "stroke": 'black',
        "strokeWidth": 4,
        "draggable": True
    })
def f1():
    document.body.style.cursor = 'pointer'
    
def f2():
    document.body.style.cursor = 'default'
# add cursor styling
box.on('mouseover', f1())
box.on('mouseout', f2())
layer.add(box)
stage.add(layer)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "konva1" 的按鈕點按時, 執行 Konva1 物件中的 prog 方法
doc["konva1"].bind('click', Konva1.prog)
</script>
</p>
<!-- konva1 ends -->
<p></p>
<!-- ycqsort starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Ycqsort = beditor.editor("""# Ycombinator quicksort example
Y = lambda f: lambda *args: f(Y(f))(*args)
quicksort = Y(lambda f:
    lambda x: (
        f([item for item in x if item < x[0]])
        + [y for y in x if x[0] == y]
        + f([item for item in x if item > x[0]])
    ) if x else [])
    
print(quicksort([1, 3, 5, 4, 1, 3, 2]))
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "ycqsort" 的按鈕點按時, 執行 Ycqsort 物件中的 prog 方法
doc["ycqsort"].bind('click', Ycqsort.prog)
</script>
</p>
<!-- ycqsort ends -->
<p></p>
<!-- ball starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Ball = beditor.editor("""# Ggame ball example
from ggame import (
    App, 
    Color, 
    LineStyle, 
    Sprite, 
    RectangleAsset, 
    ImageAsset,
    CircleAsset, 
    EllipseAsset, 
    PolygonAsset,
)
from browser import document as doc
from browser import html
# for site variable to check socket.gethostname() for image file location
import socket
# 引入既有的id="graphics-column" 標註
graphics_column = doc["graphics-column"]
# 建立內定名稱為 "ggame-canvas" 的 canvas 標註
canvas = html.CANVAS(width = 600, height = 100)
canvas.id = "ggame-canvas"
# 將 canvas 插入 gc 標註中
graphics_column <= canvas
# reverse - change the ball direction
def reverse(b):
    b.direction *= -1
# Set up function for handling screen refresh
def step():
    if ball.go:
        ball.x += ball.direction
        if ball.x + ball.width > myapp.width or ball.x < 0:
            ball.x -= ball.direction
            reverse(ball)
myapp = App()
# Three primary colors with no transparency (alpha = 1.0)
red = Color(0xff0000, 1.0)
green = Color(0x00ff00, 1.0)
blue = Color(0x0000ff, 1.0)
black = Color(0x000000, 1.0)
# define colors and line style
green = Color(0x00ff00, 1)
black = Color(0, 1)
noline = LineStyle(0, black)
# a rectangle asset and sprite to use as background
bg_asset = RectangleAsset(canvas.width, canvas.height, noline, green)
bg = Sprite(bg_asset, (0,0))
# when work with dynamic site
if socket.gethostname() == "localhost":
    site = ""
else:
    # when work with remote site
    site="./.."
ball_asset = ImageAsset(site+"/images/orb-150545_640.png")
ball = Sprite(ball_asset, (0, 0))
# Original image is too big. Scale it to 1/10 its original size
ball.scale = 0.1
# custom attributes
ball.direction = 7
ball.go = True
myapp.run(step)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "ball" 的按鈕點按時, 執行 Ball 物件中的 prog 方法
doc["ball"].bind('click', Ball.prog)
</script>
</p>
<!-- ball ends -->
<p></p>
<!-- nfulist starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Nfulist = beditor.editor("""# nfulist
url = "https://nfulist.herokuapp.com/?semester=1092&courseno=2384&column=True"
data = open(url).read()
print(data)
'''
2021 spring:
0741 1a
0764 2a
0776 2b
2384 5j
'''
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "nfulist" 的按鈕點按時, 執行 Nfulist 物件中的 prog 方法
doc["nfulist"].bind('click', Nfulist.prog)
</script>
</p>
<!-- nfulist ends -->
<p></p>
<!-- clock1 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Clock1 = beditor.editor("""# clock1 in Brython
'''Code for the clock'''
# Line drawing
# 導入 doc
from browser import document as doc
from browser import html
import math
import time
import browser.timer
canvas = html.CANVAS(width = 300, height = 200)
canvas.id = "line_drawing"
brython_div = doc["brython_div"]
brython_div <= canvas
# 準備繪圖畫布
canvas = doc["line_drawing"]
ctx = canvas.getContext("2d")

sin, cos = math.sin, math.cos
width, height = 200, 200 # canvas dimensions
ray = 100 # clock ray

background = "SteelBlue"
digits = "#fff"
border = "blue"

def needle(angle, r1, r2):
    '''Draw a needle at specified angle in specified color.
    r1 and r2 are percentages of clock ray.
    '''
    x1 = width / 2 - ray * cos(angle) * r1
    y1 = height / 2 - ray * sin(angle) * r1
    x2 = width / 2 + ray * cos(angle) * r2
    y2 = height / 2 + ray * sin(angle) * r2
    ctx.beginPath()
    ctx.strokeStyle = "#fff"
    ctx.moveTo(x1, y1)
    ctx.lineTo(x2, y2)
    ctx.stroke()

def set_clock():
    # erase clock
    ctx.beginPath()
    ctx.fillStyle = background
    ctx.arc(width / 2, height / 2, ray * 0.89, 0, 2 * math.pi)
    ctx.fill()

    # redraw hours
    show_hours()

    # print day
    now_time = time.time()
    now = time.localtime(now_time)
    microsecs = now_time - int(now_time)
    day = now.tm_mday
    ctx.font = "bold 14px Arial"
    ctx.textAlign = "center"
    ctx.textBaseline = "middle"
    ctx.fillStyle = "#000"
    ctx.fillText(day, width * 0.7, height * 0.5)

    # draw needles for hour, minute, seconds
    ctx.lineWidth = 2
    hour = now.tm_hour % 12 + now.tm_min / 60
    angle = hour * 2 * math.pi / 12 - math.pi / 2
    needle(angle, 0.05, 0.45)
    minute = now.tm_min
    angle = minute * 2 *math.pi / 60 - math.pi / 2
    needle(angle, 0.05, 0.7)
    ctx.lineWidth = 1
    second = now.tm_sec + microsecs
    angle = second * 2 * math.pi / 60 - math.pi / 2
    needle(angle, 0.05, 0.8)

def show_hours():
    ctx.beginPath()
    ctx.arc(width / 2, height / 2, ray * 0.05, 0, 2 * math.pi)
    ctx.fillStyle = digits
    ctx.fill()
    for i in range(1, 13):
        angle = i * math.pi / 6 - math.pi / 2
        x3 = width / 2 + ray * cos(angle) * 0.82
        y3 = height / 2 + ray * sin(angle) * 0.82
        ctx.font = "18px Arial"
        ctx.textAlign = "center"
        ctx.textBaseline = "middle"
        ctx.fillText(i, x3, y3)
    # cell for day
    ctx.fillStyle = "#fff"
    ctx.fillRect(width * 0.65, height * 0.47, width * 0.1, height * 0.06)

    ctx.beginPath()
ctx.arc(width / 2, height / 2, ray, 0, 2 * math.pi)
ctx.fillStyle = background
ctx.fill()

browser.timer.set_interval(set_clock, 100)
show_hours()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "clock1" 的按鈕點按時, 執行 Clock1 物件中的 prog 方法
doc["clock1"].bind('click', Clock1.prog)
</script>
</p>
<!-- clock1 ends -->
<p></p>
<!-- fourbar linkage starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Fourbar= beditor.editor("""# Fourbar Linkage Simulation
from browser import document, html
import math
import time
import browser.timer
 
class Coord(object):
    def __init__(self,x,y):
        self.x = x
        self.y = y
 
    def __sub__(self,other):
        # This allows you to substract vectors
        return Coord(self.x-other.x,self.y-other.y)
 
    def __repr__(self):
        # Used to get human readable coordinates when printing
        return "Coord(%f,%f)"%(self.x,self.y)
 
    def length(self):
        # Returns the length of the vector
        return math.sqrt(self.x**2 + self.y**2)
 
    def angle(self):
        # Returns the vector's angle
        return math.atan2(self.y,self.x)
 
def normalize(coord):
    return Coord(
        coord.x/coord.length(),
        coord.y/coord.length()
        )
 
def perpendicular(coord):
    # Shifts the angle by pi/2 and calculate the coordinates
    # using the original vector length
    return Coord(
        coord.length()*math.cos(coord.angle()+math.pi/2),
        coord.length()*math.sin(coord.angle()+math.pi/2)
        )
 
# 點類別
class Point(object):
    # 起始方法
    def __init__(self, x, y):
        self.x = x
        self.y = y
 
    # 繪製方法
    def drawMe(self, g, r):
        self.g = g
        self.r = r
        self.g.save()
        self.g.moveTo(self.x,self.y)
        self.g.beginPath()
        # 根據 r 半徑繪製一個圓代表點的所在位置
        self.g.arc(self.x, self.y, self.r, 0, 2*math.pi, True)
        self.g.moveTo(self.x,self.y)
        self.g.lineTo(self.x+self.r, self.y)
        self.g.moveTo(self.x, self.y)
        self.g.lineTo(self.x-self.r, self.y)
        self.g.moveTo(self.x, self.y)
        self.g.lineTo(self.x, self.y+self.r)
        self.g.moveTo(self.x, self.y)
        self.g.lineTo(self.x, self.y-self.r)
        self.g.restore()
        self.g.stroke()
 
    # 加入 Eq 方法
    def Eq(self, pt):
        self.x = pt.x
        self.y = pt.y
 
    # 加入 setPoint 方法
    def setPoint(self, px, py):
        self.x = px
        self.y = py
 
    # 加上 distance(pt) 方法, 計算點到 pt 的距離
    def distance(self, pt):
        self.pt = pt
        x = self.x - self.pt.x
        y = self.y - self.pt.y
        return math.sqrt(x * x + y * y)
 
    # 利用文字標示點的座標位置
    def tag(self, g):
        self.g = g
        self.g.beginPath()
        self.g.fillText("%d, %d"%(self.x, self.y),self.x, self.y)
        self.g.stroke()
 
 
# Line 類別物件
class Line(object):
 
    # 起始方法
    def __init__(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
        # 直線的第一點, 設為線尾
        self.Tail = self.p1
        # 直線組成的第二點, 設為線頭
        self.Head = self.p2
        # 直線的長度屬性
        self.length = math.sqrt(math.pow(self.p2.x-self.p1.x, 2)+math.pow(self.p2.y-self.p1.y,2))
 
    # setPP 以指定頭尾座標點來定義直線
    def setPP(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
        self.Tail = self.p1
        self.Head = self.p2
        self.length = math.sqrt(math.pow(self.p2.x-self.p1.x, 2)+math.pow(self.p2.y-self.p1.y,2))
 
    # setRT 方法 for Line, 應該已經確定 Tail 點, 然後以 r, t 作為設定 Head 的參考
    def setRT(self, r, t):
        self.r = r
        self.t = t
        x = self.r * math.cos(self.t)
        y = self.r * math.sin(self.t)
        self.Tail.Eq(self.p1)
        self.Head.setPoint(self.Tail.x + x,self.Tail.y + y)
 
    # getR 方法 for Line
    def getR(self):
        # x 分量與 y 分量
        x = self.p1.x - self.p2.x
        y = self.p1.y - self.p2.y
        return math.sqrt(x * x + y * y)
 
    # 根據定義 atan2(y,x), 表示 (x,y) 與 正 x 軸之間的夾角, 介於 pi 與 -pi 間
    def getT(self):
        x = self.p2.x - self.p1.x
        y = self.p2.y - self.p1.y
        if (math.fabs(x) < math.pow(10,-100)):
            if(y < 0.0):
                return (-math.pi/2)
            else:
                return (math.pi/2)
        else:
            return math.atan2(y, x)
 
    # setTail 方法 for Line
    def setTail(self, pt):
        self.pt = pt
        self.Tail.Eq(pt)
        self.Head.setPoint(self.pt.x + self.x, self.pt.y + self.y)
 
    # getHead 方法 for Line
    def getHead(self):
        return self.Head
 
    def getTail(self):
        return self.Tail
 
    def drawMe(self, g):
        self.g = g
        self.g.beginPath()
        self.g.moveTo(self.p1.x,self.p1.y)
        self.g.lineTo(self.p2.x,self.p2.y)
        self.g.stroke()
 
    def test(self):
        return ("this is pure test to Inherit")
 
 
class Link(Line):
    def __init__(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
        self.length = math.sqrt(math.pow((self.p2.x - self.p1.x), 2) + math.pow((self.p2.y - self.p1.y), 2))
 
    #g context
    def drawMe(self, g):
        self.g = g
        hole = 5
        radius = 10
        length = self.getR()
        # alert(length)
        # 儲存先前的繪圖狀態
        self.g.save()
        self.g.translate(self.p1.x,self.p1.y)
        #alert(str(self.p1.x)+","+str(self.p1.y))
        #self.g.rotate(-((math.pi/2)-self.getT()))
        self.g.rotate(-math.pi*0.5 + self.getT())
        #alert(str(self.getT()))
        #self.g.rotate(10*math.pi/180)
        #this.g.rotate(-(Math.PI/2-this.getT()));
        # 必須配合畫在 y 軸上的 Link, 進行座標轉換, 也可以改為畫在 x 軸上...
        self.g.beginPath()
        self.g.moveTo(0,0)
        self.g.arc(0, 0, hole, 0, 2*math.pi, True)
        self.g.stroke()
        self.g.moveTo(0,length)
        self.g.beginPath()
        self.g.arc(0,length, hole, 0, 2*math.pi, True)
        self.g.stroke()
        self.g.moveTo(0,0)
        self.g.beginPath()
        self.g.arc(0,0, radius, 0, math.pi, True)
        self.g.moveTo(0+radius,0)
        self.g.lineTo(0+radius,0+length)
        self.g.stroke()
        self.g.moveTo(0,0+length)
        self.g.beginPath()
        self.g.arc(0, 0+length, radius, math.pi, 0, True)
        self.g.moveTo(0-radius,0+length)
        self.g.lineTo(0-radius,0)
        self.g.stroke()
        self.g.restore()
        '''
        self.g.beginPath()
        self.g.fillStyle = "red"
        self.g.font = "bold 18px sans-serif"
        self.g.fillText("%d, %d"%(self.p2.x, self.p2.y),self.p2.x, self.p2.y)
        self.g.stroke()
        '''
 
class Triangle(object):
    def __init__(self, p1, p2, p3):
        self.p1 = p1
        self.p2 = p2
        self.p3 = p3
 
    def getLenp3(self):
        p1 = self.p1
        ret = p1.distance(self.p2)
        return ret
 
    def getLenp1(self):
        p2 = self.p2
        ret = p2.distance(self.p3)
        return ret
 
    def getLenp2(self):
        p1 = self.p1
        ret = p1.distance(self.p3)
        return ret
 
    # 角度
    def getAp1(self):
        ret = math.acos(((self.getLenp2() * self.getLenp2() + self.getLenp3() * self.getLenp3()) - self.getLenp1() * self.getLenp1()) / (2* self.getLenp2() * self.getLenp3()))
        return ret
 
    #
    def getAp2(self):
        ret =math.acos(((self.getLenp1() * self.getLenp1() + self.getLenp3() * self.getLenp3()) - self.getLenp2() * self.getLenp2()) / (2* self.getLenp1() * self.getLenp3()))
        return ret
 
    def getAp3(self):
        ret = math.acos(((self.getLenp1() * self.getLenp1() + self.getLenp2() * self.getLenp2()) - self.getLenp3() * self.getLenp3()) / (2* self.getLenp1() * self.getLenp2()))
        return ret
 
    def drawMe(self, g):
        self.g = g
        r = 5
        # 繪出三個頂點
        self.p1.drawMe(self.g,r)
        self.p2.drawMe(self.g,r)
        self.p3.drawMe(self.g,r)
        line1 = Line(self.p1,self.p2)
        line2 = Line(self.p1,self.p3)
        line3 = Line(self.p2,self.p3)
        # 繪出三邊線
        line1.drawMe(self.g)
        line2.drawMe(self.g)
        line3.drawMe(self.g)
 
    # ends Triangle def
    # 透過三個邊長定義三角形
    def setSSS(self, lenp3, lenp1, lenp2):
        self.lenp3 = lenmidpt = Point(0, 0)
        self.lenp1 = lenp1
        self.lenp2 = lenp2
        self.ap1 = math.acos(((self.lenp2 * self.lenp2 + self.lenp3 * self.lenp3) - self.lenp1 * self.lenp1) / (2* self.lenp2 * self.lenp3))
        self.ap2 = math.acos(((self.lenp1 * self.lenp1 + self.lenp3 * self.lenp3) - self.lenp2 * self.lenp2) / (2* self.lenp1 * self.lenp3))
        self.ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp2 * self.lenp2) - self.lenp3 * self.lenp3) / (2* self.lenp1 * self.lenp2))
 
    # 透過兩個邊長與夾角定義三角形
    def setSAS(self, lenp3, ap2, lenp1):
        self.lenp3 = lenp3
        self.ap2 = ap2
        self.lenp1 = lenp1
        self.lenp2 = math.sqrt((self.lenp3 * self.lenp3 + self.lenp1 * self.lenp1) - 2* self.lenp3 * self.lenp1 * math.cos(self.ap2))
        #等於 SSS(AB, BC, CA)
 
    def setSaSS(self, lenp2, lenp3, lenp1):
        self.lenp2 = lenp2
        self.lenp3 = lenp3
        self.lenp1 = lenp1
        if(self.lenp1 > (self.lenp2 + self.lenp3)):
        #<CAB 夾角為 180 度, 三點共線且 A 介於 BC 之間
            ret = math.pi
        else :
            # <CAB 夾角為 0, 三點共線且 A 不在 BC 之間
            if((self.lenp1 < (self.lenp2 - self.lenp3)) or (self.lenp1 < (self.lenp3 - self.lenp2))):
                ret = 0.0
            else :
            # 透過餘絃定理求出夾角 <CAB 
                ret = math.acos(((self.lenp2 * self.lenp2 + self.lenp3 * self.lenp3) - self.lenp1 * self.lenp1) / (2 * self.lenp2 * self.lenp3))
        return ret
 
    # 取得三角形的三個邊長值
    def getSSS(self):
        temp = []
        temp.append( self.getLenp1() )
        temp.append( self.getLenp2() )
        temp.append( self.getLenp3() )
        return temp
 
    # 取得三角形的三個角度值
    def getAAA(self):
        temp = []
        temp.append( self.getAp1() )
        temp.append( self.getAp2() )
        temp.append( self.getAp3() )
        return temp
 
    # 取得三角形的三個角度與三個邊長
    def getASASAS(self):
        temp = []
        temp.append(self.getAp1())
        temp.append(self.getLenp1())
        temp.append(self.getAp2())
        temp.append(self.getLenp2())
        temp.append(self.getAp3())
        temp.append(self.getLenp3())
        return temp
    #2P 2L return mid P
    def setPPSS(self, p1, p3, lenp1, lenp3):
        temp = []
        self.p1 = p1
        self.p3 = p3
        self.lenp1 = lenp1
        self.lenp3 = lenp3
 
        #bp3 is the angle beside p3 point, cp3 is the angle for line23, p2 is the output
        line31 = Line(p3, p1)
        self.lenp2 = line31.getR()
        #這裡是求角3
        ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp2 * self.lenp2) - self.lenp3 * self.lenp3) / (2 * self.lenp1 * self.lenp2))
        bp3 = line31.getT()
        cp3 = bp3 - ap3
        temp.append(p3.x + self.lenp1*math.cos(cp3))#p2.x
        temp.append(p3.y + self.lenp1*math.sin(cp3))#p2.y
        return temp
 
def tag(g, p):
    None
 
midpt = Point(0, 0)
tippt = Point(0, 0)
contour = []
# 執行繪圖流程, 注意 x, y 為 global variables
def draw():
    global theta, midpt, oldpt
    context.clearRect(0, 0, canvas.width, canvas.height)
    line1.drawMe(context)
    line2.drawMe(context)
    line3.drawMe(context)
    #triangle1.drawMe(context)
    #triangle2.drawMe(context)
    theta += dx
    p2.x = p1.x + line1.length*math.cos(theta*degree)
    p2.y = p1.y - line1.length*math.sin(theta*degree)
    p3.x, p3.y = triangle2.setPPSS(p2,p4,link2_len,link3_len)
    # 計算垂直單位向量
    a = Coord(p3.x, p3.y)
    b = Coord(p2.x, p2.y)
    normal = perpendicular(normalize(a-b))
    midpt.x = (p2.x + p3.x)/2
    midpt.y = (p2.y + p3.y)/2
    tippt.x = midpt.x + 150*normal.x
    tippt.y = midpt.y + 150*normal.y
    if theta < 360:
        contour.append((tippt.x, tippt.y))
    context.beginPath()
    context.moveTo(midpt.x, midpt.y)
    context.lineTo(tippt.x, tippt.y)
    # 利用 fillRect 繪製一個長寬各 1 單位的正方形
    for i in range(len(contour)):
        context.fillRect(contour[i][0], contour[i][1], 1, 1)
    context.stroke()
    #p1.tag(context)
 
# 以上為相關函式物件的定義區
# 全域變數
# 幾何位置輸入變數
x=10
y=10
r=10
 
# 畫布與繪圖內容
# 其他輸入變數
theta = 0
degree = math.pi/180.0
dx = 2
dy = 4
 
#set p1.p2.p3.p4 position
lift = 10
p1 =  Point(150,100+lift)
p2 =  Point(150,200+lift)
p3 =  Point(300,300+lift)
p4 =  Point(350,100+lift)
 
#accord position create link
line1 =  Link(p1,p2)
line2 =  Link(p2,p3)
line3 =  Link(p3,p4)
line4 =  Link(p1,p4)
line5 =  Link(p2,p4)
 
link2_len = p2.distance(p3)
link3_len = p3.distance(p4)
 
#link2_len = line1.getR()
#link3_len = line3.getR()
#alert(str(link2_len)+','+str(link3_len))
 
triangle1 =  Triangle(p1,p2,p4)
triangle2 =  Triangle(p2,p3,p4)
 
# 視窗載入時執行內容
# 繪圖畫布設定

canvas = html.CANVAS(width = 600, height = 450)
canvas.id = "line_drawing"
brython_div = document["brython_div"]
brython_div <= canvas
# 準備繪圖畫布
canvas = document["line_drawing"]
context = canvas.getContext("2d")
 
# 座標轉換, 移動 canvas.height 並且 y 座標變號, 也就是將原點座標移到畫面左下角
context.translate(0,canvas.height)
context.scale(1,-1)
 
#以間隔 20 micro seconds 重複呼叫 draw()
browser.timer.set_interval(draw,20)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "fourbar" 的按鈕點按時, 執行 Fourbar 物件中的 prog 方法
doc["fourbar"].bind('click', Fourbar.prog)
</script>
</p>
<!-- fourbar linkage ends -->
<p></p>
<!-- snake starts -->
<p>
<script type="text/python3">
from browser import document as doc
# 導入位於 static 目錄下的 beditor.py 
import beditor
# 利用 beditor.py 中的 editor 類別建立案例, 對應到 kw1
Snake = beditor.editor("""# 從 browser 導入 document 並設為 doc
from browser import document as doc
# 使用者可以透過 window 當作介面使用其他 Javascript 功能
from browser import html, window
# 用於定時執行特定函式
import browser.timer
# 導入數學模組
import math
# 導入亂數模組
from random import random, randint

def update_score(new_score):
    global high_score
    score_doc.innerHTML = "Score: " + str(new_score)
    if new_score > high_score:
        high_score_doc.innerHTML = "High Score: " + str(new_score)
        high_score = new_score
    
def game():
    global px, py, tc, gs, ax, ay, trail, tail, score
    # px 為 snake 第一個點的 x 座標, 增量值為 xv
    px += xv
    py += yv
    # 允許穿越四面牆, 以 tc 表示牆面座標極限
    # 若 px 為負值則設定為 tc -1, 表示 tc 為 x 方向 limit
    # x 座標方向的穿牆設定
    if px < 0:
        px = tc-1
    if px > tc-1:
        px = 0
    # y 座標方向的穿牆設定
    if py < 0:
        py = tc-1
    if py > tc-1:
        py = 0
    ctx.fillStyle = "black"
    # 畫布填入黑色
    ctx.fillRect(0, 0, canvas.width, canvas.height)
    # snake 為 lime 色
    ctx.fillStyle = "lime"
    # trail 為數列, 代表 snake 各節 [x,y] 座標
    # trail = [[x0,y0], [x1, y1], [x2, y2]...]
    # gs 為方塊邊長 pixel 數
    for i in range(len(trail)):
        # https://developer.mozilla.org/zh-TW/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes
        # fillRect(x, y, width, height)
        ctx.fillRect(trail[i][0]*gs, trail[i][1]*gs, gs-2, gs-2)
        # 若 snake 第一節座標 (px, py)  穿過身體任一節, 則 score 歸零
        if trail[i][0] == px and trail[i][1] == py:
            score = score if paused else 0
            # snake reset 為五節
            tail = 5
    # trail 數列以碰到的 [px, py] 座標數列插入作為第一節
    trail.insert(0, [px, py])
    while len(trail) > tail:
        # pop() 內建移除數列最後一個 element
        trail.pop()
    # ax, ay 為紅點座標
    # 當 snake 第一節座標[px, py] 與紅色食物座標 [ax, ay] 重合
    # 則 tail 增量, 即多一節且得分加 1, 然後食物座標 [ax, ay] 重新以亂數定位
    if ax == px and ay == py:
        tail += 1
        ax = math.floor(random()*tc)
        ay = math.floor(random()*tc)
        score += 1
    # 更新計分顯示
    update_score(score)
    ctx.fillStyle = "red"
    ctx.fillRect(ax*gs, ay*gs, gs-2, gs-2)
  
def key_push(evt):
    global xv, yv, pre_pause, paused
    key = evt.keyCode
    # 37 is left arrow key
    # 74 is j key
    if key == 74 and not paused:
        xv = -1
        yv = 0
    # 38 is up arrow key
    # 73 is i key
    elif key == 73 and not paused:
        xv = 0
        yv = -1
    # 39 is right arrow key
    # 76 is l key
    elif key == 76 and not paused:
        xv = 1
        yv = 0
    # 40 is down arrow key
    # 77 is m key
    elif key == 77 and not paused:
        xv = 0
        yv = 1
    # 32 is pause key
    # 80 is p key
    elif key == 80:
        temp = [xv, yv]
        xv = pre_pause[0]
        yv = pre_pause[1]
        pre_pause = [*temp]
        paused = not paused
  
def show_instructions(evt):
        window.alert("keys to control: i=up, m=down, j=left, l=right, p=pause")
      
# 利用 html 建立 canvas 超文件物件
canvas = html.CANVAS(width = 600, height = 600)
canvas.id = "game-board"
brython_div = doc["brython_div"]
brython_div <= canvas
  
score_doc = html.DIV("score")
score_doc.id = "score"
brython_div <= score_doc
  
high_score_doc = html.DIV("high-score")
high_score_doc.id = "high-score"
brython_div <= high_score_doc
  
button = html.BUTTON("Keys to control")
button.id = "instructions-btn"
brython_div <= button
  
score = 0
high_score = 0
  
px = py = 10
# gs*tc = canvas width and height
gs = 20
tc = 30
ax = ay = 15
xv = yv = 0
trail = []
tail = 5
  
pre_pause = [0,0]
paused = False
ctx = canvas.getContext("2d")
doc.addEventListener("keydown", key_push)
instructions_btn = doc["instructions-btn"]
instructions_btn.addEventListener("click", show_instructions)
browser.timer.set_interval(game, 1000/15)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "snake 的按鈕點按時, 執行 Snake 物件中的 prog 方法
doc["snake"].bind('click', Snake.prog)
</script>
</p>
<!-- snake ends -->
<p></p>
<!-- sudoku starts -->
<p>
<script type="text/python3">
from browser import document as doc
# 導入位於 static 目錄下的 beditor.py 
import beditor
# 利用 beditor.py 中的 editor 類別建立案例, 對應到 kw1
Sudoku = beditor.editor("""# from https://github.com/BHoggs/sudoku-speedtest
#from timeit import default_timer as timer

board = [
    [0,0,0, 0,3,0, 0,0,0],
    [0,0,1, 0,7,6, 9,4,0],
    [0,8,0, 9,0,0, 0,0,0],

    [0,4,0, 0,0,1, 0,0,0],
    [0,2,8, 0,9,0, 0,0,0],
    [0,0,0, 0,0,0, 1,6,0],

    [7,0,0, 8,0,0, 0,0,0],
    [0,0,0, 0,0,0, 4,0,2],
    [0,9,0, 0,1,0, 3,0,0]
]

def print_board():
    global board
    for i in range(9):
        if i % 3 == 0 and i != 0:
            print ("- - - - - - - - - - -")

        for j in range(9):
            if j % 3 == 0 and j != 0:
                print("| ", end='')

            if j == 8:
                print (board[i][j])

            else:
                print (str(board[i][j]) + " ", end='')

def find_empty():
    global board
    for i in range(9):
        for j in range(9):
            if board[i][j] == 0:
                return (i, j)  # row, col

    return None


def valid(num, pos):
    global board
    # Check row
    for i in range(9):
        if board[pos[0]][i] == num and pos[1] != i:
            return False

    # Check column
    for i in range(9):
        if board[i][pos[1]] == num and pos[0] != i:
            return False

    # Check box
    box_x = pos[1] // 3
    box_y = pos[0] // 3

    for i in range(box_y*3, box_y*3 + 3):
        for j in range(box_x*3, box_x*3 + 3):
            if board[i][j] == num and (i,j) != pos:
                return False

    return True

def solve():
    global board
    find = find_empty()
    if not find:
        return True

    else:
        row, col = find
        #print ("Solving... Row: %d, Col: %d" % (row+1,col+1), end='')

    for i in range(1, 10):
        if valid(i, (row, col)):
            board[row][col] = i

            if solve():
                return True

            board[row][col] = 0

    return False


print_board()

#start = timer()
solve()
#print("")
#print("Seconds to Solve: ", timer() - start)

print ("")
print ("_____________________")
print_board()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "sudoku 的按鈕點按時, 執行 Sudoku 物件中的 prog 方法
doc["sudoku"].bind('click', Sudoku.prog)
</script>
</p>
<!-- sudoku ends -->
<p></p>
<!-- autosnake starts -->
<p>
<script type="text/python3">
from browser import document as doc
# 導入位於 static 目錄下的 beditor.py 
import beditor
# 利用 beditor.py 中的 editor 類別建立案例, 對應到 kw1
Autosnake = beditor.editor("""# 從 browser 導入 document 並設為 doc
from browser import document as doc
# 使用者可以透過 window 當作介面使用其他 Javascript 功能
from browser import html, window
# 用於定時執行特定函式
import browser.timer
# 導入數學模組
import math
# 導入亂數模組
from random import random, randint
 
def update_score(new_score):
    global high_score
    score_doc.innerHTML = "Score: " + str(new_score)
    if new_score > high_score:
        high_score_doc.innerHTML = "High Score: " + str(new_score)
        high_score = new_score
        
def eat(px, py, ax, ay):
    global xv, yv, pre_pause, paused
    # (px, py) go to (ax, ay) through incremented xv, yv
    if ax != px or ay != py:
        if ax > px and not paused:
            xv = 1
            yv = 0
        if ax < px and not paused:
            xv = -1
            yv = 0
        if ay > py and not paused:
            xv = 0
            yv = 1
        if ay < py and not paused:
            xv = 0
            yv = -1
            
def game():
    global px, py, tc, gs, ax, ay, trail, tail, score
    # px 為 snake 第一個點的 x 座標, 增量值為 xv
    px += xv
    py += yv
    # 允許穿越四面牆, 以 tc 表示牆面座標極限
    # 若 px 為負值則設定為 tc -1, 表示 tc 為 x 方向 limit
    # x 座標方向的穿牆設定
    if px < 0:
        px = tc-1
    if px > tc-1:
        px = 0
    # y 座標方向的穿牆設定
    if py < 0:
        py = tc-1
    if py > tc-1:
        py = 0
    ctx.fillStyle = "black"
    # 畫布填入黑色
    ctx.fillRect(0, 0, canvas.width, canvas.height)
    # snake 為 lime 色
    ctx.fillStyle = "lime"
    # trail 為數列, 代表 snake 各節 [x,y] 座標
    # trail = [[x0,y0], [x1, y1], [x2, y2]...]
    # gs 為方塊邊長 pixel 數
    for i in range(len(trail)):
        # https://developer.mozilla.org/zh-TW/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes
        # fillRect(x, y, width, height)
        ctx.fillRect(trail[i][0]*gs, trail[i][1]*gs, gs-2, gs-2)
        # 若 snake 第一節座標 (px, py)  穿過身體任一節, 則 score 歸零
        if trail[i][0] == px and trail[i][1] == py:
            score = score if paused else 0
            # snake reset 為五節
            tail = 5
    # trail 數列以碰到的 [px, py] 座標數列插入作為第一節
    trail.insert(0, [px, py])
    while len(trail) > tail:
        # pop() 內建移除數列最後一個 element
        trail.pop()
    # ax, ay 為紅點座標
    # 當 snake 第一節座標[px, py] 與紅色食物座標 [ax, ay] 重合
    # 則 tail 增量, 即多一節且得分加 1, 然後食物座標 [ax, ay] 重新以亂數定位
    if ax == px and ay == py:
        tail += 1
        ax = math.floor(random()*tc)
        ay = math.floor(random()*tc)
        score += 1
    # [ax, ay] is known here
    # [px, py] is where the head of the snake
    # xv needed to be incremented from px to ax first
    # and yv needed to be incremented from py to ay
    eat(px, py, ax, ay)
    # 更新計分顯示
    update_score(score)
    ctx.fillStyle = "red"
    ctx.fillRect(ax*gs, ay*gs, gs-2, gs-2)
   
def key_push(evt):
    global xv, yv, pre_pause, paused
    key = evt.keyCode
    # 37 is left arrow key
    # 74 is j key
    if key == 74 and not paused:
        xv = -1
        yv = 0
    # 38 is up arrow key
    # 73 is i key
    elif key == 73 and not paused:
        xv = 0
        yv = -1
    # 39 is right arrow key
    # 76 is l key
    elif key == 76 and not paused:
        xv = 1
        yv = 0
    # 40 is down arrow key
    # 77 is m key
    elif key == 77 and not paused:
        xv = 0
        yv = 1
    # 32 is pause key
    # 80 is p key
    elif key == 80:
        temp = [xv, yv]
        xv = pre_pause[0]
        yv = pre_pause[1]
        pre_pause = [*temp]
        paused = not paused
   
def show_instructions(evt):
        window.alert("keys to control: i=up, m=down, j=left, l=right, p=pause")
       
# 利用 html 建立 canvas 超文件物件
canvas = html.CANVAS(width = 600, height = 600)
canvas.id = "game-board"
brython_div = doc["brython_div"]
brython_div <= canvas
   
score_doc = html.DIV("score")
score_doc.id = "score"
brython_div <= score_doc
   
high_score_doc = html.DIV("high-score")
high_score_doc.id = "high-score"
brython_div <= high_score_doc
   
button = html.BUTTON("Keys to control")
button.id = "instructions-btn"
brython_div <= button
   
score = 0
high_score = 0
   
px = py = 10
# gs*tc = canvas width and height
gs = 20
tc = 30
ax = ay = 15
xv = yv = 0
trail = []
tail = 5
   
pre_pause = [0,0]
paused = False
ctx = canvas.getContext("2d")
doc.addEventListener("keydown", key_push)
instructions_btn = doc["instructions-btn"]
instructions_btn.addEventListener("click", show_instructions)
browser.timer.set_interval(game, 1000/15)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "autosnake 的按鈕點按時, 執行 Autosnake 物件中的 prog 方法
doc["autosnake"].bind('click', Autosnake.prog)
</script>
</p>
<!-- autosnake ends -->
<p><button id="keyword">Keyword</button><button id="ex1">Ex1</button><button id="ex2">Ex2</button><button id="ex3">Ex3</button><button id="ex4">Ex4</button><button id="forloop">Ex5</button><button id="class_ex6">Ex6</button><button id="guess">Guess</button><button id="autoguess">Autoguess</button><button id="lottery">大樂透</button><button id="weleadlottery">威力彩</button><button id="snake">貪食蛇</button><button id="autosnake">貪食蛇2</button><button id="sudoku">Sudoku</button><button id="temp">Temp</button><button id="draw">Draw</button><button id="flag">Flag</button><button id="bezier">Bezier</button><button id="clock1">clock1</button><button id="fourbar">Fourbar</button><button id="turtle1">Turtle1</button><button id="turtle2">Turtle2</button><button id="turtle3">Turtle3</button><button id="turtle4">Turtle4</button><button id="turtle5">Turtle5</button><button id="turtle6">Turtle6</button><button id="turtle7">Turtle7</button><button id="turtle8">Turtle8</button><button id="konva1">Konva1</button><button id="bunny">Bunny</button><button id="ball">Ball</button><button id="spur">Spur</button><button id="ycqsort">Ycqsort</button><button id="nfulist">nfulist</button><button id="clear">Clear</button></p>
<h4>參考資料:</h4>
<p style="padding-left: 30px;"><a href="https://docs.python.org/3/library/turtle.html">https://docs.python.org/3/library/turtle.html</a></p>
<p style="padding-left: 30px;"><a href="https://realpython.com/beginners-guide-python-turtle/">https://realpython.com/beginners-guide-python-turtle/</a></p>
<p>其他擷取程式的方式: <a href="http://mde.tw/2017springvcp/blog/web-based-python.html">http://mde.tw/2017springvcp/blog/web-based-python.html</a></p>
<h4>Qt for Python</h4>
<p><a href="https://www.qt.io/qt-for-python">https://www.qt.io/qt-for-python</a></p>
<p><a href="https://build-system.fman.io/python-qt-tutorial">https://build-system.fman.io/python-qt-tutorial</a></p>
<p><a href="https://build-system.fman.io/pyqt-exe-creation/">https://build-system.fman.io/pyqt-exe-creation/</a></p>
<p><a href="https://github.com/mherrmann/fbs-tutorial">https://github.com/mherrmann/fbs-tutorial</a></p>
<p><a href="https://www.ics.com/blog/we-ported-qt-app-c-python-heres-what-happened">https://www.ics.com/blog/we-ported-qt-app-c-python-heres-what-happened</a></p>
<p>
<script src="/static/konva.min.js"></script>
</p>
<p>
<script>
var width = window.innerWidth;
    var height = window.innerHeight;
    // globals
    var curveLayer, lineLayer, anchorLayer, quad, bezier;
    function updateDottedLines() {
        var q = quad;
        var b = bezier;
        var quadLine = lineLayer.get('#quadLine')[0];
        var bezierLine = lineLayer.get('#bezierLine')[0];
        quadLine.setPoints([q.start.attrs.x, q.start.attrs.y, q.control.attrs.x, q.control.attrs.y, q.end.attrs.x, q.end.attrs.y]);
        bezierLine.setPoints([b.start.attrs.x, b.start.attrs.y, b.control1.attrs.x, b.control1.attrs.y, b.control2.attrs.x, b.control2.attrs.y, b.end.attrs.x, b.end.attrs.y]);
        lineLayer.draw();
    }
    function buildAnchor(x, y) {
        var anchor = new Konva.Circle({
            x: x,
            y: y,
            radius: 20,
            stroke: '#666',
            fill: '#ddd',
            strokeWidth: 2,
            draggable: true
        });
        // add hover styling
        anchor.on('mouseover', function() {
            document.body.style.cursor = 'pointer';
            this.setStrokeWidth(4);
            anchorLayer.draw();
        });
        anchor.on('mouseout', function() {
            document.body.style.cursor = 'default';
            this.setStrokeWidth(2);
            anchorLayer.draw();
        });
        anchor.on('dragend', function() {
            drawCurves();
            updateDottedLines();
        });
        anchorLayer.add(anchor);
        return anchor;
    }
    function drawCurves() {
        var context = curveLayer.getContext();
        context.clear();
        // draw quad
        context.beginPath();
        context.moveTo(quad.start.attrs.x, quad.start.attrs.y);
        context.quadraticCurveTo(quad.control.attrs.x, quad.control.attrs.y, quad.end.attrs.x, quad.end.attrs.y);
        context.setAttr('strokeStyle', 'red');
        context.setAttr('lineWidth', 4);
        context.stroke();
        // draw bezier
        context.beginPath();
        context.moveTo(bezier.start.attrs.x, bezier.start.attrs.y);
        context.bezierCurveTo(bezier.control1.attrs.x, bezier.control1.attrs.y, bezier.control2.attrs.x, bezier.control2.attrs.y, bezier.end.attrs.x, bezier.end.attrs.y);
        context.setAttr('strokeStyle', 'blue');
        context.setAttr('lineWidth', 4);
        context.stroke();
    }
    var stage = new Konva.Stage({
        container: 'container',
        width: width,
        height: height
    });
    anchorLayer = new Konva.Layer();
    lineLayer = new Konva.Layer();
    // curveLayer just contains a canvas which is drawn
    // onto with the existing canvas API
    curveLayer = new Konva.Layer();
    var quadLine = new Konva.Line({
        dash: [10, 10, 0, 10],
        strokeWidth: 3,
        stroke: 'black',
        lineCap: 'round',
        id: 'quadLine',
        opacity: 0.3,
        points: [0, 0]
    });
    var bezierLine = new Konva.Line({
        dash: [10, 10, 0, 10],
        strokeWidth: 3,
        stroke: 'black',
        lineCap: 'round',
        id: 'bezierLine',
        opacity: 0.3,
        points: [0, 0]
    });
    // add dotted line connectors
    lineLayer.add(quadLine);
    lineLayer.add(bezierLine);
    quad = {
        start: buildAnchor(60, 30),
        control: buildAnchor(240, 110),
        end: buildAnchor(80, 160)
    };
    bezier = {
        start: buildAnchor(280, 20),
        control1: buildAnchor(530, 40),
        control2: buildAnchor(480, 150),
        end: buildAnchor(300, 150)
    };
    // keep curves insync with the lines
    anchorLayer.on('beforeDraw', function() {
        drawCurves();
        updateDottedLines();
    });
    stage.add(curveLayer);
    stage.add(lineLayer);
    stage.add(anchorLayer);
    drawCurves();
    updateDottedLines();
</script>
</p>
<h4>延伸練習題:</h4>
<p style="padding-left: 30px;">上述網際 Python 程式範例執行, 是透過 <a href="https://brython.info/">Brython</a> 達成, 但是卻必須將所有 Python 範例程式碼逐一寫在網頁中 (<span style="background-color: #ccffcc;">方式 1</span>), 而 <a href="http://mde.tw/2017springvcp/blog/web-based-python.html">http://mde.tw/2017springvcp/blog/web-based-python.html</a> 的寫法, 則是將程式範例存入相對目錄中 (<span style="background-color: #ccffcc;">方式 2</span>), 然後當使用者點擊對應 button 時, 才將程式碼取出放入 editor 區域中.</p>
<p style="padding-left: 30px;">至於 <a href="http://mde.tw/cp2019/content/Task2.html">http://mde.tw/cp2019/content/Task2.html</a> 的取檔案方式, 則是將 <a href="https://dart.dev/">Dart</a> 範例程式存入 <a href="https://docs.github.com/en/github/writing-on-github/editing-and-sharing-content-with-gists/creating-gists">Gist</a> (<span style="background-color: #ccffcc;">方式 3</span>), 然後取出最新對應版本後載入 editor 區域.</p>
<p style="padding-left: 30px;">而 <a href="http://mde.tw/lab/downloads/lua/index.html?filename=guess2">http://mde.tw/lab/downloads/lua/index.html?filename=guess2</a> 則利用 URL <a href="https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Methods">Request</a> 方法取 Get 變數值後, 再根據範例檔案名稱取出存於相對目錄的程式碼, 將內容放入 editor 區域中 (<span style="background-color: #ccffcc;">方式 4</span>).</p>
<p style="padding-left: 30px;">請研究上述方式 1 的網際 Python 程式範例編輯與載入執行架構, 分別改為其他三種方式, 並討論其使用差異與優缺點.</p>
<p style="padding-left: 30px;"><a href="http://doctorsrn.cn/2019/08/08/CodingInterviewChinese2/">Python 刷題練習</a></p>
<p style="padding-left: 30px;">自 Python 3.5 之後支援 typing: <a href="https://docs.python.org/3/library/typing.html">https://docs.python.org/3/library/typing.html</a>, 也可以使用 <a href="https://mypy.readthedocs.io/en/stable/index.html">Mypy</a> 進行 static type check. Brython 3.9 也<a href="https://github.com/brython-dev/brython/blob/master/www/src/Lib/typing.py">支援 typing</a>. <a href="https://mde.tw/cp2021/content/run.html?src=https://gist.githubusercontent.com/mdecourse/c7d4da756f42ed82f472a4eb2ba904e2/raw/78dc95aecb82762e06a204f5094ed1d6b38111b6/static_typing_ex1.py">範例1</a>, <a href="https://mde.tw/cp2021/content/run.html?src=https://gist.githubusercontent.com/mdecourse/c7d4da756f42ed82f472a4eb2ba904e2/raw/78dc95aecb82762e06a204f5094ed1d6b38111b6/static_typing_ex2.py">範例2</a>.</p>
<p style="padding-left: 60px;"><a href="https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html">https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html</a> </p>
<p style="padding-left: 60px;"><a href="https://medium.com/@ageitgey/learn-how-to-use-static-type-checking-in-python-3-6-in-10-minutes-12c86d72677b">https://medium.com/@ageitgey/learn-how-to-use-static-type-checking-in-python-3-6-in-10-minutes-12c86d72677b</a> </p>
<p style="padding-left: 30px;">科學界正利用 Python 解決的問題: <a href="https://deepmind.com/blog/article/alphafold-a-solution-to-a-50-year-old-grand-challenge-in-biology">https://deepmind.com/blog/article/alphafold-a-solution-to-a-50-year-old-grand-challenge-in-biology</a></p>
<p style="padding-left: 60px;"><a href="https://github.com/deepmind/deepmind-research/tree/master/alphafold_casp13">https://github.com/deepmind/deepmind-research/tree/master/alphafold_casp13</a></p>
<p style="padding-left: 60px;"><a href="https://predictioncenter.org/casp14/doc/CASP14_Abstracts.pdf">https://predictioncenter.org/casp14/doc/CASP14_Abstracts.pdf</a></p><h3>Brython</h3>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/VJj-H4we71g" title="YouTube video player" width="560"></iframe></p>
<p><a href="https://github.com/brython-dev/brython/wiki/How-Brython-works">https://github.com/brython-dev/brython/wiki/How-Brython-works</a></p>
<p style="padding-left: 30px;">HTML 教程: <a href="https://wangdoc.com/html/">https://wangdoc.com/html/</a></p>
<p style="padding-left: 30px;">Javascript 教程: <a href="https://wangdoc.com/javascript/index.html">https://wangdoc.com/javascript/index.html</a></p>
<p>上一頁的網際 Python 是透過 <a href="https://brython.info/">https://brython.info/</a> 完成, 當使用者在網頁中執行 Python 程式時, 透過 Brython 即時轉為 Javascript 後執行. (<a href="https://en.wikipedia.org/wiki/B%C3%A9zier_curve">Bezier</a> <a href="https://mde.tw/cp2021/content/run.html?src=https://gist.githubusercontent.com/mdecourse/2089a943b8fc260c2ca3ce4d0c886b1f/raw/e70f973d0b58f9db5fc6932960ef633421792f35/bezier24v3.py">範例</a>)</p>
<p>Brython Google Group: <a href="https://groups.google.com/g/brython">https://groups.google.com/g/brython</a></p>
<h4>Introduction guide to Brython:</h4>
<p style="padding-left: 30px;"><a href="https://stackabuse.com/an-introductory-guide-to-brython">https://stackabuse.com/an-introductory-guide-to-brython</a></p>
<p style="padding-left: 30px;"><a href="https://www.geeksforgeeks.org/introduction-to-brython/">https://www.geeksforgeeks.org/introduction-to-brython/</a></p>
<p style="padding-left: 30px;"><a href="https://realpython.com/brython-python-in-browser/">https://realpython.com/brython-python-in-browser/</a></p>
<h4>Game in Brython:</h4>
<p style="padding-left: 30px;"><a href="https://medium.com/swlh/sick-of-javascript-just-use-browser-python-4b9679efe08b">https://medium.com/swlh/sick-of-javascript-just-use-browser-python-4b9679efe08b</a></p>
<h4>Calculator in Brython (應該可以透過 Brython <a href="https://brython.info/static_doc/en/html.html">html</a> 將 style 放入程式中):</h4>
<p><a href="https://codehs.com/tutorial/zach/Intro_to_Brython_-_Calculator">https://codehs.com/tutorial/zach/Intro_to_Brython_-_Calculator</a></p>
<p><a href="/downloads/calculator.html">calculator.html</a></p>
<p><iframe height="300" src="/downloads/calculator.html" width="640"></iframe></p>
<h4>calculator.html 原始碼:</h4>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;!-- 直接從 cdn 導入 brython 程式庫 --&gt;
        &lt;script type="text/javascript" src="https://cdn.jsdelivr.net/npm/brython@3.8.8/brython.min.js"&gt;&lt;/script&gt;
&lt;!-- 設定適合用於 calculator 的 table td 格式 --&gt;
&lt;style&gt;
*{
    font-family: sans-serif;
    font-weight: normal;
    font-size: 1.1em;
}
td{
    width: 80px;
    background-color: #ccc;
    padding: 10px 30px 10px 30px;
    border-radius: 0.2em;
    text-align: center;
    cursor: default;
}
#result{
    border-color: #000;
    border-width: 1px;
    border-style: solid;
    padding: 10px 30px 10px 30px;
    text-align: right;
}
&lt;/style&gt;
    &lt;/head&gt;

    &lt;body onload="brython()"&gt;
        &lt;script type="text/python"&gt;
            from browser import document, html
            # calc 為 html table
            calc = html.TABLE()
            calc &lt;= html.TR(html.TH(html.DIV("0", id="result"), colspan=3) +
                            html.TD("C"))
            lines = ["789/", "456*", "123-", "0.=+"]
            
            calc &lt;= (html.TR(html.TD(x) for x in line) for line in lines)
            
            document &lt;= calc
            
            result = document["result"] # direct acces to an element by its id
            
            def action(event):
                """Handles the "click" event on a button of the calculator."""
                # The element the user clicked on is the attribute "target" of the
                # event object
                element = event.target
                # The text printed on the button is the element's "text" attribute
                value = element.text
                if value not in "=C":
                    # update the result zone
                    if result.text in ["0", "error"]:
                        result.text = value
                    else:
                        result.text = result.text + value
                elif value == "C":
                    # reset
                    result.text = "0"
                elif value == "=":
                    # execute the formula in result zone
                    try:
                        result.text = eval(result.text)
                    except:
                        result.text = "error"
            
            # Associate function action() to the event "click" on all buttons
            for button in document.select("td"):
                button.bind("click", action)
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre>
<h4>延伸練習:</h4>
<p style="padding-left: 30px;">請將上述網際加減乘除計算機, 以 Brython(Browser Python) 改為<a href="https://www.eeweb.com/tools/online-scientific-calculator/">網際工程用計算機</a>.</p>
<h3>網際模擬程式</h3>
<p><a href="https://mdecp2018.github.io/finalproject-bgx/content/%E7%B6%B2%E9%9A%9B%E6%A8%A1%E6%93%AC%E7%A8%8B%E5%BC%8F.html">網際模擬程式原始網頁</a></p>
<p><a href="https://github.com/mdecourse/webgame">https://github.com/mdecourse/webgame</a> 是一套源自<a href="https://github.com/tiggerntatie/brython-server"> https://github.com/tiggerntatie/brython-server</a> 的網際模擬程式庫, 適合用來開發線上遊戲或與工程設計相關的網際程式.</p>
<p>之前的 js 程式庫都採用遠端資料, 目前將各程式庫升級為最新版本, 且改為自帶程式庫.</p>
<p>參考的網際程式庫: <a href="https://github.com/tiggerntatie/ggame">https://github.com/tiggerntatie/ggame</a> </p>
<p>由於此 ggame 程式庫使用</p>
<p>jquery-3.3.1.min.js - <a href="https://jquery.com/">https://jquery.com/</a> <br/>jquery-ui.1.12.1.min.js - <a href="https://jqueryui.com/">https://jqueryui.com/</a> <br/>pixi-4.8.2.min.js - <a href="http://www.pixijs.com/">http://www.pixijs.com/</a> <br/>buzz-1.2.1.js - <a href="http://buzz.jaysalvat.com/">http://buzz.jaysalvat.com/</a> <br/>brython3.9.4.js - <a href="https://brython.info/">https://brython.info/</a> <br/>brython_stdlib3.9.4.js</p>
<p>因此使用者必須對上述程式庫有些了解後, 再深入研究如何使用  ggame 程式庫開發專案套件.</p>
<p>使用者可以登入 github.com 後, 連結至 <a href="https://github.com/mdecourse/webgame">https://github.com/mdecourse/webgame</a> 選擇將 webgame 倉儲作為 template 後新增網際程式倉儲, 之後可以利用 Leo Editor 進行後續程式開發.</p>
<h3>Spacewar</h3>
<p><a href="https://mdecp2018.github.io/finalproject-bgx/content/%E7%B6%B2%E9%9A%9B%E6%A8%A1%E6%93%AC%E7%A8%8B%E5%BC%8F.html">2018 網際模擬程式</a></p>
<p><a href="/downloads/ggame-readthedocs-io-en-latest.pdf">ggame documentation.pdf</a></p>
<p>another game engine in brython: <a href="https://github.com/mdecourse/brython-game-engine-demo">https://github.com/mdecourse/brython-game-engine-demo</a></p>
<p>
<script src="/static/brython.js"></script>
</p>
<!-- check if we need brython_stdlib.js or not -->
<p></p>
<!-- <script src="/static/brython_stdlib.js"></script> -->
<p></p>
<!-- for ggame -->
<p>
<script src="/static/jquery-3.3.1.min.js"></script>
<script src="/static/jquery-ui.1.12.1.min.js"></script>
<script src="/static/pixi-3.0.5.min.js"></script>
<script src="/static/buzz-1.2.1.js"></script>
<script src="/static/bs.js"></script>
</p>
<!-- brython_modules.js is ggame brython library converted into javascript -->
<p>
<script src="/downloads/brython_modules.js"></script>
</p>
<!-- start brython -->
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/']});
}
</script>
</p>
<!-- ggame will show on graphics-column markup -->
<div id="graphics-column"></div>
<p>
<script type="text/python3">
from ggame import App, Sprite, ImageAsset, Frame, CircleAsset
from ggame import SoundAsset, Sound, TextAsset, Color
import math
from time import time
from browser import document as doc
from browser import html
import socket

# bring in the id="graphics-column" markup
graphics_column = doc["graphics-column"]
# create "ggame-canvas" canvas markup
canvas = html.CANVAS(width = 600, height = 600)
canvas.id = "ggame-canvas"
# insert canvas into the graphics_column div markup
graphics_column <= canvas

# can we get the execution mode through brython
# when work with dynamic site
if socket.gethostname() == "localhost":
    site = ""
else:
    # when work with remote site
    site="./.."

class Stars(Sprite):

    asset = ImageAsset(site+"/images/starfield.jpg")
    width = 512
    height = 512

    def __init__(self, position):
        super().__init__(Stars.asset, position)

# Sun 類別繼承自 Sprite
class Sun(Sprite):
    
    width = 80
    height = 76
    asset = ImageAsset(site+"/images/sun.png", Frame(0, 0, width, height))
    
    def __init__(self, position):
        super().__init__(Sun.asset, position, CircleAsset(32))
        self.mass = 30*1000
        self.fxcenter = 0.5
        self.fycenter = 0.5

class Vector:
    
    def __init__(self, x, y):
        self.x = x
        self.y = y
        
    def mag(self):
        return math.sqrt(self.x*self.x + self.y*self.y)
    
    def unit(self):
        r = self.mag()
        if r == 0:
            return Vector(0,0)
        else:
            return Vector(self.x/r, self.y/r)

class GravitySprite(Sprite):
    
    G = 50.0

    def __init__(self, asset, collisionasset, position, velocity, sun):
        super().__init__(asset, position, collisionasset)
        self.vx = velocity[0]
        self.vy = velocity[1]
        self.sun = sun
        self.fxcenter = 0.5
        self.fycenter = 0.5
        self.rrate = 0.0
        self.thrust = 0.0
        self.mass = 1.0
        
    def step(self, T, dT):
        #dt = 0.033
        R = Vector(self.sun.x-self.x, self.sun.y-self.y)
        #Ur = R.unit()
        r = R.mag()
        Ux, Uy = R.x/r, R.y/r
        ag = GravitySprite.G*self.sun.mass/R.mag()**2
        Agx, Agy = Ux*ag, Uy*ag
        vx, vy = self.vx, self.vy
        At = self.thrust/self.mass
        dt2o2 = dT*dT*0.5
        self.vx = self.vx + (Agx - At*math.sin(self.rotation))* dT
        self.vy = self.vy + (Agy - At*math.cos(self.rotation))* dT
        self.x = self.x + self.vx * dT + Agx*dt2o2
        self.y = self.y + self.vy * dT + Agy*dt2o2


class Bullet(GravitySprite):
    
    asset = ImageAsset(site+"/images/blast.png", Frame(0,0,8,8), 8)
    collisionasset = CircleAsset(4)
    pewasset = SoundAsset(site+"/downloads/pew1.mp3")
    
    def __init__(self, app, sun):
        super().__init__(Bullet.asset, Bullet.collisionasset, (0,0), (0,0), sun)
        self.visible = False
        self.firing = False
        self.time = 0
        self.pew = Sound(Bullet.pewasset)
        self.pew.volume = 10
        
    def shoot(self, position, velocity, time):
        self.position = position
        self.vx = velocity[0]
        self.vy = velocity[1]
        self.time = time
        self.visible = True
        self.firing = True
        self.pew.play()

    def step(self, T, dT):
        self.time = self.time - dT
        if self.visible:
            if self.time <= 0:
                self.visible = False
            else:
                self.nextImage(True)
                super().step(T, dT)
                if self.collidingWith(self.sun):
                    self.visible = False
                    ExplosionSmall(self.position)
                else:
                    ships = self.collidingWithSprites(Ship1)
                    ships.extend(self.collidingWithSprites(Ship2))
                    for ship in ships:
                        if not self.firing and ship.visible:
                            ship.explode()
                            self.visible = False
                    if not ships:
                        self.firing = False


class HealthBar:
    
    def __init__(self, indicatorasset, initvalue, position, app):
        self.sprites = [Sprite(indicatorasset, (0,app.height-75)) for i in range(initvalue)]
        for s in self.sprites:
            s.scale = 0.4
        width = self.sprites[0].width
        if position == 'left':
            x = 50
            step = width+5
        else:
            x = app.width - 50 - width
            step = -width-5
        for s in self.sprites:
            s.x = x
            x = x + step
        self.restart()
        
    def restart(self):
        for s in self.sprites:
            s.visible = True
        self.count = len(self.sprites)
        
    def dead(self):
        return self.count == 0
        
    def killone(self):
        if self.count > 0:
            self.count =  self.count - 1
            self.sprites[self.count].visible = False


class Ship(GravitySprite):

    R = 2.0
    bullets = 6
    healthcount = 6
    reappearasset = SoundAsset(site+"/downloads/reappear.mp3")
    
    def __init__(self, asset, app, position, velocity, sun):
        self.bullets = []
        for i in range(Ship.bullets):
            self.bullets.append(Bullet(app, sun))
        collisionasset = CircleAsset(40) 
        super().__init__(asset, collisionasset, position, velocity, sun)
        self.initposition = position
        self.initvelocity = self.vx, self.vy
        self.initrotation = self.rotation
        self.app = app
        self.mass = 1.0
        self.imagex = 0
        self.reappear = Sound(Ship.reappearasset)
        self.reappear.volume = 40
        self.waitspawn = 0
        self.respawnplayed = False
        healthpos = 'left' if position[0] < app.width/2 else 'right'
        self.health = HealthBar(asset, Ship.healthcount, healthpos, app)
        self.dead = False

    def registerKeys(self, keys):
        commands = ["left", "right", "forward", "fire"]
        self.keymap = dict(zip(keys, commands))
        [self.app.listenKeyEvent("keydown", k, self.controldown) for k in keys]
        [self.app.listenKeyEvent("keyup", k, self.controlup) for k in keys]

    def shootvector(self):
        vel = 150
        xv = vel*(-math.sin(self.rotation))
        yv = vel*(-math.cos(self.rotation))
        return xv + self.vx, yv + self.vy
        

    def controldown(self, event):
        if self.visible:
            command = self.keymap[event.key]
            if command == "left":
                self.rrate = Ship.R
            elif command == "right":
                self.rrate = -Ship.R
            elif command == "forward":
                self.thrust = 40.0
                self.imagex = 1 # start the animated rockets
                self.setImage(self.imagex)
            elif command == "fire":
                for bullet in self.bullets:
                    if bullet.time <= 0:
                        bullet.shoot(self.position, self.shootvector(), 10)
                        break
                        
            
    def controlup(self, event):
        command = self.keymap[event.key]
        if command in ["left", "right"]:
            self.rrate = 0.0
        elif command == "forward":
            self.thrust = 0.0
            self.imagex = 0 # stop the animated rockets
            self.setImage(self.imagex)
            
    def step(self, T, dT):
        if self.waitspawn > 0:
            self.waitspawn = self.waitspawn - dT
            if self.waitspawn < 1 and not self.respawnplayed:
                self.reappear.play()
                self.respawnplayed = True
            if self.waitspawn <= 0:
                self.reset()
        for bullet in self.bullets:
            bullet.step(T, dT)
        if self.visible:
            super().step(T, dT)
            self.rotation = self.rotation + self.rrate * dT
            if self.collidingWith(self.sun):
                self.explode()
            if self.thrust != 0.0:
                self.imagex = self.imagex + 1    # animate the rockets
                if self.imagex == 4:
                    self.imagex = 1
                self.setImage(self.imagex)
            if (self.x < -100 or self.x > self.app.width + 100 or
                self.y < -100 or self.y > self.app.height + 100):
                self.explode()
        

    def explode(self):
        self.visible = False
        ExplosionBig(self.position)
        self.waitspawn = 5

    def reset(self):
        if not self.health.dead():
            self.position = self.initposition
            self.vx, self.vy = self.initvelocity
            self.rotation = self.initrotation
            self.visible = True
            self.respawnplayed = False
            self.health.killone()
            for bullet in self.bullets:
                bullet.time = 0
        else:
            self.dead = True

    def newgame(self):
        self.health.restart()
        self.dead = False
        self.reset()
            
class Ship1(Ship):
    
    asset = ImageAsset(site+"/images/four_spaceship_by_albertov_with_thrust.png", 
        Frame(227,0,292-227,125), 4, 'vertical')
        
    def __init__(self, app, position, velocity, sun):
        super().__init__(Ship1.asset, app, position, velocity, sun)
        self.registerKeys(["a", "d", "w", "space"])
        
    def step(self, T, dT):
        super().step(T, dT)
        if self.visible:
            collides = self.collidingWithSprites(Ship2)
            if len(collides):
                if collides[0].visible:
                    collides[0].explode()
                    self.explode()
        
class Ship2(Ship):
    
    asset = ImageAsset(site+"/images/four_spaceship_by_albertov_with_thrust.png", 
        Frame(0,0,86,125), 4, 'vertical')
        
    def __init__(self, app, position, velocity, sun):
        super().__init__(Ship2.asset, app, position, velocity, sun)
        self.registerKeys(["left arrow", "right arrow", "up arrow", "enter"])

    def step(self, T, dT):
        super().step(T, dT)
        if self.visible:
            collides = self.collidingWithSprites(Ship1)
            if len(collides):
                if collides[0].visible:
                    collides[0].explode()
                    self.explode()

class ExplosionSmall(Sprite):
    
    asset = ImageAsset(site+"/images/explosion1.png", Frame(0,0,128,128), 10)
    boomasset = SoundAsset(site+"/downloads/explosion1.mp3")
    
    def __init__(self, position):
        super().__init__(ExplosionSmall.asset, position)
        self.image = 0
        self.center = (0.5, 0.5)
        self.boom = Sound(ExplosionSmall.boomasset)
        self.boom.play()
        
    def step(self):
        self.setImage(self.image//2)  # slow it down
        self.image = self.image + 1
        if self.image == 20:
            self.destroy()

class ExplosionBig(Sprite):
    
    asset = ImageAsset(site+"/images/explosion2.png", Frame(0,0,4800/25,195), 25)
    boomasset = SoundAsset(site+"/downloads/explosion2.mp3")
    
    def __init__(self, position):
        super().__init__(ExplosionBig.asset, position)
        self.image = 0
        self.center = (0.5, 0.5)
        self.boom = Sound(ExplosionBig.boomasset)
        self.boom.play()
        
    def step(self):
        self.setImage(self.image//2)  # slow it down
        self.image = self.image + 1
        if self.image == 50:
            self.destroy()

class Spacewar(App):
    
    strings = {'winner': 'WINNER!',
        'tie': 'TIE!',
        'space': 'Press SPACE to play.',
        'left': 'AWD\nSpace to FIRE',
        'right': 'Arrow Keys\nEnter to FIRE',
        }

    def __init__(self):
        super().__init__()
        for x in range(self.width//Stars.width + 1):
            for y in range(self.height//Stars.height + 1):
                Stars((x*Stars.width, y*Stars.height))
        self.sun = Sun((self.width/2, self.height/2))
        self.ship1 = Ship1(self, (self.width/2-140,self.height/2), (0,-120), self.sun)
        self.ship2 = Ship2(self, (self.width/2+140,self.height/2), (0,120), self.sun)
        self.tsprites = {k:Sprite(TextAsset(text=v, width=200, align='center',style='20px Arial', fill=Color(0xff2222,1))) 
            for k, v in Spacewar.strings.items()}
        self.tsprites['winner'].visible = False
        self.tsprites['winner'].y = self.height/2
        self.tsprites['tie'].visible = False
        self.tsprites['tie'].position = (self.width/2 - 100, self.height/2 + 50)
        self.tsprites['space'].position = (self.width/2 - 100, self.height*3/4)
        self.tsprites['left'].position = (self.width/4 - 50, self.height/2)
        self.tsprites['right'].position = (self.width*3/4 - 50, self.height/2)
        self.state = 'instructions'
        self.listenKeyEvent('keydown', 'space', self.space)

    def space(self, evt):
        if self.state in ['instructions', 'gameover']:
            for t in self.tsprites.values():
                t.visible = False
            self.state = 'playing'
            self.Tlast = time()
            evt.consumed = True
            self.ship1.newgame()
            self.ship2.newgame()

        
    def step(self):
        explosions = self.getSpritesbyClass(ExplosionSmall)
        for explosion in explosions:
            explosion.step()
        explosions = self.getSpritesbyClass(ExplosionBig)
        for explosion in explosions:
            explosion.step()
        if self.state == 'instructions':
            self.tsprites['space'].visible = True
            self.tsprites['left'].visible = True
            self.tsprites['right'].visible = True
        elif self.state == 'playing':
            T = time()
            dT = T-self.Tlast
            self.Tlast = T
            self.ship1.step(T, dT)
            self.ship2.step(T, dT)
            if self.ship1.dead or self.ship2.dead:
                self.state = 'gameover'
        elif self.state == 'gameover':
            self.tsprites['space'].visible = True
            if self.ship1.dead and self.ship2.dead:
                self.tsprites['tie'].visible = True
            else:
                self.tsprites['winner'].visible = True
                self.tsprites['winner'].x = self.width*3/4-50 if self.ship1.dead else self.width/4-50

app = Spacewar()
app.run()
</script>
</p>
<h3>Flask</h3>
<p>網際程式對於機械設計工程師之所以重要, 是因為機械設計流程與許多不同專業及製造團隊緊密連結, 傳統上無論是採用企業資源管理 (<a href="https://en.wikipedia.org/wiki/Enterprise_resource_planning">ERP</a>), 製造資源管理 (<a href="https://en.wikipedia.org/wiki/Manufacturing_resource_planning">MRP II</a>), 產品資料管理 (<a href="https://en.wikipedia.org/wiki/Product_data_management">PDM</a>) 或產品生命週期管理 (<a href="https://en.wikipedia.org/wiki/Product_life-cycle_management_(marketing)">PLM</a>) 系統, 所有的實體產品零組件, 都源自機械設計部門的電腦輔助設計與工程分析模型. 因此如何透過動態整合 (程式方法) 將設計分析資訊與各不同專業與製造流程部門進行即時互動調控, 將是機械設計工程師所面臨的重要考驗之一.</p>
<p>Server 端 (Flask):</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from flask import Flask, render_template, request, jsonify
 
# Initialize the Flask application
app = Flask(__name__)
 
@app.route('/')
def index():
    return render_template('index.html')
 
@app.route('/add_numbers', methods=['POST'])
def add_numbers():
    a = request.form.get('a', 0, type=int)
    b = request.form.get('b', 0, type=int)
    #return jsonify(result = a+b)
    # 必須傳回字串?
    return str(a+b)
 
if __name__ == '__main__':
    app.run(debug=True)</pre>
<p>Client 端 (Brython):</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"&gt;&lt;/script&gt;
    &lt;link href="//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css" rel="stylesheet"&gt;
    &lt;script src="http://brython.info/src/brython_dist.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body onload="brython()"&gt;
  &lt;script type="text/python"&gt;
    from browser import document
    from browser import ajax
    # https://www.brython.info/static_doc/en/ajax.html
     
    def on_complete(req):
        document["txt_area"] .clear()
        if req.status==200 or req.status==0:
            document["txt_area"] &lt;= req.text
        else:
            document["txt_area"] &lt;= "error "+req.text
             
    def get(url):  
        # req 從 ajax 模組中的 ajax 類別建立案例, 為一個 ajax 物件        
        req = ajax.ajax()
        # a 為 id="A" 輸入欄位中所輸入的值
        a = document['A'].value
        # b 為 id="B" 輸入欄位中所輸入的值        
        b = document['B'].value
        # ajax 物件中的 bind 方法, 第一個輸入變數為 evt, 'complete' 表示 ajax 從伺服器取值完成後, 執行 on_complete 函式
        req.bind('complete', on_complete)
        req.open('POST', url, True)
        req.set_header('content-type','application/x-www-form-urlencoded')
        req.send({"a": a, "b":b}) 
     
    # 使用者按下 id="calculate" 按鈕, 將會執行上述 get("/add_numbers") 函式
    document['calculate'].bind('click',lambda ev:get('/add_numbers'))
 
&lt;/script&gt;
   
    &lt;div class="container"&gt;
      &lt;div class="header"&gt;
        &lt;h3 class="text-muted"&gt;Brython ajax example&lt;/h3&gt;
      &lt;/div&gt;
      &lt;div&gt;
    &lt;input type="text" id="A" size="5" name="a"&gt; +
    &lt;input type="text" id ="B" size="5" name="b"&gt; =
    &lt;div id="txt_area"&gt;&lt;/div&gt;
    &lt;p&gt;&lt;button id="calculate"&gt;calculate server side&lt;/button&gt;
      &lt;/form&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>
<h4>學習資源:</h4>
<p style="padding-left: 30px;"><a href="https://link.springer.com/book/10.1007/978-1-4842-6339-6">Foundation Dynamic Web Pages with Python</a> (校園網路下載電子書)</p>
<p style="padding-left: 30px;"><a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/mdecourse/cmstemplate">https://github.com/mdecourse/cmstemplate</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/mdecourse/scissor-rock-paper">https://github.com/mdecourse/scissor-rock-paper</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/mdecourse/scissor-rock-paper2">https://github.com/mdecourse/scissor-rock-paper2</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/mdecourse/wcms-scrum1">https://github.com/mdecourse/wcms-scrum1</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/chiamingyen/pygrouf">https://github.com/chiamingyen/pygrouf</a></p>
<p></p>
<h3>Flutter</h3>
<p>Flutter 是 2015 年由 Google 提出的手機跨 iOS 與 Android 平台應用程式開發框架, 第一版釋出時間為 2017 年 5 月. Flutter 框架除了可以開發手機程式外, 也可用於單機或網際程式開發.</p>
<p>Windows 64 位元環境中的可攜 Flutter 跨平台 App 開發系統:</p>
<p style="padding-left: 30px;"><a href="https://drive.google.com/file/d/1X8icOyPgABAkKHYaDLXPSoy7U7nyxqzW/view?usp=sharing">下載 Flutter_portable_20210707.7z</a> (下載 4.7 GB, 解開壓縮後約 20GB)</p>
<p>可攜系統中的 Android sdk 容量約 7.5 GB, Flutter 與 Dart 容量約 1.6 GB, Java jdk 容量約 200MB. vscode 約 530 MB, home_mdecourse 目錄下含手機 emulator 檔案容量約 9.3 GB.</p>
<p>利用 Visual Studio Code 開發 Flutter App 之前, 必須啟動 BlueStacks (<a href="https://drive.google.com/file/d/1X8icOyPgABAkKHYaDLXPSoy7U7nyxqzW/view?usp=sharing">Flutter_portable_20210707.7z</a> 中 data/ref 目錄有 BlueStacks 第 4 版安裝檔案, 而最新的版本可以從 <a href="https://www.bluestacks.com">https://www.bluestacks.com</a> 下載), 並且啟用 Android Debug Bridge (ADB) 功能, 之後在 Flutter 可攜系統啟動後, 在命令列視窗中執行 adb connect localhost:5555, 就可以直接利用 BlueStacks 作為虛擬手機介面進行 Flutter App 的執行.</p>
<p>當 Visual Studio Code 執行時, 目前必須要啟用 IPv4 網路協定才可正常建立 App 並安裝於 BlueStacks 手機介面中, 之後必須再看看是否能夠直接在 IPv6 網路協定下正常運作.</p>
<p>以下為 Flutter 可攜系統所需的啟動設定檔內容:</p>
<div>
<div class="syntaxhighlighter js" id="highlighter_290865">
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">REM for flutter
set java_home=%Disk%:\java\jdk8u222-b10
set ANDROID_SDK_home=%Disk%:\home_mdecourse
set GRADLE_USER_home=%Disk%:\home_mdecourse
set ANDROID_SDK_ROOT=%Disk%:\android\sdk
set PUB_CACHE=%Disk%:\home_mdecourse\pub
 
REM set _JAVA_OPTIONS=-Duser.home=%HOME%
set path_flutter=%Disk%:\android\sdk\tools;%Disk%:\android\sdk\tools\bin;%Disk%:\android\sdk\platform-tools;%Disk%:\flutter\bin;%Disk%:\flutter\bin\cache\dart-sdk\bin;
 
set path_vscode=%Disk%:\vscode;</pre>
<h4>參考資料:</h4>
<p style="padding-left: 30px;"><a href="http://mde.tw/cp2019/content/Task2.html">http://mde.tw/cp2019/content/Task2.html</a></p>
<p style="padding-left: 30px;"><a href="http://mde.tw/cp2019/content/Flutter.html">http://mde.tw/cp2019/content/Flutter.html</a></p>
<p style="padding-left: 30px;"><a href="http://mde.tw/cp2019/content/Flutter%20Web.html">http://mde.tw/cp2019/content/Flutter%20Web.html</a></p>
<p style="padding-left: 30px;"><a href="http://mde.tw/cp2019/content/DartLang.html">http://mde.tw/cp2019/content/DartLang.html</a></p>
<p style="padding-left: 30px;"><a href="http://mde.tw/cp2019/content/DartLang.html">http://mde.tw/cp2019/content/DartLang.html</a></p>
</div>
</div>
<h3>Red</h3>
<p>見識過 <a href="http://www.rebol.com/">http://www.rebol.com/</a> 就會令人引頸期盼 Red Language, 非常奇特的程式語言.</p>
<p><a href="https://github.com/red/red/wiki/Coming-to-Red-from-Python">https://github.com/red/red/wiki/Coming-to-Red-from-Python</a></p>
<p><a href="https://github.com/red/red">https://github.com/red/red</a></p>
<h3>Rust</h3>
<h4>Rust 中文入門:</h4>
<p style="padding-left: 30px;"><a href="https://rust-lang.tw/book-tw/title-page.html">https://rust-lang.tw/book-tw/title-page.html</a> (<a href="https://github.com/rust-tw/book-tw">on Github</a>, 利用 <a href="https://github.com/rust-tw/book-tw/blob/zh_tw/.github/workflows/main.yml">Github Actions</a> (<a href="https://github.com/features/actions">何謂 Github Actions</a>?), 以 <a href="https://github.com/rust-lang/mdBook">mdbook</a> 轉為 html)</p>
<p style="padding-left: 30px;">Rust 編譯系統也包含在 <a href="https://mde.tw">KMOLab</a> <a href="http://mde.tw/cmstemplate/content/%E5%8F%AF%E6%94%9C%E7%B3%BB%E7%B5%B1.html">可攜系統</a>中.</p>
<h4>學習利用 Rust 寫一個文字編輯器:</h4>
<p style="padding-left: 30px;"><a href="https://www.philippflenker.com/hecto/">https://www.philippflenker.com/hecto/</a></p>
<p>2021 計算機程式主要透過網際 Brython 讓學員利用 Python 解決相關機械設計過程可能遭遇的問題, 接下來則將透過 Flask 編寫網際程式, 目的除了進行網際內容管理外, 也希望能夠在 Server 部署 CoppeliaSim headless server, 並利用影像串流將機電系統模擬的場景, 傳輸至使用者瀏覽器中, 以便進行後續的虛實整合模擬與控制, 其中 Rust 首先將扮演的角色為: <a href="https://bheisler.github.io/post/calling-rust-in-python/">讓 Python 能夠呼叫 Rust 所編寫的動態程式庫</a>, 或者採用 Rust 與 Python 程式能夠雙向溝通的 <a href="https://pyo3.rs/v0.14.1/">PyO3</a>, 如此 <a href="https://github.com/KmolYuan/metaheuristics-nature-rs">https://github.com/KmolYuan/metaheuristics-nature-rs</a> 中的演化運算程式庫, 便可以讓伺服器端的 Python 程式進行機械設計相關的演化運算.</p>
<p>當然, 目前 <a href="https://mde.tw">KMOLab</a> 主要的網際程式都採用 Python + Flask 建置, 但之後也可以嘗試將部分網際程式轉由 Rust + <a href="https://actix.rs/">Actix Web</a> 建置.</p>
<hr/>
<p>From <a href="https://research.mozilla.org/rust/">https://research.mozilla.org/rust/</a>, Rust is an open-source systems programming language that focuses on speed, memory safety and parallelism. Developers are using Rust to create a wide range of new software applications, such as game engines, operating systems, file systems, browser components and simulation engines for virtual reality.</p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/8EPsnf_ZYU0" title="YouTube video player" width="560"></iframe></p>
<p>在 Windows 操作系統中學習 Rust, 首先需要一個能夠編譯 Rust 程式的<a href="http://mde.tw/cmstemplate/content/%E5%8F%AF%E6%94%9C%E7%B3%BB%E7%B5%B1.html">可攜系統</a>.</p>
<p>有了可攜系統之後再逐步從 <a href="http://stevedonovan.github.io/rust-gentle-intro/">http://stevedonovan.github.io/rust-gentle-intro/</a> 了解 Rust 並非簡單易學, 而是當機械設計工程師在熟悉利用 Python 建立網際服務與最佳化設計運算後, 必須利用數值分析方法提升運算效益時, Rust 會是不錯的選擇之一. 具備學習動機之後, 可以先看一下 <a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>, 之後再導入諸如 <a href="https://github.com/KmolYuan/metaheuristics-nature-rs">https://github.com/KmolYuan/metaheuristics-nature-rs</a> 的程式庫, 配合伺服器中的網際 Python 程式進行設計運算.</p>
<p>User Forum: <a href="https://users.rust-lang.org/">https://users.rust-lang.org/</a></p>
<p>Reddit: <a href="https://www.reddit.com/r/rust/">https://www.reddit.com/r/rust/</a></p>
<h4>Rust and Webassembly:</h4>
<p style="padding-left: 30px;"><a href="https://rustwasm.github.io/docs/book/">https://rustwasm.github.io/docs/book/</a></p>
<p style="padding-left: 30px;"><a href="https://ithelp.ithome.com.tw/articles/10206128">https://ithelp.ithome.com.tw/articles/10206128</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/yewstack/yew">https://github.com/yewstack/yew</a></p>
<p style="padding-left: 60px;"><a href="http://www.sheshbabu.com/posts/rust-wasm-yew-single-page-application/">http://www.sheshbabu.com/posts/rust-wasm-yew-single-page-application/</a></p>
<p style="padding-left: 30px;"><a href="https://erwabook.com/">https://erwabook.com/</a></p>
<h4>GUI for Webassembly:</h4>
<p style="padding-left: 30px;"><a href="https://github.com/emilk/egui">https://github.com/emilk/egui</a></p>
<p style="padding-left: 60px;"><a href="https://reposhub.com/rust/gui/emilk-emigui.html">https://reposhub.com/rust/gui/emilk-emigui.html</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/tauri-apps/tauri">https://github.com/tauri-apps/tauri</a></p>
<h4>Why Python users may need Rust:</h4>
<p style="padding-left: 30px;"><a href="https://gitter.im/rustpython/Lobby">https://gitter.im/rustpython/Lobby</a></p>
<p style="padding-left: 30px;"><a href="https://searchapparchitecture.techtarget.com/news/252496553/Google-Microsoft-back-Python-and-Rust-programming-languages">https://searchapparchitecture.techtarget.com/news/252496553/Google-Microsoft-back-Python-and-Rust-programming-languages</a></p>
<p style="padding-left: 30px;"><a href="https://developers.redhat.com/blog/2017/11/16/speed-python-using-rust#why_does_it_matter_for_a_python_developer_">Speed up your python using Rust</a></p>
<p style="padding-left: 60px;">高階抽象下仍不失其對於低階層面的控制</p>
<p style="padding-left: 60px;">在編譯階段就能揪出平行運算與記憶體管理上的錯誤</p>
<p style="padding-left: 60px;">由於沒有 runtime, 因此可以跟各種 runtime 結合運用, 以 Rust 寫的原生延伸程式, 可以與 node.js, python 或 lua 結合應用. 後續關注 <a href="https://github.com/getsentry/milksnake">milksnake</a> (<a href="https://blog.sentry.io/2017/11/14/evolving-our-rust-with-milksnake">What is milksnake</a>?)與 <a href="https://github.com/PyO3/pyo3">pyo3</a>.</p>
<p style="padding-left: 60px;">從<a href="https://mde.tw/cmstemplate/content/%E5%8F%AF%E6%94%9C%E7%B3%BB%E7%B5%B1.html">可攜系統</a>中下載 Rust, 然後進行實作, 編譯後的 Rust 可以導入 Python 呼叫.</p>
<p style="padding-left: 30px;"><a href="https://blog.yasking.org/a/rust-create-dll-using-by-python-nodejs.html">https://blog.yasking.org/a/rust-create-dll-using-by-python-nodejs.html</a></p>
<p style="padding-left: 30px;"><span style="background-color: #ffff99;">Python interpreter written in Rust</span>: <a href="https://github.com/RustPython/RustPython">https://github.com/RustPython/RustPython</a></p>
<p style="padding-left: 60px;"><a href="https://archive.fosdem.org/2019/schedule/event/rust_python/attachments/slides/2846/export/events/attachments/rust_python/slides/2846/RustPython_fosdem2019.pdf">https://archive.fosdem.org/2019/schedule/event/rust_python/attachments/slides/2846/export/events/attachments/rust_python/slides/2846/RustPython_fosdem2019.pdf</a></p>
<p style="padding-left: 30px;"><a href="https://towardsdatascience.com/learning-rust-by-converting-python-to-rust-259e735591c6">https://towardsdatascience.com/learning-rust-by-converting-python-to-rust-259e735591c6</a></p>
<p style="padding-left: 30px;"><a href="https://www.vortexa.com/insight/integrating-rust-into-python">https://www.vortexa.com/insight/integrating-rust-into-python</a></p>
<p style="padding-left: 30px;"><a href="https://codeburst.io/how-to-use-rust-to-extend-python-360174ee5819">https://codeburst.io/how-to-use-rust-to-extend-python-360174ee5819</a></p>
<p style="padding-left: 30px;"><a href="https://pyoxidizer.readthedocs.io/en/v0.9.0/rust_porting.html">https://pyoxidizer.readthedocs.io/en/v0.9.0/rust_porting.html</a></p>
<p style="padding-left: 30px;"><a href="https://www.infinyon.com/blog/2021/03/python-client/">https://www.infinyon.com/blog/2021/03/python-client/</a></p>
<p style="padding-left: 30px;"><a href="https://www.codingame.com/playgrounds/54888/rust-for-python-developers---operators/introduction">https://www.codingame.com/playgrounds/54888/rust-for-python-developers---operators/introduction</a></p>
<p><a href="https://github.com/rust-lang/book">https://github.com/rust-lang/book</a></p>
<p><a>http://stevedonovan.github.io/rust-gentle-intro/</a></p>
<h4>Web framework:</h4>
<p style="padding-left: 30px;"><a href="https://github.com/actix/actix-web">https://github.com/actix/actix-web</a></p>
<p style="padding-left: 30px;"><a href="https://actix.rs/docs/getting-started/">https://actix.rs/docs/getting-started/</a></p>
<h4>cargo.toml</h4>
<pre class="brush:rust;auto-links:false;toolbar:false" contenteditable="false">[package]
name = "hello-actix"
version = "0.1.0"
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

actix-web = "3"</pre>
<h4>main.rs</h4>
<pre class="brush:rust;auto-links:false;toolbar:false" contenteditable="false">use actix_web::{get, post, web, App, HttpResponse, HttpServer, Responder};

#[get("/")]
async fn hello() -&gt; impl Responder {
    HttpResponse::Ok()
        .content_type("text/html; charset=utf-8")
        .body("速度很快!!")
}

#[post("/echo")]
async fn echo(req_body: String) -&gt; impl Responder {
    HttpResponse::Ok().body(req_body)
}

async fn manual_hello() -&gt; impl Responder {
    HttpResponse::Ok().body("Hey there!")
}


#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    HttpServer::new(|| {
        App::new()
            .service(hello)
            .service(echo)
            .route("/hey", web::get().to(manual_hello))
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}
</pre>
<h4>The Rust Programming Language:</h4>
<p style="padding-left: 30px;"><a href="https://doc.rust-lang.org/stable/book/">https://doc.rust-lang.org/stable/book/</a></p>
<p style="padding-left: 30px;"><a href="https://lise-henry.github.io/books/trpl2.pdf">https://lise-henry.github.io/books/trpl2.pdf</a></p>
<p><a href="https://github.com/PyO3/pyo3">https://github.com/PyO3/pyo3</a> for Rust Version 1.41.1 (2020-02-27) and up.</p>
<h4>其他:</h4>
<p style="padding-left: 30px;"><a href="https://github.com/lalrpop/lalrpop">https://github.com/lalrpop/lalrpop</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/gluon-lang/gluon">https://github.com/gluon-lang/gluon</a></p>
<h4>學習資源:</h4>
<p style="padding-left: 30px;"><a href="https://github.com/KmolYuan/metaheuristics-nature-rs">https://github.com/KmolYuan/metaheuristics-nature-rs</a></p>
<p style="padding-left: 60px;"><a href="https://github.com/KmolYuan/metaheuristics">https://github.com/KmolYuan/metaheuristics</a> (Cython)</p>
<p style="padding-left: 60px;"><a href="https://github.com/kmollee/algorithm">https://github.com/kmollee/algorithm</a> (Python and Cython)</p>
<p style="padding-left: 60px;"><a href="https://link.springer.com/book/10.1007/978-3-540-73190-0">Introduction to Genetic Algorithms</a> (校園網路中下載電子書)</p>
<p style="padding-left: 60px;"><a href="https://link.springer.com/book/10.1007/978-1-4615-5237-6">Multiobjective Scheduling by Genetic Algorithms</a> (校園網路中下載電子書)</p>
<p style="padding-left: 30px;"><a href="https://fasterthanli.me/articles/a-half-hour-to-learn-rust">https://fasterthanli.me/articles/a-half-hour-to-learn-rust</a></p>
<p style="padding-left: 30px;"><a href="https://tourofrust.com/00_zh-tw.html">https://tourofrust.com/00_zh-tw.html</a></p>
<p style="padding-left: 30px;"><a href="https://towardsdatascience.com/you-want-to-learn-rust-but-you-dont-know-where-to-start-fc826402d5ba">https://towardsdatascience.com/you-want-to-learn-rust-but-you-dont-know-where-to-start-fc826402d5ba</a></p>
<p style="padding-left: 30px;"><a href="https://rust-lang-nursery.github.io/rust-cookbook/intro.html">https://rust-lang-nursery.github.io/rust-cookbook/intro.html</a></p>
<p style="padding-left: 30px;"><a href="https://dhghomon.github.io/easy_rust/">https://dhghomon.github.io/easy_rust/</a></p>
<p style="padding-left: 30px;"><a href="https://serokell.io/blog/rust-guide#data-ownership-model">https://serokell.io/blog/rust-guide#data-ownership-model</a></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/zF34dRivLOw" title="YouTube video player" width="560"></iframe></p>
<h3>Haskell</h3>
<p><a href="https://pandoc.org/">https://pandoc.org/</a> 就是採用 Haskell 編寫.</p>
<p><a href="https://serokell.io/blog/10-reasons-to-use-haskell">https://serokell.io/blog/10-reasons-to-use-haskell</a></p>
<p><a href="https://link.springer.com/book/10.1007/978-1-4842-4480-7">Practical Haskell</a> (校園網路中下載電子書)</p>
<p><a href="https://link.springer.com/book/10.1007/978-1-4842-3739-7">Practical Web Development with Haskell</a> (校園中下載電子書)</p>
<p><a href="https://link.springer.com/book/10.1007/978-1-4302-6251-0">Beginning Haskell</a> (校園網路下載電子書)</p>
<p><a href="https://link.springer.com/book/10.1007/978-1-4842-4507-1">Haskell Quick Syntax Reference</a> (校園網路下載電子書)</p>
<h3>PowerShell</h3>
<p><a href="https://github.com/PowerShell/PowerShell">https://github.com/PowerShell/PowerShell</a></p>
<p><a href="https://link.springer.com/book/10.1007/978-1-4842-4504-0">PowerShell and Python Together</a> (從校園網路下載電子書)</p>
<p>在<a href="https://old.reddit.com/r/PowerShell/comments/8gztev/any_way_i_can_speed_this_script_up/">網友的幫忙</a>下, 將部分程式碼改寫, 從原先 9 小時執行時間縮減為 20 分鐘.</p>
<p><a href="https://old.reddit.com/r/PowerShell/comments/jncf3z/how_can_i_speed_up_this_validation_script/">這個案例</a>從 7 小時縮減為 5 分鐘.</p>
<p><a href="https://old.reddit.com/r/PowerShell/comments/9qu7nj/suggestions_to_speed_this_up/">這個案例</a>從 10 分鐘縮減為 30 秒.</p>
<p><a href="https://old.reddit.com/r/PowerShell/comments/8r53r3/help_with_time_optimization_of_script/">這個案例</a>從 9 秒縮減為 0.75 秒.</p>
<p><a href="https://en.wikipedia.org/wiki/Sudoku">sudoku</a>.ps1 (from <a href="https://bpa.st/QCHA">https://bpa.st/QCHA</a> )</p>
<pre class="brush:ps;auto-links:false;toolbar:false" contenteditable="false">$global:board = @(
    @(0,0,0, 0,3,0, 0,0,0),
    @(0,0,1, 0,7,6, 9,4,0),
    @(0,8,0, 9,0,0, 0,0,0),

    @(0,4,0, 0,0,1, 0,0,0),
    @(0,2,8, 0,9,0, 0,0,0),
    @(0,0,0, 0,0,0, 1,6,0),

    @(7,0,0, 8,0,0, 0,0,0),
    @(0,0,0, 0,0,0, 4,0,2),
    @(0,9,0, 0,1,0, 3,0,0)
)

function print_board {
    foreach ($i in 0..8) {
        if ($i % 3 -eq 0 -and $i -ne 0) {
            Write-Host "- - - - - - - - - - -"
        }

        foreach ($j in 0..8) {
            if ($j % 3 -eq 0 -and $j -ne 0) {
                Write-Host "| " -NoNewline
            }

            if ($j -eq 8) {
                Write-Host $global:board[$i][$j]
            }
            else {
                Write-Host ([string]$global:board[$i][$j] + " ") -NoNewline
            }
        }
    }
}

class Sudoku
{
    static [bool] valid([int]$num, [int]$row, [int]$col) {
        # Check row
        foreach ($i in 0..8) {
            if ($global:board[$row][$i] -eq $num -and $col -ne $i) {
                return $False
            }
        }

        # Check column
        foreach ($i in 0..8) {
            if ($global:board[$i][$col] -eq $num -and $row -ne $i) {
                return $False
            }
        } 

        # Check box
        $box_x = [math]::floor($col / 3)
        $box_y = [math]::floor($row / 3)

        foreach ($i in ($box_y*3)..($box_y*3 + 2)) {
            foreach ($j in ($box_x * 3)..($box_x*3 + 2)) {
                if ($global:board[$i][$j] -eq $num -and ($i -ne $col) -and ($j -ne $col)) {
                    return $False
                }
            }
        }

        return $True
    }

    static [System.Tuple[int,int]] find_empty() {
        foreach ($i in 0..8) {
            foreach ($j in 0..8) {
                if ($global:board[$i][$j] -eq 0) {
                    return [Tuple]::Create($i, $j)  # row, col
                }
            }
        }
        return $null
        
    }
}

function solve {
    $find = [Sudoku]::find_empty()
    if (-not $find) {
        return $True
    }
    else {
        $row, $col = $find.Item1, $find.Item2
        #Write-Progress -Activity "Solving..." -CurrentOperation "Row: $($row+1), Col: $($col+1)" -PercentComplete ([math]::round($row*$col/64*100))
        #Write-Host "`rSolving... Row: $($row+1), Col: $($col+1)" -NoNewline
    }

    foreach ($i in 1..9) {
        if ([sudoku]::valid($i, $row, $col)) {
            $global:board[$row][$col] = $i
            #print_board

            if (solve) {
                return $True
            }

            $global:board[$row][$col] = 0
        }
    }

    return $False
}

print_board
$time = Measure-Command {solve}
Write-Host ""
Write-Host "Seconds to Solve: $($time.TotalSeconds)"
Write-Host ""
Write-Host "_____________________"
print_board
</pre>
<p></p>
<h2>RoboDK</h2>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/nv7mOBDA_Z8" title="YouTube video player" width="560"></iframe></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/dkRaf5n3OKs" title="YouTube video player" width="560"></iframe></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/3EqzMzszMV0" title="YouTube video player" width="560"></iframe></p>
<h2>開發範例</h2>
<h4>平面機構分析與合成:</h4>
<p style="padding-left: 30px;"><a href="https://github.com/mdecourse/ps2020">https://github.com/mdecourse/ps2020</a></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/YOnLdzrLivM" title="YouTube video player" width="560"></iframe></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/ZAGrFV1jCdk" title="YouTube video player" width="560"></iframe></p>
<h4>Python GUI with Serial port communication:</h4>
<p style="padding-left: 30px;"><a href="https://github.com/mdecourse/Pyquino">https://github.com/mdecourse/Pyquino</a></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/R26R_07rkIc" title="YouTube video player" width="560"></iframe></p>
<p><a href="https://github.com/mdecourse/virtualkossel">https://github.com/mdecourse/virtualkossel</a></p>
<p style="padding-left: 30px;"><a href="http://mde.tw/virtualkossel/">http://mde.tw/virtualkossel/</a></p>
<p></p>
<h3>網際程式</h3>
<h4>An re-introduction to HTTP cookies:</h4>
<p style="padding-left: 30px;"><a href="https://www.valentinog.com/blog/cookies/">https://www.valentinog.com/blog/cookies/</a></p>
<p>以下程式主要在結合 Flask 與 Fossil SCM 的登入 cookie 設定, 兩台 server 必須屬於同一個 domain name.</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from flask import Flask
from flask import make_response, request, redirect
import requests
# for app.secret_key
import os

app = Flask(__name__)
# 使用 session 必須要設定 secret_key
secret_key = os.urandom(24).hex()
app.secret_key = secret_key

@app.route('/')
def hello_world():
    with requests.Session() as s:
        url = 'https://fossil.kmol.info/u/yen/login'
        post_var = {'u': 'username', 'p': 'password'}
        headers = {'X-Requested-With': 'XMLHttpRequest'}
        result = s.post(url, data = post_var, headers = headers)
        cookie = s.cookies.get_dict()
        key = list(cookie.keys())[0]
        value = cookie[key]
        response = make_response(redirect(url))
        response.set_cookie(key, value)
        return response
        
if __name__ == '__main__':
    app.run()</pre>
<h4>Python and SQLite:</h4>
<p style="padding-left: 30px;"><a href="https://github.com/thombashi/SimpleSQLite">https://github.com/thombashi/SimpleSQLite</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/codewithlennylen/Python-SQLite-Tutorials">https://github.com/codewithlennylen/Python-SQLite-Tutorials</a></p>
<h3>RPA</h3>
<p><a href="https://link.springer.com/book/10.1007/978-1-4842-5729-6">The Robotic Process Automation Handbook</a> (從校園網路下載電子書)</p>
<p style="padding-left: 30px;">the word "robotic" does not refer to a physical robot – instead, it is about a software-based robot (or bot) that can <span style="background-color: #ffff99;">automate human actions</span> in the workplace (generally for white collar applications in clerical and administrative functions). A bot can be delivered via the cloud or through downloadable software.</p>
<p>RPA involves bots that perform a set of specified actions or tasks, such as the following:</p>
<ol>
<li>The cut-and-paste of information from one app  to another</li>
<li>The opening of a web site and login</li>
<li>The opening of an e-mail and attachments</li>
<li>The read/write of a database</li>
<li>The extraction of content from forms or documents</li>
<li>The use of calculations and workflows</li>
</ol>
<p>Such things may sound kind of mundane, boring, and simplistic. But that’s the point. RPA is focused on those <span style="background-color: #ffff99;">tasks that are really a waste of efforts for workers</span>. Shouldn’t they be doing more important activities?</p>
<h4>RPA 相關開源套件:</h4>
<p style="padding-left: 30px;"><a href="https://github.com/pywinauto/pywinauto">https://github.com/pywinauto/pywinauto</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/tebelorg/RPA-Python">https://github.com/tebelorg/RPA-Python</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/FrankBGao/F2R_approach_RPA">https://github.com/FrankBGao/F2R_approach_RPA</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/Aksh97/EasyReq">https://github.com/Aksh97/EasyReq</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/rpabotsworld/awesome-rpa">https://github.com/rpabotsworld/awesome-rpa</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/A9T9/RPA">https://github.com/A9T9/RPA</a></p>
<p style="padding-left: 60px;"><a href="https://ui.vision/rpa">https://ui.vision/rpa</a></p>
<h3>FossilPy</h3>
<p><a href="https://github.com/gumblex/fossilpy">https://github.com/gumblex/fossilpy</a></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import sqlite3
con = sqlite3.connect('kmol.fossil')
cur = con.cursor()

# this is the login user through flask Oauth2 login
username = "yen"

# check if login name existed
# pw field is the password
cur.execute("select pw from user where login='" + username + "';")
password = cur.fetchall()

if len(password) == 0:
    print("account is not created!")
    # we may need to create account for this login user
else:
    # the fetched data is a list with tuple inside
    print(password[0][0])
    # we will need the user account and password to get login cookie
    # we will use the account/password to login through flask connection

con.close()</pre>
<p>當 Flask Oauth2 server 與 Fossil SCM 同在一台主機上共用 domain name 時, 可以利用下列程式, 讓使用者透過 Oauth2 登入 Fossil SCM 倉儲:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from flask import Flask
from flask import make_response, redirect
# for creating session
import requests
# for generating random secret_key
import os

app = Flask(__name__)
secret_key = os.urandom(24).hex()
app.secret_key = secret_key

@app.route('/')
def hello_world():
    with requests.Session() as s:
        url = 'https://fossil.kmol.info/u/yen/login'
        post_var = {'u': 'yen', 'p': 'fossil'}
        headers = {'X-Requested-With': 'XMLHttpRequest'}
        result = s.post(url, data = post_var, headers = headers)
        cookie = s.cookies.get_dict()
        key = list(cookie.keys())[0]
        value = cookie[key]

        response = make_response(redirect(url))
        response.set_cookie(key, value)
        return response
        

if __name__ == '__main__':
    app.run()
    </pre>
<h4>Fossil SCM skin 相關資料:</h4>
<p style="padding-left: 30px;"><a href="https://fossil.include-once.org/fossil-skins/index">https://fossil.include-once.org/fossil-skins/index</a> </p>
<p style="padding-left: 30px;"><a href="https://www.fossil-scm.org/home/doc/trunk/www/customskin.md">https://www.fossil-scm.org/home/doc/trunk/www/customskin.md</a></p>
<p style="padding-left: 30px;"><a href="https://fossil-scm.org/home/doc/0d7ac90d/www/customskin.md">https://fossil-scm.org/home/doc/0d7ac90d/www/customskin.md</a> </p>
<h4>Fossil SCM tools:</h4>
<p style="padding-left: 30px;"><a href="https://kuu.se/fossil/fossmd.cgi/doc/ckout/README.fossmd.md">https://kuu.se/fossil/fossmd.cgi/doc/ckout/README.fossmd.md</a> </p>
<p style="padding-left: 30px;">Self-hosting: <a href="https://dev.to/schollz/self-hosting-with-fossil-an-alternative-to-git-33bk">https://dev.to/schollz/self-hosting-with-fossil-an-alternative-to-git-33bk</a></p>
<p></p><h3>Delta</h3>
<p>Delta format 的應用說明:</p>
<p style="padding-left: 30px;">Suppose we have some text value a, and user has changed it to value b. Using delta function we can get a compressed delta value d that we can store and keep it along with the new text value b. If later user wants to see the previous version of text, we can use deltainv(b, d) to get the previous value a. If we keep all consequtive deltas we can use deltainv multiple times to get any of the earlier text versions.</p>
<p>原始的 <a href="https://fossil-scm.org/home/doc/tip/www/delta_format.wiki">Fossil SCM Delta</a> 以 C 編寫.</p>
<p>以下則以 setuptools 編譯為 Python 動態連結程式庫.</p>
<h4>Python Fossil Delta:</h4>
<p style="padding-left: 30px;"><a href="https://github.com/ggicci/python-fossil-delta">https://github.com/ggicci/python-fossil-delta</a></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import fossil_delta

def main():
    # 使用者在改版過程將 abcdef 改為 abc
    # 當下透過 delta algorithm 對兩者取 delta
    delta = fossil_delta.create_delta(b'abc', b'abcdef')
    # 之後透過 delta 運算給定 delta 與目前的版本, 可以取得先前的版本內容
    out = fossil_delta.apply_delta(b'abc', delta)
    print(out)  # --&gt; abcdef</pre>
<p>以及用 Rust 改寫.</p>
<h4>Rust Fossil Delta:</h4>
<p style="padding-left: 30px;"><a href="https://crates.io/crates/fossil-delta">https://crates.io/crates/fossil-delta</a></p>
<p style="padding-left: 30px;">其中包含 <a href="https://leoeditor.com/">Leo Editor</a> 的應用.</p>
<p>將 <a href="https://github.com/ggicci/python-fossil-delta/blob/master/src/fossil_delta/delta.c">delta.c</a> 透過</p>
<p>setup.py</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from setuptools import setup

setup(
    name='python-fossil-delta',
    version='18.11.27',
    description='Delta compression algorithm from fossil SCM',
    long_description=open('README.md', 'rt').read(),
    url='https://github.com/ggicci/python-fossil-delta',
    author='Ggicci',
    author_email='ggicci@163.com',
    license='MIT',
    keywords='fossil-delta compression algorithm',
    setup_requires=['cffi&gt;=1.11.5'],
    package_dir={'': 'src'},
    packages=['fossil_delta'],
    package_data={
        'fossil_delta': ['*.h', '*.c', 'build/*.py'],
    },
    cffi_modules=[
        'src/fossil_delta/build/fossil_delta_build.py:ffibuilder',
    ],
    install_requires=['cffi&gt;=1.11.5'],
    platforms='any',
)
</pre>
<p>編譯為 dll, 可以為 Python 程式呼叫運用.</p>
<h3>DSL</h3>
<h4>Domain Specific Language:</h4>
<p style="padding-left: 30px;"><a href="https://github.com/lark-parser/lark">https://github.com/lark-parser/lark</a></p>
<p style="padding-left: 30px;"><a href="http://blog.erezsh.com/how-to-write-a-dsl-in-python-with-lark/">http://blog.erezsh.com/how-to-write-a-dsl-in-python-with-lark/</a></p>
<h2>C</h2>
<p>以 <a href="https://www.msys2.org/">MSYS2</a> 編譯 <a href="https://github.com/mdecourse/libgd">https://github.com/mdecourse/libgd</a> Graphics Library 為例:</p>
<p>因為倉儲帶有 CMakeLists.txt, 可以採用 <a href="https://github.com/mdecourse/libgd">CMake</a> 建立編譯用的 Makefile (<a href="/downloads/GNUMakeManual.pdf">GNU Make Manual.pdf</a>).</p>
<h4>編譯 C 實習第一步:</h4>
<p>因為 libgd 倉儲程式碼並無子模組, 因此可以直接以 git clone 取下原始碼檔案.</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">git clone https://github.com/mdecourse/libgd.git

cd libgd

mkdir build

cd build

cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release

mingw32-make</pre>
<p>編譯完成後可以在 build/Bin 目錄建立 libgd.dll</p>
<h4>編譯 C 實習第二步:</h4>
<p>接下來可以利用 <a href="https://www.msys2.org/">MSYS2</a> 編譯 Lua 解譯程式套件 (也是採用 C 程式語言編寫).</p>
<p>從 <a href="https://www.lua.org/ftp/">https://www.lua.org/ftp/</a> 可以下載 Lua 解譯器的原始碼, 為了之後配合 <a href="https://github.com/lua/lua/tree/063d4e4543088e7a21965bda8ee5a0f952a9029e">CoppeliaSim</a> <a href="https://www.coppeliarobotics.com/helpFiles/en/versionInfo.htm#coppeliaSim4.2.0">4.2.0 rev5</a>, 在此採用 Lua 5.3.5 的<a href="https://www.lua.org/ftp/lua-5.3.5.tar.gz">版本</a>.</p>
<p>解開 lua-5.3.5.tar.gz 壓縮檔案後, 在命令列中 cd lua-5.3.5 後, 即可利用 mingw32-make mingw 完成編譯. 在 lua-5.3.5/src 中即可取得 lua53.dll, lua.exe 與 luac.exe.</p>
<h4>編譯 C 實習第三步:</h4>
<p>由於 <a href="https://github.com/cyberbotics/webots/wiki">Webots</a> 編譯過程(<a href="https://github.com/cyberbotics/webots/wiki">說明</a>)需要讓 Lua 可以透過 <a href="https://github.com/ittner/lua-gd">https://github.com/ittner/lua-gd</a> 呼叫上述第一步的 gd 繪圖程式庫, 因此接下仍然利用 <a href="https://www.msys2.org/">MSYS2</a> 編譯採 C 編寫的 lua-gd.</p>
<p>git clone <a href="https://github.com/ittner/lua-gd.git">https://github.com/ittner/lua-gd.git</a> 將原始碼取下放入 c:\tmp 目錄中.</p>
<p>接下來由於要在 Windows 10 以 MSYS2 編譯 lua-gd, 因此 Makefile 必須配合 gd 繪圖程式庫與 Lua 解譯器所在位置修改如下:</p>
<p>而且執行編譯後需要載入 gd.dll 並執行 test_features.lua 測試, 因此需要將所需的 dll 檔案 <a href="/downloads/lua-gd_required_dlls.7z">lua-gd_required_dlls.7z</a>  放入 lua-gd 原始碼目錄中.</p>
<p>編譯時進入 c:\tmp\lua-gd&gt;mingw32-make 即可完成編譯, 取得 gd.dll 與 Lua 解譯器及所需的 dll 檔案結合後, 即可與 SciTE 配合, 以 Lua 程式呼叫 gd 繪圖程式庫執行各種 2D Graphics 應用. 其中最重要的應用就是可以在往後的課程中自行編譯 <a href="https://cyberbotics.com/">Webots</a>, 建立延伸工具與其他軟體或硬體進行整合.</p>
<p>Makefile for lua-gd, 編譯完成結合 Lua 5.3.5 解譯器檔案: <a href="/downloads/lua-5.3.5_with_gd.7z">lua-5.3.5_with_gd.7z</a>.</p>
<h4>編譯 C 實習第四步:</h4>
<p>請將上述所完成 Lua + GD 程式庫檔案配置在可攜系統中, 並利用 Lua 程式執行各種 2D 繪圖.</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false"># Lua-GD version. This one must be set.
VERSION=2.0.33r3

# Command used to run Lua code
LUABIN=Y:/lua-5.3.5/lua.exe

# Path to the utility 'gdlib-config'. This may be changed to compile the
# module with development versions of libgd.
GDLIBCONFIG=gdlib-config

# Optimization for the brave of heart ;)
OMITFP=-fomit-frame-pointer

# ---------------------------------------------------------------------------
# Manual configuration for Windows and systems without sed, pkgconfig, etc.
# Uncomment, change and good luck :)

OUTFILE=gd.dll
CFLAGS=-O3 -Wall $(OMITFP)
CFLAGS+=-IY:/lua-5.3.5/src -IC:/tmp/lua-gd -IC:/tmp/libgd/src
CFLAGS+=-DVERSION=\"$(VERSION)\"
GDFEATURES=-DGD_JPEG -DGD_FONTCONFIG -DGD_FREETYPE -DGD_PNG -DGD_GIF
LFLAGS=-shared -L "Y:/lua-5.3.5" -lgd -llua53 -lm $(OMITFP)
# ---------------------------------------------------------------------------


all: test

$(OUTFILE): gd.lo
	$(CC) -o $(OUTFILE) gd.lo $(LFLAGS)

test: $(OUTFILE)
	$(LUABIN) test_features.lua

gd.lo: luagd.c
	$(CC) -o gd.lo -c $(GDFEATURES) $(CFLAGS) luagd.c

install: $(OUTFILE)
	install -D -s $(OUTFILE) $(DESTDIR)/$(INSTALL_PATH)/$(OUTFILE)


# Rules for making a distribution tarball

TDIR=lua-gd-$(VERSION)
DFILES=COPYING README luagd.c lua-gd.spec Makefile test_features.lua
dist: $(DISTFILES)
	rm -f $(TDIR).tar.gz
	mkdir $(TDIR)
	mkdir -p $(TDIR)/doc $(TDIR)/demos $(TDIR)/debian
	cp $(DFILES) $(TDIR)
	cp demos/* $(TDIR)/demos/
	cp doc/* $(TDIR)/doc/
	cp debian/* $(TDIR)/debian/
	tar czf $(TDIR).tar.gz $(TDIR)
	rm -rf $(TDIR)

clean:
	rm -f $(OUTFILE) gd.lo
	rm -rf $(TDIR) $(TDIR).tar.gz
	rm -f demos/out.png demos/out.gif demos/counter.txt

.PHONY: all test install clean dist
</pre>
<h4>Lua 實習第五步:</h4>
<p style="padding-left: 30px;">結合 <a href="https://github.com/aphenriques/gnuplot">https://github.com/aphenriques/gnuplot</a> 與 <a href="http://www.gnuplot.info/">gnuplot</a></p>
<p style="padding-left: 30px;">下載 <a href="https://drive.google.com/file/d/10WTzjMosketDZZVIlYB7H948lFPrWpYU/view?usp=sharing">gnuplot_lua_tinyc.7z</a></p>
<h4 style="padding-left: 30px;"> 參考資料:</h4>
<p style="padding-left: 60px;"><a href="https://mde.tw/cad2020/content/W7.html">https://mde.tw/cad2020/content/W7.html</a></p>
<p>C 語言教程: <a href="https://wangdoc.com/clang/">https://wangdoc.com/clang/</a></p>
<p></p>
<h3>Cython</h3>
<p>從 <a href="http://mde.tw/cp2021/content/C.html">C 程式語言的頁面</a>, 我們已經知道以純 C 編寫的 2D 繪圖程式庫 <a href="https://github.com/libgd/libgd">https://github.com/libgd/libgd</a> 可以直接利用可攜程式系統中的 <a href="https://www.msys2.org/">MSYS2</a> 進行編譯. 亦即可以編寫類似以下的 C 程式執行 2D 繪圖:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">#include "gd.h"
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
	gdImagePtr im;
	FILE *fp;
	int cor_rad = 60;
	im = gdImageCreateTrueColor(400, 400);
	gdImageFilledRectangle(im, 0, 0, 399, 399, 0x00FFFFFF);

	gdImageFilledArc (im, cor_rad, 399 - cor_rad, cor_rad *2, cor_rad *2, 90, 180, 0x0, gdPie);

	fp = fopen("b.png", "wb");
	if (!fp) {
		fprintf(stderr, "Can't save png image.\n");
		gdImageDestroy(im);
		return 1;
	}
	gdImagePng(im, fp);
	fclose(fp);

	gdImageDestroy(im);
	return 0;
}
</pre>
<p>但是除非再將 <a href="https://github.com/libgd/libgd">libgd</a> 處理成為 <a href="https://github.com/TinyCC/tinycc">Tiny CC </a>的程式庫, 然後在 <a href="https://www.scintilla.org/SciTE.html">SciTE</a> 編輯程式環境中以類解譯的方式執行 ANSI C 程式 (將 <a href="https://github.com/libgd/libgd">libgd</a> 編譯為可以讓 <a href="https://github.com/TinyCC/tinycc">Tiny CC</a> 直接呼叫使用的專案, 也是一個不錯的 C 程式語言練習題目), 否則上列的 C 程式每次執行都必須經過編譯與程式庫連結的流程才可進行繪圖. 所以在 <a href="http://mde.tw/cp2021/content/C.html">C 程式語言的頁面</a>中, 我們利用 Lua 解譯程式語言的特性, 也是利用 <a href="https://www.msys2.org/">MSYS2</a> 編譯, 取得 <a href="https://github.com/ittner/lua-gd">https://github.com/ittner/lua-gd</a> 程式碼編譯後, 可以讓 Lua 程式直接透過這個 Wrapper, 使用 <a href="https://github.com/libgd/libgd">libgd</a> 中的 2D 繪圖功能.</p>
<p>透過相同的流程, 我們也可以利用 Python 解譯程式, 設法建立一個 Wrapper, 使用 <a href="https://github.com/libgd/libgd">libgd</a> 中的 2D 繪圖功能. <a href="https://github.com/NOAA-ORR-ERD/py_gd">https://github.com/NOAA-ORR-ERD/py_gd</a> 就是其中一個較新的程式倉儲, 利用 <a href="https://github.com/NOAA-ORR-ERD/py_gd">Cython</a> 編寫 Wrapper 程式.</p>
<p>利用 <a href="https://cython.org/">Cython</a> 編寫 C/C++ 動態程式庫的簡要說明, 可以參考這裡的<a href="https://stackoverflow.com/questions/16993927/using-cython-to-link-python-to-a-shared-library">問答</a>. 也可以從比較簡單的範例程式碼進行練習: <a href="https://github.com/stavshamir/cython-c-wrapper">https://github.com/stavshamir/cython-c-wrapper</a>.</p>
<p>由於我們預計採用 <a href="https://www.msys2.org/">MSYS2</a> 進行 C 程式碼的編譯, 因此 Python 3.9 中的兩個地方必須進行修改, 才能使用 mingw32-make 處理 Python 建立與安裝模組的流程 (相關細節請參見 <a href="https://docs.python.org/3/library/distutils.html">https://docs.python.org/3/library/distutils.html</a>. 其中之一就是位於 Y:\Python395\Lib\distutils 目錄中的 cygwinccompiler.py 檔案. 必須套用下列函式碼:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def get_msvcr():
    """Include the appropriate MSVC runtime library if Python was built
    with MSVC 7.0 or later.
    """
    msc_pos = sys.version.find('MSC v.')
    if msc_pos != -1:
        msc_ver = sys.version[msc_pos+6:msc_pos+10]
        if msc_ver == '1300':
            # MSVC 7.0
            return ['msvcr70']
        elif msc_ver == '1310':
            # MSVC 7.1
            return ['msvcr71']
        elif msc_ver == '1400':
            # VS2005 / MSVC 8.0
            return ['msvcr80']
        elif msc_ver == '1500':
            # VS2008 / MSVC 9.0
            return ['msvcr90']
        elif msc_ver == '1600':
            # VS2010 / MSVC 10.0
            return ['msvcr100']
        elif msc_ver == '1700':
            # Visual Studio 2012 / Visual C++ 11.0
            return ['msvcr110']
        elif msc_ver == '1800':
            # Visual Studio 2013 / Visual C++ 12.0
            return ['msvcr120']
        elif msc_ver == '1900':
            # Visual Studio 2015 / Visual C++ 14.0
            # "msvcr140.dll no longer exists" http://blogs.msdn.com/b/vcblog/archive/2014/06/03/visual-studio-14-ctp.aspx
            return ['vcruntime140']
        elif 1910 &lt;= int(msc_ver) &lt;= 1916:
            return ['vcruntime140']
        elif 1920 &lt;= int(msc_ver) &lt;= 1928:
            return ['vcruntime140']
        else:
            raise ValueError("Unknown MS Compiler version %s " % msc_ver)</pre>
<p>另一個有關 Python 3.9 可攜程式系統的更動就是在 Y:\Python395\Lib\distutils 目錄中, 新增一個 distutils.cfg 檔案, 內容為:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">[build]
compiler = mingw32</pre>
<p>表示當執行 python setup.py build 時, 編譯器將使用 mingw32 而非 Windows 操作系統中 Python 內定的 Visual Studio C++ (我們其實並不排斥使用 VC++, 只是必須透過虛擬操作系統才可以做成可攜 (直接在外接 SSD 中使用編譯系統), 感覺沒有 <a href="https://www.msys2.org/">MSYS2</a> 方便, 但是我們也因此付出許多代價, 但回報是, 採用 <a href="https://www.msys2.org/">MSYS2</a> 編譯 C/C++ 的過程比較接近 Linux 與 MacOS, 可以讓我們編寫跨操作系統平台的程式開發流程更加順利, 很慶幸 <a href="https://www.cyberbotics.com/">Webots</a> 的開發者也<a href="https://www.cyberbotics.com/doc/guide/compiling-controllers-in-a-terminal">認為如此</a>).</p>
<p></p>
<h2>CPP</h2>
<p><a href="/get_page/DSL/Guide to Scientific Computing in C++">Guide to Scientific Computing in C++</a> (校園網路中下載電子書)</p>
<p><a href="https://drive.google.com/file/d/1m6cmWu9AZhkBj6wFn9IiJlShcpGbz05g/view?usp=sharing">msys64_20210419.7z</a> (下載 3.5GB, 解開壓縮後 12GB)</p>
<p style="padding-left: 30px;">功能: <a href="https://www.msys2.org/">Msys2</a> 安裝</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">pacman -S mingw-w64-x86_64-toolchain
pacman -Sy mingw-w64-x86_64-qt5
pacman -Sy mingw-w64-x86_64-qt5-static
pacman -Sy mingw-w64-x86_64-ffmpeg
pacman -Sy mingw-w64-x86-64-cmake</pre>
<p><a href="https://drive.google.com/file/d/17M7Ro9NO2mmycvwOuK-10yYgs2oxFwEB/view?usp=sharing">msys64_20210419_clean.7z</a> (下載 87MB , 解開壓縮後 374MB)</p>
<p style="padding-left: 30px;">功能: 尚未安裝任何 Package 的 <a href="https://www.msys2.org/">Msys2</a> 系統.</p>
<p></p>
<h1>課程主題</h1>
<p>在進入計算機程式課程主題之前, 必須要了解以下幾個與電腦軟硬體溝通的必備觀念與技術:</p>
<p style="padding-left: 30px;">逐步養成多看英文相關資料的習慣, 不懂的單字與語法要設法儘快弄懂.</p>
<p style="padding-left: 30px;">早日學會 Touch Typing 技巧 - <a href="https://www.typingclub.com/">https://www.typingclub.com/</a></p>
<p style="padding-left: 30px;">花時間學會使用 PowerShell scripting:</p>
<p style="padding-left: 60px;"><a href="https://docs.microsoft.com/zh-tw/powershell/">https://docs.microsoft.com/zh-tw/powershell/</a></p>
<p style="padding-left: 60px;"><a href="https://leanpub.com/powershell101">https://leanpub.com/powershell101</a></p>
<p style="padding-left: 30px;">了解與電腦硬體有關的英文術語:</p>
<p style="padding-left: 60px;"><a href="/get_page/%E8%AA%B2%E7%A8%8B%E4%B8%BB%E9%A1%8C/有關 PowerShell:  https:/docs.microsoft.com/zh-tw/powershell/  https:/leanpub.com/powershell101">Introduction to personal computer.pdf</a></p>
<p style="padding-left: 30px;">學會使用 Windows 10 並密切關注與 Windows 11 的差異:</p>
<p style="padding-left: 60px;"><a href="https://en.wikipedia.org/wiki/Windows_11">https://en.wikipedia.org/wiki/Windows_11</a></p>
<p style="padding-left: 60px;"><a href="https://www.cnet.com/tech/computing/windows-11-vs-windows-10-every-big-difference/">https://www.cnet.com/tech/computing/windows-11-vs-windows-10-every-big-difference/</a></p>
<hr/>
<h4>學習重點:</h4>
<p style="padding-left: 30px;">請登入 @gm 帳號後, 下載 <a href="https://drive.google.com/file/d/1LW-UHAY9Hgvnfk14Cknt3PXFNr6huw9t/view?usp=sharing">cp2021_textbook.pdf</a> 課程教材.</p>
<p style="padding-left: 30px;">學會如何運用 Github? - <a href="https://lab.github.com/">https://lab.github.com/</a></p>
<p style="padding-left: 30px;">學會如何安裝課程所需套件 (假如在自己的筆電或桌機上工作)</p>
<p style="padding-left: 30px;">學會如何製作可攜程式環境 (假如在電腦輔助設計室或其他公用電腦上工作)</p>
<p style="padding-left: 30px;">了解計算機課程如何評分?</p>
<hr/>
<p>建立可攜系統在解決 ____ 問題?</p>
<h4>建立可攜程式系統:</h4>
<p style="padding-left: 30px;">從<a href="http://mde.tw/cmstemplate/content/%E5%8F%AF%E6%94%9C%E7%B3%BB%E7%B5%B1.html">可攜系統</a>中選擇所需組合, 搭建可用於維護個人倉儲與網站內容用之隨身程式系統.</p>
<p style="padding-left: 30px;">維護學習倉儲與網站:</p>
<p style="padding-left: 30px;">Portablekmol_base - 每一個 portablekmol 可攜程式系統都必須包括, 其中內含啟動隨身與關閉隨身系統的批次檔案與對應的 home 目錄.</p>
<p style="padding-left: 30px;"><a href="https://www.scintilla.org/SciTE.html">SciTE</a> - 程式與文件編輯器, 經過設定, 可用來解譯 Python, Lua 與 ANSI C 程式.</p>
<p style="padding-left: 30px;"><a href="https://github.com/ShareX/ShareX/releases">ShareX</a> - Windows 電腦畫面取影像或拍攝操作影片用之開放源工具, 應該要設法用 <a href="https://www.qt.io/qt-for-python">Qt for Python</a> 改寫, 其主要核心程式為開放源的 <a href="https://github.com/FFmpeg/FFmpeg">ffmpeg</a>, <a href="https://github.com/ShareX/ShareX/releases">ShareX</a> 利用 C# 建立其操作流程之 GUI 功能視窗介面.</p>
<p style="padding-left: 30px;"><a href="https://docs.microsoft.com/en-us/sysinternals/downloads/zoomit">Zoomit</a> - 用於拍攝操作影片縮放畫面螢幕之工具.</p>
<p style="padding-left: 30px;"><a href="https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer">Process Explorer</a> - 用於 Windows Process 檢視與控管之工具.</p>
<p style="padding-left: 30px;"><a href="https://www.python.org/">Python</a> - 用於維護個人靜態網頁與動態網頁之程式解譯系統, 也用於進行 GUI 套件與網際程式開發, 或最佳化及數值分析運算.</p>
<p style="padding-left: 60px;">為了啟動最新版的 CMSiMDE 動態網站, Python 需要安裝 pyopenssl 模組: pip install pyopenssl.</p>
<p style="padding-left: 30px;"><a href="https://git-scm.com/downloads">Portablegit</a> - Git 分散式版次管理系統工具.</p>
<p style="padding-left: 30px;"><a href="https://www.putty.org/">Putty</a> - 提供 sftp, ssh 與 key 控管及網路傳檔或遠端登入工具.</p>
<p style="padding-left: 30px;"><a href="https://portableapps.com/apps/internet/filezilla_portable">Filezilla</a> - 提供 GUI 模式之 sftp 網路傳檔工具.</p>
<p style="padding-left: 30px;"><a href="https://sourceforge.net/projects/xming/">Xming</a> - Windows X server.</p>
<p style="padding-left: 30px;"><a href="https://portableapps.com/apps/music_video/obs-studio-portable">Portable OBS</a> - 可攜網路串流平台, 可與 Youtube 直播結合, 將直播內容存於 Youtube 直播影片系統中.</p>
<p style="padding-left: 30px;"><a href="https://robodk.com/index">RoboDK</a> - 工業級機械手臂在線與離線模擬與控制系統, 提供 Python API 程式介面, 可讓使用者直觀學習 Python 程式語法, 進而學習如何操控工業級機械手臂執行自動化操作流程.</p>
<p style="padding-left: 30px;"><a href="https://www.coppeliarobotics.com/">CoppeliaSim</a> - 開放源機電系統模擬與控制整合平台, 提供 Lua 與 Python API 程式控制介面, 可近端或遠端控制模擬中的機電系統.</p>
<p style="padding-left: 30px;"><a href="https://www.msys2.org/">Msys2</a> - 可在 Windows 採用與 Mac 及 Linux 操作系統相同的 C/C++ 程式編譯流程, 主要目的在開發可跨各種操作系統的機械設計相關套件與應用程式.</p>
<p style="padding-left: 30px;"><a href="https://bellard.org/tcc/">TCC</a> - 可與 <a href="https://www.scintilla.org/SciTE.html">SciTE</a> 結合, 用於簡單 ANSI C 程式的類解譯執行.</p>
<p style="padding-left: 30px;"><a href="https://www.lua.org/">Lua</a> - 主要用於 <a href="https://www.coppeliarobotics.com/">CoppeliaSim</a> 機電系統與模擬, 也可用於<a href="http://mde.tw/lab/downloads/lua/index.html">網際程式開發</a>.</p>
<p style="padding-left: 30px;"><a href="https://github.com/Range-Software/range3">Range3</a> - 小型開放源有限元素分析套件.</p>
<p style="padding-left: 30px;"><a href="https://cyberbotics.com/">Webots</a> - 開放源機電系統模擬與控制平台, 其特色是採用 VRML 2.0 延伸格式建立零組件模型, 除具備網際介面外, 也可讓使用者透過程式方法與各種參數式電腦輔助設計系統結合, 直接進行機電系統的零組件轉檔, 無需中間經由人工再次進行機電模擬系統組立.</p>
<p style="padding-left: 30px;"><a href="https://miktex.org/">MikTeX</a> - <a href="https://www.latex-project.org/">LaTeX</a> 文件編譯套件, 可與 <a href="https://github.com/features/actions">Github Actions</a> 結合在近端或雲端編譯使用者所建立的協同 LaTeX 文件.</p>
<p style="padding-left: 30px;"><a href="https://www.rust-lang.org/">Rust</a> - 二十一世紀工程師的 C++ 程式語言.</p>
<p>建立倉儲與網站, 在解決 ____ 問題?</p>
<h4>建立課程學習倉儲與網頁:</h4>
<p style="padding-left: 30px;">本課程所有學員都必須建立 <a href="https://github.com/">github</a> (若 <a href="https://gitlab.com">gitlab</a> 已開放一般用戶使用 <a href="https://docs.gitlab.com/ee/user/project/pages/">gitlab pages</a>, 則需同時建立 <a href="https://gitlab.com">gitlab</a> 帳號) 與 <a href="https://www.heroku.com/">Heroku</a> 帳號, 目的在將課程學習歷程, 記錄在分散式版次管理系統中.</p>
<p style="padding-left: 30px;">除了雲端主機外, 各學員必須學會如何利用 <a href="https://www.virtualbox.org/">Virtualbox</a> 上的 <a href="https://ubuntu.com/">Ubuntu</a> 虛擬主機, 將雲端分散式版次管理系統上的內容, 同步至自行架設的 <a href="https://gogs.io/">GOGS</a> (或 <a href="https://github.com/go-gitea/gitea">Gitea</a>) 與 <a href="https://www.fossil-scm.org">Fossil SCM</a> 分散式版次管理系統.</p>
<p>Fossil SCM 的出現, 在解決 ____ 問題?</p>
<h4>Fossil SCM 手冊巡禮:</h4>
<p style="padding-left: 30px;"><a href="https://www.fossil-scm.org/home/doc/trunk/www/index.wiki">https://www.fossil-scm.org/home/doc/trunk/www/index.wiki</a></p>
<p style="padding-left: 30px;">Git 與 Fossil SCM 倉儲之間的內容同步, Fossil SCM 系統應用.</p>
<p>在網際介面學習簡單的 Python 語法, 在解決 ____ 問題?</p>
<h4>利用網際介面與可攜系統學習 Python 程式語法:</h4>
<ol>
<li>了解如合透過 <a href="https://brython.info/">Brython</a>, 在網頁中編寫並執行 Python 程式.</li>
<li>了解如何建立簡單的<a href="http://mde.tw/cp2021/content/Brython.html">網際計算機</a>.</li>
<li>延伸簡單的<a href="http://mde.tw/cp2021/content/Brython.html">網際計算機</a>, 建立工程用計算機.</li>
<li>了解如何在網際環境, 利用 Python 進行 2D 繪圖.</li>
<li>延伸<a href="https://cadlab.mde.tw/post/wang-ji-ji-jie-she-ji-2d-hui-tu.html">網際 2D 繪圖</a>, 完成正齒輪齒形繪製.</li>
<li>延伸網際正齒輪齒形繪製, 完成齒輪減速機<a href="https://github.com/mdecourse/wcms-scrum1">齒面寬設計</a>運算與囓合圖.</li>
<li>Python 與 <a href="https://robodk.com/index">RoboDK</a></li>
</ol>
<p></p>
<h2>倉儲與網頁</h2>
<p>本課程網頁的倉儲位於:</p>
<p style="padding-left: 30px;"><a href="https://github.com/mdecourse/cp2021.git">https://github.com/mdecourse/cp2021.git</a> - <a href="https://mde.tw/cp2021">Github Pages</a></p>
<p style="padding-left: 30px;"><a href="https://gitlab.com/mdecourse/cp2021.git">https://gitlab.com/mdecourse/cp2021.git</a> - <a href="https://mdecourse.gitlab.io/cp2021/">Gitlab Pages</a></p>
<p style="padding-left: 30px;"><a href="https://bitbucket.org/mdecourse/cp2021.git">https://bitbucket.org/mdecourse/cp2021.git</a> -Bitbucket (<a href="https://support.atlassian.com/bitbucket-cloud/docs/publishing-a-website-on-bitbucket-cloud/">如何</a>建立一般網頁, Pages 則必須<a href="https://marketplace.atlassian.com/apps/1212525/pages-for-bitbucket-server?tab=overview&amp;hosting=datacenter">付費</a>)</p>
<p style="padding-left: 30px;"><a href="https://git.heroku.com/cp2021.git">https://git.heroku.com/cp2021.git</a> (cp2021 ~ cp2025 -- heroku2 At Mde dot TW)</p>
<p>將同一份資料的改版提交同步至 Github, Gitlab, Bitbucket 與 Heroku:</p>
<p>Github 上的代號為 origin, 對應至 https://github.com/mdecourse/cp2021.git</p>
<p>git remote add gitlab https://gitlab.com/mdecourse/cp2021.git</p>
<p>git remote add bitbucket https://mdecourse@bitbucket.org/mdecourse/cp2021.git</p>
<p>heroku login 之後 heroku git:remote -a cp2021 (即 git remote add heroku <a href="https://git.heroku.com/cp2021.git">https://git.heroku.com/cp2021.git</a>)</p>
<p>以上設定與改版資料同步至四種雲端系統後, 若僅一人執行開發, 則相關內容連同近端倉儲, 共計有 5 個備份版本.</p>
<p>若專案牽涉 n 人協同, 則每一個時段都將會有至少 n + 4 個備份版本.</p>
<h4>課程練習:</h4>
<p style="padding-left: 30px;">CMSiMDE 倉儲的靜態網站該如何設定, 才能分別在 Github, Gitlab, Bitbucket 與 Heroku 平台上進行伺服?</p>
<p style="padding-left: 30px;">註: Gitlab 與 Bitbucket pages 並非可免費使用. Github pages 也可能只有針對教育帳號能免費使用.</p>
<p style="padding-left: 30px;">CMSiMDE 倉儲的靜態網站該如何在 Fossil SCM 主機中進行伺服?</p>
<p style="padding-left: 30px;">基礎知識:</p>
<p style="padding-left: 60px;">何謂倉儲 (repository)?</p>
<p style="padding-left: 60px;">何謂靜態網頁 (static web site)? 那麼有動態網頁 (dynamic web site)嗎?</p>
<p style="padding-left: 60px;">何謂(電腦)伺服 (serving)?</p>
<p style="padding-left: 60px;">何謂 Fossil SCM？</p>
<h3>Why Git</h3>
<p>為什麼 <a href="https://ist.mit.edu/github-enterprise">https://ist.mit.edu/github-enterprise</a> 與 <a href="https://support.cc.gatech.edu/support-tools/faq/what-gt-github-enterprise">https://support.cc.gatech.edu/support-tools/faq/what-gt-github-enterprise</a> 都使用 Git 與 Github?</p>
<p><a href="https://asmehackathon2020.github.io/">https://asmehackathon2020.github.io/</a></p>
<p><a href="https://sassafras13.github.io/Gitwiththeflow/">https://sassafras13.github.io/Gitwiththeflow/</a></p>
<p><a href="https://github.com/m2n037/awesome-mecheng">https://github.com/m2n037/awesome-mecheng</a></p>
<p><a href="https://github.com/topics/mechanical-engineering">https://github.com/topics/mechanical-engineering</a></p>
<p><a href="https://www.bosch.com/stories/bringing-open-source-to-mechanical-engineering/">https://www.bosch.com/stories/bringing-open-source-to-mechanical-engineering/</a></p>
<p><a href="https://towardsdatascience.com/transition-from-mechanical-engineer-to-machine-learning-engineer-or-data-scientist-786b9887537">https://towardsdatascience.com/transition-from-mechanical-engineer-to-machine-learning-engineer-or-data-scientist-786b9887537</a></p>
<p><a href="https://git-scm.com/book/zh-tw/v2">Git Book</a> (中文)</p>
<p><a href="https://link.springer.com/book/10.1007/978-1-4842-5313-7">Beginning Git and Github</a> (英文, 可從校園網路下載)</p>
<p>What can Git do?</p>
<p>Remember all those problems we tried to solve at the beginning of this chapter? Well, Git can solve them all. It can even solve problems you didn’t know you had!</p>
<p>First, it works great with tracking changes. You can</p>
<ol>
<li>Go back and forth between versions</li>
<li>Review the differences between those versions</li>
<li>Check the change history of a file (<a href="https://git-scm.com/docs/git-blame">git blame</a>)</li>
<li>Tag a specific version for quick referencing</li>
</ol>
<p>Git is also a great tool for teamwork. You can</p>
<ol>
<li>Exchange "changesets" between repositories</li>
<li>Review the changes made by others</li>
</ol>
<p>One of the main features of Git is its Branching system. A branch is a copy of a project which you can work on without messing with the repository. This concept has been around for some time, but with Git, it is way faster and more efficient. Branching also comes along with Merging, which is the act of copying the changesets done in a branch back to the source.</p>
<p>Generally, you create a branch to create or test a new feature and merge that branch back when you are satisfied with the work.</p>
<p>There is also a simple concept that you might use a lot: Stashing.</p>
<p>Stashing is the act of safely putting away your current edits so that you have clean environment to work on something completely different. You might want to use stashing when you are playing around or testing a feature but need to work on a new feature in priority. So, you stash your changes away and begin to write that feature. After you are done, you can get your changes back and apply them to your current working environment.</p>
<h4>Git 與 Github 使用情境:</h4>
<p style="padding-left: 30px;">在倉儲中將其他倉儲引入作為子模組 - 可以使用特定的子模組版本, 各子模組可以持續改版, 不會影響先前引用舊版本倉儲的運作.</p>
<p style="padding-left: 60px;">git submodule add url_of_remote_repository local_directory_name</p>
<p style="padding-left: 60px;">假如要將設為子模組的子模組內容更新到原設定版本, 使用:</p>
<p style="padding-left: 90px;">git submodule update --init --recursive</p>
<p style="padding-left: 60px;"></p>
<p style="padding-left: 60px;"></p>
<p style="padding-left: 60px;"></p>
<h3>Git Push</h3>
<p>將近端改版資料新增提交等步驟都在近端完成, 但是 git push 則是要將改版資料推向遠端倉儲.</p>
<p>共有三種方式可以取得 git push 的使用授權:</p>
<ol>
<li>以該倉儲對應的帳號密碼進行 push (Github 已經<a href="https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/">不再接受</a>使用者採帳號與密碼 push 改版內容)</li>
<li>以該倉儲對應的 <a href="https://docs.github.com/en/github/authenticating-to-github/keeping-your-account-and-data-secure/creating-a-personal-access-token">Personal Access Token</a> 進行 push</li>
<li>以該倉儲對應帳號的 SSH 私鑰進行 push</li>
</ol>
<p>以帳號密碼進行 push (目前已經不再接受採帳號密碼 push):</p>
<p style="padding-left: 30px;">語法為 url = https://github.com/mdecourse/report.git</p>
<p>利用 <a href="https://docs.github.com/en/github/authenticating-to-github/keeping-your-account-and-data-secure/creating-a-personal-access-token">Github Personal Access Token</a> 進行 push 請參考<a href="https://stackoverflow.com/questions/68191392/password-authentication-is-temporarily-disabled-as-part-of-a-brownout-please-us">這裡</a>的說明.</p>
<p style="padding-left: 30px;">語法為 url = <a href="https://&lt;token&gt;@github.com/mdecourse/report.git">https://&lt;token&gt;@github.com/mdecourse/report.git</a></p>
<p>以 <a href="https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh">Github SSH </a>私鑰進行 push:</p>
<p style="padding-left: 30px;">語法為 utl = <a href="mailto:git@&lt;putty_session&gt;:mdecourse/report.git">git@&lt;putty_session&gt;:mdecourse/report.git</a></p>
<h3>Github</h3>
<p>網際介面操作 - 可以從瀏覽器新建或上傳近端電腦檔案, 可在兩台異地電腦之間傳遞對應檔案, 一台以瀏覽器登入 Github 倉儲上傳檔案, 另外一台則在其近端倉儲工作目錄中以 git pull 取下所上傳的檔案.</p>
<p></p>
<h2>Gist</h2>
<h4>以下讓使用者將 Python 範例程式 (<a href="https://brython.info/static_tutorial/en/index.html">Brython</a>) 存入 <a href="https://docs.github.com/en/github/writing-on-github/editing-and-sharing-content-with-gists/creating-gists">Github Gist</a> 後, 經由程式 pubic Gist URL 連結, 以按鈕放入編輯器中執行:</h4>
<!-- 導入 brython 程式庫 -->
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
<!-- 啟動 Brython -->
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<p><!-- 印出版次與關鍵字程式 --></p>
<p>
<script type="text/python3">
from browser import document as doc
from browser import html
import ace
# 清除畫布
def clear_bd(ev):
    bd = doc["brython_div"]
    bd.clear()
# Brython 3.3.4 內建的 container 名稱為  'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id
Ace = ace.Editor(editor_id="kw_editor", console_id="kw_console", container_id="kw__container", storage_id="kw_py_src" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
url = "https://gist.githubusercontent.com/mdecourse/379f02862e9dfd95dbc5241d4faa2ad4/raw/e3dc77e68bbfb8f00eef2e78d3c8d2323b0f17da/clock.py"
data = open(url).read()
Ace.editor.setValue(data)
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)
# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run'].bind('click', Ace.run)
doc['kw_show_console'].bind('click', Ace.show_console)
doc['kw_clear_console'].bind('click', Ace.clear_console)
doc['clear_bd'].bind('click', clear_bd)
</script>
</p>
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<!-- 存擋表單開始 --><form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src', 'kw_filename');" type="submit" value="Save"/></form><!-- 存擋表單結束 -->
<p></p>
<!-- 執行與清除按鈕開始 -->
<p><button id="kw_run">Run</button> <button id="kw_show_console">Output</button> <button id="kw_clear_console">清除輸出區</button><button id="clear_bd">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<!-- 執行與清除按鈕結束 -->
<p></p>
<!-- 程式編輯檔案 -->
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console"></textarea></div>
<!-- 程式輸入位置 -->
<div id="brython_div"></div>
<div class="col-md-0" height="1" id="graphics-column" width="1"></div>
<!-- 開始建立程式範例以及對應按鈕 -->
<p><button id="snake">Snake</button><button id="clock">Clock</button><button id="two_link_ik">Two link IK</button><button id="bezier">Bezier</button><button id="spur_num">Spur</button></p>
<!-- clock 開始 -->
<script type="text/python3">
# 導入 document 與 beditor
from browser import document
import beditor
# 設定按鈕 id 名稱 name 與 原始碼對應 url
name = "clock"
url = "https://gist.githubusercontent.com/mdecourse/379f02862e9dfd95dbc5241d4faa2ad4/raw/e3dc77e68bbfb8f00eef2e78d3c8d2323b0f17da/clock.py"
# 利用 open 與 read 取回原始碼
src = open(url).read()
# 將原始碼放入 editor
e = beditor.editor(src, "kw_editor", "kw_console", "kw__container", "kw_py_src")
# 設定 id 為 name 的元件按下後會執行 e.prog, 意即將原始碼放入 editor 中
document[name].bind('click', e.prog)
</script>
<!-- clock 結束 -->
<p><!-- snake 開始 -->
<script type="text/python3">
from browser import document as doc
# 導入位於 static 目錄下的 beditor.py 
import beditor
# 利用 beditor.py 中的 editor 類別建立案例, 對應到 snake
snake_url = "https://gist.githubusercontent.com/mdecourse/d306a1f57e53bfd6466eaae20bcb9439/raw/2160a12b9fec9707a120a383ed5d38b9b78a02cf/snake.py"
snake_src = open(snake_url).read()
snake = beditor.editor(snake_src, "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "snake" 的按鈕點按時, 執行 snake 物件中的 prog 方法
doc["snake"].bind('click', snake.prog)
</script>
</p>
<p><!-- snake 結束--></p>
<!-- two link robot ik starts -->
<script type="text/python3">
# based on https://mde.tw/cd2021/content/W14-W15.html
from browser import document as doc
import beditor
url = "https://gist.githubusercontent.com/mdecourse/b58d23e73ff57c9ab1334f2e01cdc6e0/raw/2a0393fff3f621bc0267f2102697e586f99b8282/two_link_ik.py"
src = open(url).read()
two_link_ik = beditor.editor(src, "kw_editor", "kw_console", "kw__container", "kw_py_src")
doc["two_link_ik"].bind('click', two_link_ik.prog)
</script>
<!-- two link robot ik ends -->
<p></p>
<!-- bezier 開始 -->
<script type="text/python3">
import beditor
from browser import document
url = "https://gist.githubusercontent.com/mdecourse/2089a943b8fc260c2ca3ce4d0c886b1f/raw/e70f973d0b58f9db5fc6932960ef633421792f35/bezier24v3.py"
src = open(url).read()
bezier = beditor.editor(src, "kw_editor", "kw_console", "kw__container", "kw_py_src")
document["bezier"].bind("click", bezier.prog)
</script>
<!-- bezier 結束 -->
<p></p>
<!-- canvas spur gear with num setting starts -->
<script type="text/python3">
from browser import document
import beditor
url = "https://gist.githubusercontent.com/mdecourse/626206cf3b2a9a9a69f7ce4bb4a116f0/raw/970e2653a7207828b3814c2c867892903734522a/spur_set_num.py"
src = open(url).read()
spur_num = beditor.editor(src, "kw_editor", "kw_console", "kw__container", "kw_py_src")
document["spur_num"].bind('click', spur_num.prog)
</script>
<!-- canvas spur gear with num setting ends -->
<script src="https://mde.tw/eng/cmsimde/static/Cango-24v03-min.js"></script>
<script src="https://mde.tw/eng/cmsimde/static/gearUtils-09.js"></script>
<h3>Brythonsrc</h3>
<p>用於建立上一頁 Gist 的 html 原始碼:</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;h2&gt;Gist&lt;/h2&gt;
&lt;h4&gt;以下讓使用者將 Python 範例程式存入 &lt;a href="https://docs.github.com/en/github/writing-on-github/editing-and-sharing-content-with-gists/creating-gists"&gt;Github Gist&lt;/a&gt; 後, 經由程式 pubic Gist URL 連結, 以按鈕放入編輯器中執行:&lt;/h4&gt;
&lt;!-- 導入 brython 程式庫 --&gt;
&lt;script src="/static/brython.js"&gt;&lt;/script&gt;
&lt;script src="/static/brython_stdlib.js"&gt;&lt;/script&gt;
&lt;!-- 啟動 Brython --&gt;
&lt;script&gt;// &lt;![CDATA[
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
// ]]&gt;&lt;/script&gt;
&lt;p&gt;&lt;!-- 導入 FileSaver 與 filereader --&gt;&lt;/p&gt;
&lt;p&gt;
&lt;script type="text/javascript" src="/static/ace/FileSaver.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/static/ace/filereader.js"&gt;&lt;/script&gt;
&lt;/p&gt;
&lt;p&gt;&lt;!-- 導入 ace --&gt;&lt;/p&gt;
&lt;p&gt;
&lt;script type="text/javascript" src="/static/ace/ace.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/static/ace/ext-language_tools.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/static/ace/mode-python3.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/static/ace/snippets/python.js"&gt;&lt;/script&gt;
&lt;/p&gt;
&lt;p&gt;&lt;!-- 請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--&gt;&lt;/p&gt;
&lt;p&gt;
&lt;script type="text/javascript"&gt;// &lt;![CDATA[
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
// ]]&gt;&lt;/script&gt;
&lt;/p&gt;
&lt;p&gt;&lt;!-- 印出版次與關鍵字程式 --&gt;&lt;/p&gt;
&lt;p&gt;
&lt;script type="text/python3"&gt;// &lt;![CDATA[
from browser import document as doc
from browser import html
import ace
# 清除畫布
def clear_bd(ev):
    bd = doc["brython_div"]
    bd.clear()
# Brython 3.3.4 內建的 container 名稱為  'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id
Ace = ace.Editor(editor_id="kw_editor", console_id="kw_console", container_id="kw__container", storage_id="kw_py_src" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
url = "https://gist.githubusercontent.com/mdecourse/379f02862e9dfd95dbc5241d4faa2ad4/raw/e3dc77e68bbfb8f00eef2e78d3c8d2323b0f17da/clock.py"
data = open(url).read()
Ace.editor.setValue(data)
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)
# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run'].bind('click', Ace.run)
doc['kw_show_console'].bind('click', Ace.show_console)
doc['kw_clear_console'].bind('click', Ace.clear_console)
doc['clear_bd'].bind('click', clear_bd)
// ]]&gt;&lt;/script&gt;
&lt;/p&gt;
&lt;p&gt;&lt;!-- 用來顯示程式碼的 editor 區域 --&gt;&lt;/p&gt;
&lt;div id="kw_editor" style="width: 600px; height: 300px;"&gt;&lt;/div&gt;
&lt;p&gt;&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;&lt;/p&gt;
&lt;!-- 存擋表單開始 --&gt;&lt;form&gt;&lt;label&gt;Filename: &lt;input id="kw_filename" placeholder="input file name" type="text"&gt;.py&lt;/label&gt; &lt;input onclick="doSave('kw_py_src', 'kw_filename');" type="submit" value="Save"&gt;&lt;/form&gt;&lt;!-- 存擋表單結束 --&gt;
&lt;p&gt;&lt;/p&gt;
&lt;!-- 執行與清除按鈕開始 --&gt;
&lt;p&gt;&lt;button id="kw_run"&gt;Run&lt;/button&gt; &lt;button id="kw_show_console"&gt;Output&lt;/button&gt; &lt;button id="kw_clear_console"&gt;清除輸出區&lt;/button&gt;&lt;button id="clear_bd"&gt;清除繪圖區&lt;/button&gt;&lt;button onclick="window.location.reload()"&gt;Reload&lt;/button&gt;&lt;/p&gt;
&lt;!-- 執行與清除按鈕結束 --&gt;
&lt;p&gt;&lt;/p&gt;
&lt;!-- 程式編輯檔案 --&gt;
&lt;div style="width: 100%; height: 100%;"&gt;&lt;textarea autocomplete="off" id="kw_console"&gt;&lt;/textarea&gt;&lt;/div&gt;
&lt;!-- 程式輸入位置 --&gt;
&lt;div id="brython_div"&gt;&lt;/div&gt;
&lt;div class="col-md-0" height="1" id="graphics-column" width="1"&gt;&lt;/div&gt;
&lt;!-- 開始建立程式範例以及對應按鈕 --&gt;
&lt;p&gt;&lt;button id="snake"&gt;Snake&lt;/button&gt;&lt;button id="clock"&gt;Clock&lt;/button&gt;&lt;button id="two_link_ik"&gt;Two link IK&lt;/button&gt;&lt;/p&gt;
&lt;!-- clock 開始 --&gt;
&lt;script type="text/python3"&gt;// &lt;![CDATA[
# 導入 document 與 beditor
from browser import document
import beditor
# 設定按鈕 id 名稱 name 與 原始碼對應 url
name = "clock"
url = "https://gist.githubusercontent.com/mdecourse/379f02862e9dfd95dbc5241d4faa2ad4/raw/e3dc77e68bbfb8f00eef2e78d3c8d2323b0f17da/clock.py"
# 利用 open 與 read 取回原始碼
src = open(url).read()
# 將原始碼放入 editor
e = beditor.editor(src, "kw_editor", "kw_console", "kw__container", "kw_py_src")
# 設定 id 為 name 的元件按下後會執行 e.prog, 意即將原始碼放入 editor 中
document[name].bind('click', e.prog)
// ]]&gt;&lt;/script&gt;
&lt;!-- clock 結束 --&gt;
&lt;p&gt;&lt;!-- snake 開始 --&gt;
&lt;script type="text/python3"&gt;// &lt;![CDATA[
from browser import document as doc
# 導入位於 static 目錄下的 beditor.py 
import beditor
# 利用 beditor.py 中的 editor 類別建立案例, 對應到 snake
snake_url = "https://gist.githubusercontent.com/mdecourse/d306a1f57e53bfd6466eaae20bcb9439/raw/2160a12b9fec9707a120a383ed5d38b9b78a02cf/snake.py"
snake_src = open(snake_url).read()
snake = beditor.editor(snake_src, "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "snake" 的按鈕點按時, 執行 snake 物件中的 prog 方法
doc["snake"].bind('click', snake.prog)
// ]]&gt;&lt;/script&gt;
&lt;/p&gt;
&lt;p&gt;&lt;!-- snake 結束--&gt;&lt;/p&gt;
&lt;!-- two link robot ik starts --&gt;
&lt;script type="text/python3"&gt;// &lt;![CDATA[
# based on https://mde.tw/cd2021/content/W14-W15.html
from browser import document as doc
import beditor
url = "https://gist.githubusercontent.com/mdecourse/b58d23e73ff57c9ab1334f2e01cdc6e0/raw/2a0393fff3f621bc0267f2102697e586f99b8282/two_link_ik.py"
src = open(url).read()
two_link_ik = beditor.editor(src, "kw_editor", "kw_console", "kw__container", "kw_py_src")
doc["two_link_ik"].bind('click', two_link_ik.prog)
// ]]&gt;&lt;/script&gt;
&lt;!-- two link robot ik ends --&gt;</pre>
<p></p>
<h2>解題練習</h2>
<p>這個頁面已經將 ggame 從 brython 模組轉為 javascript (<a href="/downloads/JavaScript Course Notes.pdf">note</a>) 模組(<a href="http://mde.tw/cp2021/content/%E5%AD%B8%E7%BF%92%E7%A8%8B%E5%BC%8F.html">方法</a>), 名稱為 brython_modules.js 放在 downloads 目錄中.</p>
<h4>請利用下列網際編輯器, 開始學習如何使用 Python 解決問題, 一般機械設計流程會面臨什麼問題?</h4>
<p><a href="https://link.springer.com/book/10.1007/978-3-030-20290-3">A Beginners Guide to Python 3 Programming</a> (校園網路下載電子書)</p>
<p><a href="https://link.springer.com/book/10.1007/978-3-030-25943-3">Advanced Guide to Python 3 Programming</a> (校園網路下載電子書)</p>
<p><a href="https://link.springer.com/book/10.1007/978-1-4842-5793-7">Advanced Python Development</a> (校園網路下載電子書)</p>
<p><a href="https://link.springer.com/book/10.1007/978-3-319-19596-4">Elementary Mechanics Using Python</a> (校園網路下載電子書)</p>
<p>1) 從 URL 導入程式<a href="https://docs.python.org/3/tutorial/modules.html">模組</a> (modules). (使用 /static/, ./../downloads/py/). 請列出<a href="https://docs.python.org/3/tutorial/modules.html">模組</a>中的 fib(1000). (瀏覽器上的程式, 可以導入其他網際路徑上 (或其他程式設計者伺服器上) 的另一個程式段, 並且使用該程式段的功能, 對於機械設計流程, 有何用處?)</p>
<p>2) <a href="https://qry.nfu.edu.tw/">學校教務主機</a>可以根據當學期的課號, 查得該課程的修課學員名單, 請問可以直接利用下列網際 Python 程式編輯器, 取得本課程的修課人員學號資料嗎? 當取得修課人員名單後, 可以從中以亂數選出特定個數的學員嗎? 若每一週各選出特定學員, 當週已經被選過的學員, 可以從後續亂數選擇的名單中剔除嗎? (請參考 <a href="https://en.wikipedia.org/wiki/Ajax_(programming)">Ajax</a> 與 <a href="https://brython.info/static_doc/en/ajax.html">browser.ajax</a>, 利用瀏覽器中的程式, 可以跨網路即時從其他伺服器擷取資料, 對機械設計者有什麼意義?)</p>
<p>3) 定時執行特定任務對某些機械裝置可能有些用處, 能夠讓 <a href="https://github.com/mdecourse/schedule">Schedule 模組</a> (<a href="https://bhupesh-v.github.io/A-Simple-Scheduler-in-Python/">ref</a>), 在 Brython 環境中執行嗎?</p>
<p>4) 可以移動的機電模型經常需要客製化的齒輪減速裝置, 能夠直接在瀏覽器中根據減速需求, 設計繪製出能夠直接列印的齒輪組嗎? (<a href="/downloads/DesignBasicGearBoxes.pdf">ref1</a>, <a href="https://all3dp.com/2/3d-printed-gearbox-how-to-design-your-own-box/">ref2</a>, <a href="https://en.wikipedia.org/wiki/STL_(file_format)">ref3</a>, <a href="http://hessmer.org/gears/InvoluteSpurGearBuilder.html?circularPitch=8&amp;pressureAngle=20&amp;clearance=0.05&amp;backlash=0.05&amp;profileShift=0&amp;gear1ToothCount=30&amp;gear1CenterHoleDiamater=4&amp;gear2ToothCount=8&amp;gear2CenterHoleDiamater=4&amp;showOption=3">ref4</a>, <a href="http://www.hessmer.org/blog/2020/09/27/online-involute-spur-gear-builder-v2/">ref5</a>, <a href="https://geargenerator.com/#200,200,100,6,1,3,0,4,1,8,2,4,27,-90,0,0,0,0,0,0,16,4,4,27,-60,0,0,0,0,1,1,12,1,12,20,-60,0,0,0,0,2,0,60,5,12,20,0,1,0,0,0,0,0,3,-515">ref6</a>, <a href="https://www.igus.eu/info/3d-print-gears">ref7</a>)</p>
<p>啟動 Brython 時, 可以同時設定多個模組擷取路徑:</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;script&gt;/
window.onload=function(){
brython({debug:1, pythonpath:['/static/','/./../downloads/py/']});
}
&lt;/script&gt;</pre>
<p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
</p>
<!-- for ggame -->
<p>
<script src="/static/jquery-3.3.1.min.js"></script>
<script src="/static/jquery-ui.1.12.1.min.js"></script>
<script src="/static/pixi-3.0.5.min.js"></script>
<script src="/static/buzz-1.2.1.js"></script>
<script src="/static/bs.js"></script>
<script src="/downloads/brython_modules.js"></script>
</p>
<!-- Cango 程式庫 -->
<p>
<script src="/static/Cango-24v03-min.js"></script>
<script src="/static/CangoAxes-6v01-min.js"></script>
<script src="/static/gearUtils-09.js"></script>
<script src="/static/SVGpathUtils-6v03-min.js"></script>
</p>
<!-- for Konva 程式庫 -->
<p>
<script src="/static/konva.min.js"></script>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
</p>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<p><!-- 印出版次與關鍵字程式 --></p>
<p>
<script type="text/python3">
from browser import document as doc
from browser import html
import ace
# 清除畫布
def clear_bd(ev):
    bd = doc["brython_div"]
    bd.clear()
# Brython 3.3.4 內建的 container 名稱為  'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id
Ace = ace.Editor(editor_id="kw_editor", console_id="kw_console", container_id="kw__container", storage_id="kw_py_src" )
Ace.editor.setValue("""# 導入 sys 模組
import sys
# 導入 keyword 模組
import keyword
def helloWorld():
    print("Hello World!")
helloWorld()
# 利用 sys 模組中的 version_info 印出 Python 版次
print("Python version: ", sys.version_info)
# 利用 keyword 模組中的 kwlist 印出關鍵字
print("Python keywords: ", keyword.kwlist)
""")
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)
# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run'].bind('click', Ace.run)
doc['kw_show_console'].bind('click', Ace.show_console)
doc['kw_clear_console'].bind('click', Ace.clear_console)
doc['clear_bd'].bind('click', clear_bd)
</script>
</p>
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src', 'kw_filename');" type="submit" value="Save"/></form>
<p><button id="kw_run">Run</button> <button id="kw_show_console">Output</button> <button id="kw_clear_console">清除輸出區</button><button id="clear_bd">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console"></textarea></div>
<div id="brython_div"></div>
<div class="col-md-0" height="1" id="graphics-column" width="1"></div>
<p><!-- ****************************** keyword start -->
<script type="text/python3">
from browser import document as doc
# 導入位於 static 目錄下的 beditor.py 
import beditor
# 利用 beditor.py 中的 editor 類別建立案例, 對應到 kw1
kw1 = beditor.editor("""# 導入 sys 模組
import sys
# 導入 keyword 模組
import keyword
# 利用 sys 模組中的 version_info 印出 Python 版次
print("Python version: ", sys.version_info)
# 利用 keyword 模組中的 kwlist 印出關鍵字
print("Python keywords: ", keyword.kwlist)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "keyword" 的按鈕點按時, 執行 kw1 物件中的 prog 方法
doc["keyword"].bind('click', kw1.prog)
</script>
</p>
<p><!-- ****************************** keyword end --></p>
<p><!-- ***************************** slide ex1 start --></p>
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Ex1 = beditor.editor("""# 導入 Ex1 原始碼
a = 0
def my_print(n, input_str):
    print("以下將重覆列印 '", input_str + "' " + str(n) + "次")
    for i in range(n):
        print(i, input_str)
my_print(5, "Hello World!")
the_str = "開始學習 Python"
num = input("請輸入要列印的次數!")
my_print(int(num), the_str)
a = a + 1
print("(" + str(a) + ")", "_" * 25)
def myfun():
    yield 1
    yield 2
    yield 3
for i in myfun():
    print(i)
x = iter(myfun())
y = list(myfun())
a = a + 1
print("(" + str(a) + ")", "_" * 25)
print(x.__next__())
print(x.__next__())
print(x.__next__())
print(y)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "ex1" 的按鈕點按時, 執行 Ex1 物件中的 prog 方法
doc["ex1"].bind('click', Ex1.prog)
</script>
</p>
<p><!-- ***************************** slide ex1 end --></p>
<p><!-- ***************************** slide ex2 start --></p>
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Ex2 = beditor.editor("""# Python 的內建資料型別
import math
def f():
    print("This is a user-defined function")
    return 42
print("Some basic types in Python:")
print(type(2))           # int
print(type(2.2))         # float
print(type("2.2"))       # str  (string)
print(type(2 < 2.2))     # bool (boolean)
print(type(math))        # module
print(type(math.tan))    # builtin_function_or_method ("function" in Brython)
print(type(f))           # function (user-defined function)
print(type(type(42)))    # type
print("#####################################################")
print("And some other types we will see later in the course...")
print(type(Exception())) # Exception
print(type(range(5)))    # range
print(type([1,2,3]))     # list
print(type((1,2,3)))     # tuple
print(type({1,2}))       # set
print(type({1:42}))      # dict (dictionary or map)
print(type(2+3j))        # complex  (complex number) (we may not see this type)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "ex2" 的按鈕點按時, 執行 Ex2 物件中的 prog 方法
doc["ex2"].bind('click', Ex2.prog)
</script>
</p>
<p><!-- ***************************** slide ex2 end --></p>
<p><!-- ***************************** slide ex3 start --></p>
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Ex3 = beditor.editor("""# Python 的內建常數與函式
# 內建常數
print("Some builtin constants:")
print(True)
print(False)
print(None)
print("And some more constants in the math module:")
import math
print(math.pi)
print(math.e)
# 內建函式
print("Type conversion functions:")
print(bool(0))   # convert to boolean (True or False)
print(float(42)) # convert to a floating point number
print(int(2.8))  # convert to an integer (int)
print("And some basic math functions:")
print(abs(-5))   # absolute value
print(max(2,3))  # return the max value
print(min(2,3))  # return the min value
print(pow(2,3))  # raise to the given power (pow(x,y) == x**y)
print(round(2.354, 1)) # round with the given number of digits
# other examples
print(3 * 2)
print(3 * "abc")
print(3 + 2)
print("abc" + "def")
print(3 + "def")
# Type Affect Semantics
print(3 * 2)
print(3 * "abc")
print(3 + 2)
print("abc" + "def")
print(3 + "def")
# Integer Division
print("The / operator does 'normal' float division:")
print(" 5/3  =", ( 5/3))
print()
print("The // operator does integer division:")
print(" 5//3 =", ( 5//3))
print(" 2//3 =", ( 2//3))
print("-1//3 =", (-1//3))
print("-4//3 =", (-4//3))
# Modulus or Remainder Operator (%)
print(" 6%3 =", ( 6%3))
print(" 5%3 =", ( 5%3))
print(" 2%3 =", ( 2%3))
print(" 0%3 =", ( 0%3))
print("-4%3 =", (-4%3))
print(" 3%0 =", ( 3%0))
# Verify that (a%b) is equivalent to (a-(a//b)*b)
def mod(a, b):
  return a - (a//b)*b
print(41%14, mod(41,14))
print(14%41, mod(14,41))
print(-32%9, mod(-32,9))
print(32%-9, mod(32,-9))
# Operator Order (Precedence and Associativity)
print("Precedence:")
print(2+3*4)  # prints 14, not 20
print(5+4%3)  # prints  6, not 0 (% has same precedence as *, /, and //)
print(2**3*4) # prints 32, not 4096 (** has higher precedence than *, /, //, and %)
print()
print("Associativity:")
print(5-4-3)   # prints -2, not 4 (- associates left-to-right)
print(4**3**2) # prints 262144, not 4096 (** associates right-to-left)
# Approximate Values of Floating-Point Numbers
print(0.1 + 0.1 == 0.2)        # True, but...
print(0.1 + 0.1 + 0.1 == 0.3)  # False!
print(0.1 + 0.1 + 0.1)         # prints 0.30000000000000004 (uh oh)
print((0.1 + 0.1 + 0.1) - 0.3) # prints 5.55111512313e-17 (tiny, but non-zero!)
# Equality Testing with math.isclose
print("The problem....")
d1 = 0.1 + 0.1 + 0.1
d2 = 0.3
print(d1 == d2)                # False (never use == with floats!)
print()
print("The solution...")
import math
print(math.isclose(d1, d2))  # True!
# math.isclose checks if the two numbers are ALMOST equal, within a small error
# Short-Circuit Evaluation
def yes():
    return True
def no():
    return False
def crash():
    return 1/0 # crashes!
print(no() and crash()) # Works!
print(crash() and no()) # Crashes!
print (yes() and crash()) # Never runs (due to crash), but would also crash (without short-circuiting)
# Or operator
def yes():
    return True
def no():
    return False
def crash():
    return 1/0 # crashes!
print(yes() or crash()) # Works!
print(crash() or yes()) # Crashes!
print(no() or crash())  # Never runs (due to crash), but would also crash (without short-circuiting)
# more examples
def isPositive(n):
    result = (n > 0)
    print("isPositive(",n,") =", result)
    return result
def isEven(n):
    result = (n % 2 == 0)
    print("isEven(",n,") =", result)
    return result
print("Test 1: isEven(-4) and isPositive(-4))")
print(isEven(-4) and isPositive(-4)) # Calls both functions
print("----------")
print("Test 2: isEven(-3) and isPositive(-3)")
print(isEven(-3) and isPositive(-3)) # Calls only one function!
# type vs isinstance
# Both type and isinstance can be used to type-check
# In general, (isinstance(x, T)) will be more robust than (type(x) == T)
print(type("abc") == str)
print(isinstance("abc", str))
# We'll see better reasons for this when we cover OOP + inheritance later
# in the course.  For now, here is one reason:  say you wanted to check
# if a value is any kind of number (int, float, complex, etc). 
# You could do:
def isNumber(x):
    return ((type(x) == int) or
            (type(x) == float)) # are we sure this is ALL kinds of numbers?
print(isNumber(1), isNumber(1.1), isNumber(1+2j), isNumber("wow"))
# But this is cleaner, and works for all kinds of numbers, including
# complex numbers for example:
import numbers
def isNumber(x):
    return isinstance(x, numbers.Number) # works for any kind of number
print(isNumber(1), isNumber(1.1), isNumber(1+2j), isNumber("wow"))
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "ex3" 的按鈕點按時, 執行 Ex3 物件中的 prog 方法
doc["ex3"].bind('click', Ex3.prog)
</script>
</p>
<p><!-- ***************************** slide ex3 end --></p>
<p><!-- ***************************** slide ex4 start --></p>
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Ex4 = beditor.editor("""# Python 函式
# Vocabulary
x = 5
def f(y, z):
    result = x + y + z
    return result
print(f(1, 2)) # 8
print(f(3, 4)) # 12
# Vocabulary:
#   variables: global vs. local
#   statements vs. expressions
#   function definitions vs. function calls
#   parameters vs. arguments
# Return Statements
# Basic example
def isPositive(x):
    return (x > 0)
print(isPositive(5))  # True
print(isPositive(-5)) # False
print(isPositive(0))  # False
# Return ends the function immediately
def isPositive(x):
    print("Hello!")   # runs
    return (x > 0)
    print("Goodbye!") # does not run ("dead code")
print(isPositive(5))  # prints Hello, then True
# No return statement --> return None
def f(x):
    x + 42
print(f(5)) # None
def f2(x):
    result = x + 42
print(f2(5)) # None
# Print versus Return
# This is a common early mistake (confusing print and return):
def cubed(x):
    print(x**3) # Here is the error!
cubed(2)          # seems to work!
print(cubed(3))   # sort of works (but prints None, which is weird)
print(2*cubed(4)) # Error!
# Once again (correctly)
def cubed2(x):
    return (x**3) # That's better!
cubed2(2)          # seems to be ignored (why?)
print(cubed2(3))   # works!
print(2*cubed2(4)) # works!
# Different Parameter and Return Types
def hypotenuse(a, b):
    return ((a**2) + (b**2))**0.5
print(hypotenuse(3, 4)) # 5.0 (not 5)
print("---------------------")
def xor(b1, b2):
    return ((b1 and (not b2)) or (b2 and (not b1)))  # same as (b1 != b2)
print(xor(True,  True))  # False
print(xor(True,  False)) # True
print(xor(False, True))  # True
print(xor(False, False)) # False
print("---------------------")
def isPositive(n):
    return (n > 0)
print(isPositive(10))     # True
print(isPositive(-1.234)) # False
# Function Composition
def f(w):
    return 10*w
def g(x, y):
    return f(3*x) + y
def h(z):
    return f(g(z, f(z+1)))
print(h(1)) # hint: try the "visualize" feature
# Helper Functions 
def onesDigit(n):
    return n%10
def largerOnesDigit(x, y):
    return max(onesDigit(x), onesDigit(y))
print(largerOnesDigit(134, 672)) # 4
print(largerOnesDigit(132, 674)) # Still 4
# Test Functions
# A broken test function
def onesDigit(n):
    return n%10
def testOnesDigit():
    print("Testing onesDigit()...", end="")
    assert(onesDigit(5) == 5)
    assert(onesDigit(123) == 3)
    assert(onesDigit(100) == 0)
    assert(onesDigit(999) == 9)
    print("Passed!")
testOnesDigit() # Passed!  Why is this bad?
# A better version
def onesDigit2(n):
    return n%10
def testOnesDigit2():
    print("Testing onesDigit()...", end="")
    assert(onesDigit2(5) == 5)
    assert(onesDigit2(123) == 3)
    assert(onesDigit2(100) == 0)
    assert(onesDigit2(999) == 9)
    assert(onesDigit2(-123) == 3) # Added this test
    print("Passed!")
testOnesDigit2() # Crashed!  So the test function worked!
# Local Variable Scope
def f(x):
    print("In f, x =", x)
    x += 5
    return x
def g(x):
    return f(x*2) + f(x*3)
print(g(2))
# Another example
def f(x):
    print("In f, x =", x)
    x += 7
    return round(x / 3)
def g(x):
    x *= 10
    return 2 * f(x)
def h(x):
    x += 3
    return f(x+4) + g(x)
print(h(f(1)))
# Global Variable Scope
# In general, you should avoid using global variables.
# You will even lose style points if you use them!
# Still, you need to understand how they work, since others
# will use them, and there may also be some very few occasions
# where you should use them, too!
g = 100
def f(x):
    return x + g
print(f(5)) # 105
print(f(6)) # 106
print(g)    # 100
# Another exampl
g = 100
def f(x):
    # If we modify a global variable, we must declare it as global.
    # Otherwise, Python will assume it is a local variable.
    global g
    g += 1
    return x + g
print(f(5)) # 106
print(f(6)) # 108
print(g)    # 102
# Default arguments
# Sometimes, a function has a parameter that has a natural default
# We can specify that default value in the function definition,
# then choose whether or not to include it in the function call.
def f(x, y=10):
    return x + y
print(f(5))   # 15
print(f(5,1)) # 6
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "ex4" 的按鈕點按時, 執行 Ex4 物件中的 prog 方法
doc["ex4"].bind('click', Ex4.prog)
</script>
</p>
<p><!-- ***************************** slide ex4 end --></p>
<!-- line drawing start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Draw = beditor.editor("""# Line drawing
# 導入 doc
from browser import document as doc
from browser import html
import math
canvas = html.CANVAS(width = 300, height = 200)
canvas.id = "line_drawing"
brython_div = doc["brython_div"]
brython_div <= canvas
# 準備繪圖畫布
canvas = doc["line_drawing"]
ctx = canvas.getContext("2d")
# 進行座標轉換, x 軸不變, y 軸反向且移動 canvas.height 單位光點
# ctx.setTransform(1, 0, 0, -1, 0, canvas.height)
# 以下採用 canvas 原始座標繪圖
# 設定填圖顏色
ctx.fillStyle = "rgb(200,0,0)"
# 設定畫筆顏色
ctx.strokeStyle = "rgb(0,0,200)"
# 乘上 deg 可轉為徑度單位
deg = math.pi / 180
# 建立多邊形定點位置畫線函式
def star(radius, xc, yc, n):
    #radius = 100
    #xc = 200
    #yc = 200
    xi = xc + radius*math.cos((360/n)*deg+90*deg)
    yi = yc - radius*math.sin((360/n)*deg+90*deg)
    ctx.beginPath()
    ctx.moveTo(xi,yi)
    for i in range(2, n+1):
        x = xc + radius*math.cos((360/n)*deg*i+90*deg)
        y = yc - radius*math.sin((360/n)*deg*i+90*deg)
        ctx.lineTo(x,y)
# 以下利用多邊形畫線函式呼叫執行畫框線或填入顏色
# 畫五邊形框線
star(50, 50, 50, 5)
ctx.closePath()
ctx.stroke()
    
# 填三角形色塊
star(50, 150, 50, 3)
ctx.closePath()
ctx.fill()
    
# 改變畫線顏色後, 畫七邊形框線
ctx.strokeStyle = "rgb(0,200,20)"
star(50, 250, 50, 7)
ctx.closePath()
ctx.stroke()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "draw" 的按鈕點按時, 執行 Draw 物件中的 prog 方法
doc["draw"].bind('click', Draw.prog)
</script>
</p>
<!-- line drawing ends -->
<p></p>
<!-- flag ex start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Flag = beditor.editor("""# 畫中華民國國旗
# 導入 doc
from browser import document as doc
from browser import html
import math
canvas = html.CANVAS(width = 300, height = 200)
canvas.style = {"width": "100%"}
canvas.id = "taiwan_flag"
brython_div = doc["brython_div"]
brython_div <= canvas
# 準備繪圖畫布
canvas = doc["taiwan_flag"]
ctx = canvas.getContext("2d")
# 進行座標轉換, x 軸不變, y 軸反向且移動 canvas.height 單位光點
# ctx.setTransform(1, 0, 0, -1, 0, canvas.height)
# 以下採用 canvas 原始座標繪圖
flag_w = canvas.width
flag_h = canvas.height
circle_x = flag_w/4
circle_y = flag_h/4
# 先畫滿地紅
ctx.fillStyle='rgb(255, 0, 0)'
ctx.fillRect(0,0,flag_w,flag_h)
# 再畫青天
ctx.fillStyle='rgb(0, 0, 150)'
ctx.fillRect(0,0,flag_w/2,flag_h/2)
# 畫十二道光芒白日
ctx.beginPath()
star_radius = flag_w/8
angle = 0
for i in range(24):
    angle += 5*math.pi*2/12
    toX = circle_x + math.cos(angle)*star_radius
    toY = circle_y + math.sin(angle)*star_radius
    # 只有 i 為 0 時移動到 toX, toY, 其餘都進行 lineTo
    if (i):
        ctx.lineTo(toX, toY)
    else:
        ctx.moveTo(toX, toY)
ctx.closePath()
# 將填色設為白色
ctx.fillStyle = '#fff'
ctx.fill()
# 白日:藍圈
ctx.beginPath()
ctx.arc(circle_x, circle_y, flag_w*17/240, 0, math.pi*2, True)
ctx.closePath()
# 填色設為藍色
ctx.fillStyle = 'rgb(0, 0, 149)'
ctx.fill()
# 白日:白心
ctx.beginPath()
ctx.arc(circle_x, circle_y, flag_w/16, 0, math.pi*2, True)
ctx.closePath()
# 填色設為白色
ctx.fillStyle = '#fff'
ctx.fill()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "flag" 的按鈕點按時, 執行 Flag 物件中的 prog 方法
doc["flag"].bind('click', Flag.prog)
</script>
</p>
<!-- flag ex ends -->
<p></p>
<!-- bunny starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Bunny = beditor.editor("""# Ggame
from ggame import App, ImageAsset, Sprite, MouseEvent
from random import random, randint
from browser import document as doc
from browser import html
import math
# for site variable to use socket.gethostname() to differentiate execution on localhost or not
import socket
# 引入既有的id="graphics-column" 標註
graphics_column = doc["graphics-column"]
# 建立內定名稱為 "ggame-canvas" 的 canvas 標註
canvas = html.CANVAS(width = 600, height = 400)
canvas.id = "ggame-canvas"
# 將 canvas 插入 gc 標註中
graphics_column <= canvas

# when work with dynamic site
if socket.gethostname() == "localhost":
    site = ""
else:
    # when work with remote site
    site="./.."

class Bunny(Sprite):
    
    asset = ImageAsset(site+"/images/bunny.png")
    
    def __init__(self, position):
        super().__init__(Bunny.asset, position)
        # register mouse events
        App.listenMouseEvent(MouseEvent.mousedown, self.mousedown)
        App.listenMouseEvent(MouseEvent.mouseup, self.mouseup)
        App.listenMouseEvent(MouseEvent.mousemove, self.mousemove)
        self.dragging = True
        self.deltax = 0
        self.deltay = 0
    
    def step(self):
        # Every now and then a bunny hops...
        if random() < 0.01:
            self.x += randint(-20,20)
            self.y += randint(-20,20)
        
        
    def mousedown(self, event):
        # capture any mouse down within 50 pixels
        self.deltax = event.x - (self.x + self.width//2) 
        self.deltay = event.y - (self.y + self.height//2)
        if abs(self.deltax) < 50 and abs(self.deltay) < 50:
            self.dragging = True
            # only drag one bunny at a time - consume the event
            event.consumed = True
            
    def mousemove(self, event):
        if self.dragging:
            self.x = event.x - self.deltax - self.width//2
            self.y = event.y - self.deltay - self.height//2
            event.consumed = True
            
    def mouseup(self, event):
        if self.dragging:
            self.dragging = False
            event.consumed = True
            
        
class DemoApp(App):
    
    def __init__(self):
        super().__init__()
        for i in range(5):
            Bunny((randint(50, 600), randint(50, 400)))
        
    def step(self):
        # Override step to perform action on each frame update
        for bunny in self.spritelist:
            bunny.step()
# Create the app
app = DemoApp()  
# Run the app
app.run()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "bunny" 的按鈕點按時, 執行 Bunny 物件中的 prog 方法
doc["bunny"].bind('click', Bunny.prog)
</script>
</p>
<!-- bunny ends -->
<p></p>
<!-- clear canvas start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Clear = beditor.editor("""# 清除畫布
from browser import document, html
brython_div = document["brython_div"] 
brython_div.clear()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "clear" 的按鈕點按時, 執行 Clear 物件中的 prog 方法
doc["clear"].bind('click', Clear.prog)
</script>
</p>
<!-- clear canvas ends -->
<p></p>
<!-- cango three spur gears starts -->
<script type="text/python3">
from browser import document
import beditor
url = "https://gist.githubusercontent.com/mdecourse/e896a4705a95ac8cc4147b355b0e87ef/raw/8954b8280c524c5781dc3c0b3565bc489d3aa3a3/three_spur_rotating.py"
src = open(url).read()
cango_three_spurs = beditor.editor(src, "kw_editor", "kw_console", "kw__container", "kw_py_src")
document["spur"].bind("click", cango_three_spurs.prog)
</script>
<!-- cango three spur gears ends -->
<p></p>
<!-- temp convert start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Temp = beditor.editor("""# Temperature Conversion
# Temperature Conversion
'''
C to F: Celsius to Fahrenheit Conversion Formula. To convert temperatures in degrees Celsius to Fahrenheit, multiply by 1.8 (or 9/5) and add 32.
To convert temperatures in degrees Fahrenheit to Celsius, subtract 32 and multiply by .5556 (or 5/9).
Fahrenheit = Celsius*9/5 + 32
Celsium = (Fahrenheit - 32)*5/9
'''
from browser import document, html
brython_div = document["brython_div"]
def c2f(c):
    f = round(c*9/5 + 32, 3)
    return "Celsiusc: "+ str(c) +         " degrees = Fahrenheit: " + str(f) + " degrees"
    
def f2c(f):
    c = round((f - 32)*5/9, 3)
    return "Fahrenheit: "+ str(f) +         " degrees = Celsiusc: " + str(c) + " degrees"
    
choice = input("c2f or f2c")
if choice == "c2f":
    '''
    c = float(input("input Celsius in degrees"))
    print(c2f(c))
    '''
    for deg in range(100):
        brython_div <= c2f(deg)
        brython_div <= html.BR()
else:
    '''
    f = float(input("input Fahrenheit in degrees"))
    print(f2c(f))
    '''
    for deg in range(100):
        brython_div <= f2c(deg)
        brython_div <= html.BR()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "temp" 的按鈕點按時, 執行 Temp 物件中的 prog 方法
doc["temp"].bind('click', Temp.prog)
</script>
</p>
<!-- temp convert ends -->
<p></p>
<!-- forloop start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Forloop = beditor.editor("""# For loop
for i in range(5):
    print(i)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "forloop" 的按鈕點按時, 執行 Forloop 物件中的 prog 方法
doc["forloop"].bind('click', Forloop.prog)
</script>
</p>
<!-- forloop ends -->
<p></p>
<!-- ex6 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Class_ex6 = beditor.editor("""# global variable i
i = 2
class myobj:
    # local variable i
    i = 1
    print(i)
    def method1(self):
        # can only access global variable variable i
        # can access local variable i through self.i 
        return i, self.i
def main():
    myinst = myobj()
    print(myinst.method1()) 

print(__name__)

if __name__ == "__main__":
    main()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "class_ex6" 的按鈕點按時, 執行 Class_ex6 物件中的 prog 方法
doc["class_ex6"].bind('click', Class_ex6.prog)
</script>
</p>
<!-- ex6 ends -->
<p></p>
<!-- guess start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Guess = beditor.editor("""# 猜數字遊戲
from browser import document, html, alert
import random
# 跳出文字說明視窗
alert("開始玩猜數字遊戲")
# 利用 random 模組中的 randint 取 1~100 間的亂數
標準答案 = random.randint(1, 100)
# 利用 input 函式視窗, 取使用者所猜的數字, 轉為整數
你猜的數字 = int(input("請輸入您所猜 1~100 間的整數:"))
# 猜測次數起始值設為 1
猜測次數 = 1
# 進入重複迴圈, 直到猜對數字
while 標準答案 != 你猜的數字:
    # 根據使用者所猜的數字, 與答案比較後, 給出提示
    if 標準答案 < 你猜的數字:
        alert("猜第" + str(猜測次數) + "次, 太大了，再猜 :)加油")
    else:
        alert("猜第" + str(猜測次數) + "次, 太小了，再猜 :)加油")
    你猜的數字 = int(input("請輸入您所猜 1~100 間的整數:"))
    # 猜測次數累加
    猜測次數 += 1
# 跳出迴圈表示猜對, 給出最後文字說明視窗
alert("猜對了！答案為" + str(標準答案) + ", 總共猜了" + str(猜測次數) + "次")
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "guess" 的按鈕點按時, 執行 Guess 物件中的 prog 方法
doc["guess"].bind('click', Guess.prog)
</script>
</p>
<!-- guess ends -->
<p></p>
<!-- autoguess start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Autoguess = beditor.editor("""# 程式自動猜數字遊戲
from browser import document, html, alert
import random
 
id4 = document["brython_div"]
執行次數 = 100
總猜測次數 = 0
for i in range(執行次數):
    id4 <= "第" + str(i+1) + "次玩:" + html.BR()
    下限 = 1
    上限 = 100
    標準答案 = random.randint(下限, 上限)
    pc猜的數字 = random.randint(下限, 上限)
    #print(標準答案, pc猜的數字)
    #integer int()
    #string str()
    #float float()
    #你猜的數字 = int(input("請輸入您所猜的整數:"))
    猜測次數 = 1
    while 標準答案 != pc猜的數字:
        if 標準答案 < pc猜的數字:
            #print("太大了，再猜一次 :)加油")
            # 因此已經確定"pc猜的數字"不是答案, 因此 - 1
            id4 <= "電腦猜的數字:" + str(pc猜的數字) + " 太大了!" + html.BR()
            上限 = pc猜的數字 - 1
        else:
            #print("太小了，再猜一次 :)加油")
            # 因此已經確定"pc猜的數字"不是答案, 因此 + 1
            id4 <= "電腦猜的數字:" + str(pc猜的數字) + " 太小了!" + html.BR()
            下限 = pc猜的數字 + 1
        #pc猜的數字 = int(input("請輸入您所猜的整數:"))
        pc猜的數字 = random.randint(下限, 上限)
        猜測次數 += 1
    #print("猜對了！總共猜了", 猜測次數, "次")
    id4 <= "電腦猜對了, 答案為: " + str(標準答案) + ", 總共猜了 "+ str(猜測次數) + "次" + html.BR()
    總猜測次數 += 猜測次數
平均猜測次數 = int(總猜測次數/執行次數)
#print("平均次數", 平均猜測次數)
id4 <= "平均次數: " + str(平均猜測次數)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "autoguess" 的按鈕點按時, 執行 Autoguess 物件中的 prog 方法
doc["autoguess"].bind('click', Autoguess.prog)
</script>
</p>
<!-- autoguess ends -->
<p></p>
<!-- lottery start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Lottery = beditor.editor("""# 大樂透電腦選號
# lottery
from browser import document, html, alert
import random
try:
    total = int(input("請問要出幾張大樂透彩卷號碼?"))
except:
    alert("請輸入要選擇大樂透電腦選號數量的'整數'")
    total = int(input("請問要出幾張大樂透彩卷號碼?"))
# 準備將電腦選出的號碼, 輸出到內定 id="brython_div" 的標註區域
output_div = document["brython_div"]
output_div <= "以下將出 " + str(total) + " 張電腦選號彩卷:" + html.BR()
for i in range(1, total + 1):
    # 利用 list(range()) 產生 1 到 49 的 population list
    # 然後再透過 random.sample(population, k) 
    # 從 population, 產生 k 個不同的數字
    numbers = random.sample(list(range(1, 49)), 6)
    output_div <= str(i) + ". 電腦選號為: " + str(numbers) + html.BR()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "lottery" 的按鈕點按時, 執行 Lottery 物件中的 prog 方法
doc["lottery"].bind('click', Lottery.prog)
</script>
</p>
<!-- lottery ends -->
<p></p>
<!-- 台灣威力彩 start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Weleadlottery = beditor.editor("""# 威力彩電腦選號
# weleadlottery
from browser import document, html, alert
import random
try:
    total = int(input("請問要出幾張威力彩卷號碼?"))
except:
    alert("請輸入要選擇威力彩電腦選號數量的'整數'")
    total = int(input("請問要出幾張威力彩卷號碼?"))
# 準備將電腦選出的號碼, 輸出到內定 id="brython_div" 的標註區域
output_div = document["brython_div"]
output_div <= "以下將出 " + str(total) + " 張威力彩電腦選號彩卷:" + html.BR()
for i in range(1, total + 1):
    # 利用 list(range()) 產生第一區 1 到 38 , 第二區 1 到 8 的 population list
    # 然後再透過 random.sample(population, k) 
    # 從 population, 產生 k 個不同的數字
    section1_numbers = random.sample(list(range(1, 38)), 6)
    section2_number = random.sample(list(range(1, 8)), 1)
    output_div <= str(i) + ". 電腦選號第一區為: " + str(section1_numbers) + html.BR()
    output_div <= ". 電腦選號第二區為: " + str(section2_number) + html.BR()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "lottery" 的按鈕點按時, 執行 Lottery 物件中的 prog 方法
doc["weleadlottery"].bind('click', Weleadlottery.prog)
</script>
</p>
<!-- 台灣威力彩 ends -->
<p></p>
<!-- bezier 開始 -->
<script type="text/python3">
import beditor
from browser import document
url = "https://gist.githubusercontent.com/mdecourse/2089a943b8fc260c2ca3ce4d0c886b1f/raw/e70f973d0b58f9db5fc6932960ef633421792f35/bezier24v3.py"
src = open(url).read()
bezier = beditor.editor(src, "kw_editor", "kw_console", "kw__container", "kw_py_src")
document["bezier"].bind("click", bezier.prog)
</script>
<!-- bezier 結束 -->
<p></p>
<!-- turtle1 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Turtle1 = beditor.editor("""# Turtle1 繪圖
from browser import window, html
from browser import document as doc
import turtle
turtle.set_defaults(
    turtle_canvas_wrapper = doc['brython_div']
)
t = turtle.Turtle()
t.width(5)
for c in ['red', '#00ff00', '#fa0', 'rgb(0,0,200)']:
    t.color(c)
    t.forward(100)
    t.left(90)
# dot() and write() do not require the pen to be down
t.penup()
t.goto(-30, -100)
t.dot(40, 'rgba(255, 0, 0, 0.5')
t.goto(30, -100)
t.dot(40, 'rgba(0, 255, 0, 0.5')
t.goto(0, -70)
t.dot(40, 'rgba(0, 0, 255, 0.5')
t.goto(0, 125)
t.color('purple')
t.write("這就是 Brython, 網頁上的 Python", font=("Arial", 15, "normal"))
turtle.done()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "turtle1" 的按鈕點按時, 執行 Turtle1 物件中的 prog 方法
doc["turtle1"].bind('click', Turtle1.prog)
</script>
</p>
<!-- turtle1 ends -->
<p></p>
<!-- turtle2 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Turtle2 = beditor.editor("""# Turtle2 繪圖
from browser import document as doc
import turtle
turtle.set_defaults(
    turtle_canvas_wrapper = doc['brython_div']
)
star = turtle.Turtle()
for i in range(5):
    star.forward(250)
    star.right(144)
    
turtle.done()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "turtle2" 的按鈕點按時, 執行 Turtle2 物件中的 prog 方法
doc["turtle2"].bind('click', Turtle2.prog)
</script>
</p>
<!-- turtle2 ends -->
<p></p>
<!-- turtle3 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Turtle3 = beditor.editor("""# Turtle3 繪圖
# https://michael0x2a.com/blog/turtle-examples
from browser import document as doc
import turtle
turtle.set_defaults(
    turtle_canvas_wrapper = doc['brython_div']
)
painter = turtle.Turtle()
painter.pencolor("blue")
for i in range(50):
    painter.forward(50)
    painter.left(123) # Let's go counterclockwise this time 
    
painter.pencolor("red")
for i in range(50):
    painter.forward(100)
    painter.left(123)
    
turtle.done()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "turtle3" 的按鈕點按時, 執行 Turtle3 物件中的 prog 方法
doc["turtle3"].bind('click', Turtle3.prog)
</script>
</p>
<!-- turtle3 ends -->
<p></p>
<!-- turtle4 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Turtle4 = beditor.editor("""# Turtle4 繪圖
# https://docs.python.org/3.7/library/turtle.html?highlight=turtle
# https://fiftyexamples.readthedocs.io/en/latest/turtle.html
from browser import document as doc
import turtle
turtle.set_defaults(
    turtle_canvas_wrapper = doc['brython_div']
)
# 輸入 "turtle" 字串, 表示要使用內建的烏龜圖示
t = turtle.Turtle("turtle")
# 設定繪圖尺寸
screen_x = 500-20
screen_y = 300
# 提筆, 將烏龜移動到畫布中心
t.penup()
t.home()
# 內定方向為右, 前進 screen_x/2
t.forward(screen_x / 2)
# 將方向往右轉 90 度
t.right(90)
# 此時方向向下, 前進 screen_y/2
t.forward(screen_y / 2)
# 令烏龜方向轉絕對角度 180, 等同轉相對角度 90 度, 即 t.right(90)
t.setheading(180)
# 將畫筆顏色設為紅色
t.pencolor('red')
# 下筆準備繪圖
t.pendown()
# 設筆寬度為 10
t.pensize(10)
# 進入重複迴圈, 此時方向向右, 分別
# 前進 screen_x, 之後轉 90 度, 方向朝上
# 再前進 screen_y, 之後再轉 90 度, 方向朝右
# 再前進 screen_x, 之後轉 90 度, 方向朝下
# 最後再前進 screen_y 後, 將方向轉為向左
for distance in (screen_x, screen_y, screen_x, screen_y):
    t.forward(distance)
    t.right(90)
# 提筆後, 將烏龜轉回內定方向回到畫布中心
t.penup()
t.home()
# 完成 turtle 繪圖
turtle.done()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "turtle4" 的按鈕點按時, 執行 Turtle4 物件中的 prog 方法
doc["turtle4"].bind('click', Turtle4.prog)
</script>
</p>
<!-- turtle4 ends -->
<p></p>
<!-- turtle5 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Turtle5 = beditor.editor("""# Turtle5 繪圖
# https://brython.info/gallery/turtle.html
from browser import document as doc
import turtle
import math
turtle.set_defaults(
    turtle_canvas_wrapper = doc['brython_div']
)
t = turtle.Turtle("turtle")
t.speed(1)
t.forward(50)
print("Should be (50, 0):", t.position())
print("Should be 50: ", t.xcor())
print("Should be 0: ", t.ycor())
t.left(90)
t.color("blue")
t.speed(2)
t.fd(50)
print("Should be (50, 50):", t.pos())
print("Should be 225: ", t.towards(0, 0))
print("Should be 90: ", t.heading())
print("Should be approximately 71:", t.distance(0, 0))
# Draw the same square in three different angle modes
t.width(4)
print("Drawing using degrees - the default")
print("Heading should be 90: ", t.heading())
for i in range(4):
    t.forward(100)
    t.left(90)
print("Drawing using radians")
t.radians()
print("Heading should be pi/2: ", t.heading())
for i in range(4):
    t.forward(100)
    t.left(math.pi/2)
print("Drawing using gradients")
t.degrees(400)
print("Heading should be 100: ", t.heading())
for i in range(4):
    t.forward(100)
    t.left(100)
t.degrees()
t.width(1)
t.lt(90)
t.color("orange")
t.backward(50)
t.right(90)
t.color("green")
t.back(50)
t.rt(90)
t.color("red")
t.bk(50)
t.stamp()
t.speed(4)
t.color("black", "white")
t.goto(-100, 100)
t.stamp()
t.color("blue", "yellow")
t.setposition(0, 100)
t.stamp()
t.color("green", "white")
t.setpos(100, 100)
t.stamp()
t.speed(10)
t.color("orange")
t.sety(-100)
t.setx(-100)
t.stamp()
t.color("cyan")
t.home()
t.stamp()
t.color("green")
t.width(4)
t.setheading(180)
t.forward(150)
t.seth(90)
t.fd(20)
t.dot(30, "rgba(255, 0, 0, 0.2)")
t.color("red")
t.speed(0)
t.forward(30)
t.left(90)
t.circle(30)
turtle.done()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "turtle5" 的按鈕點按時, 執行 Turtle5 物件中的 prog 方法
doc["turtle5"].bind('click', Turtle5.prog)
</script>
</p>
<!-- turtle5 ends -->
<p></p>
<!-- turtle6 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Turtle6 = beditor.editor("""# Turtle6 繪圖
from browser import document as doc
import turtle
import math
turtle.set_defaults(
    turtle_canvas_wrapper = doc['brython_div']
)
t = turtle.Turtle("turtle")
t.speed(10)
colors = ['red', 'purple', 'blue', 'green', 'orange']
for x in range(150):
    t.pencolor(colors[x % 5])
    t.width(x/10 + 1)
    t.forward(x)
    t.left(59)
turtle.done()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "turtle6" 的按鈕點按時, 執行 Turtle6 物件中的 prog 方法
doc["turtle6"].bind('click', Turtle6.prog)
</script>
</p>
<!-- turtle6 ends -->
<p></p>
<!-- turtle7 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Turtle7 = beditor.editor("""# Turtle7 繪圖
from browser import document as doc
import turtle
import math
turtle.set_defaults(
    turtle_canvas_wrapper = doc['brython_div']
)
screen=turtle.Screen()    #making a canvas for drawing
screen.bgcolor('black')    #making canvas black
trtl=turtle.Turtle()  #making a turtle
trtl.pencolor('red')    #making colour of the pen red
trtl.pensize(5)    #choosing the size of pen nib 
trtl.speed(10)    #choosing the speed of drawing
# shape should be ‘arrow’, ‘classic’, ‘turtle’ or ‘circle’
trtl.shape('turtle')   #choosing the shape of pen nib
trtl.forward(150)    #drawing a line of 150 pixels
trtl.right(90)    #asking turtle to turn 90 degrees
trtl.forward(150)    #drawing a line of 150 pixels
trtl.penup()    # preparing for moving pen without drawing
trtl.setpos(-140,-120)    # making the new position of the turtle
trtl.pendown()   # bringing the pen down for drawing again
trtl.pencolor('green')    # choosin the pen colour as green
trtl.write('Brython 烏龜繪圖', font=("Arial", 20, "bold"))    # chosing the font
trtl.penup()
trtl.ht()    # hiding the turtle from the screen
turtle.done()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "turtle7" 的按鈕點按時, 執行 Turtle7 物件中的 prog 方法
doc["turtle7"].bind('click', Turtle7.prog)
</script>
</p>
<!-- turtle7 ends -->
<p></p>
<!-- turtle8 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Turtle8 = beditor.editor("""# Turtle8 繪圖
from browser import document as doc
import turtle
import math
turtle.set_defaults(
    turtle_canvas_wrapper = doc['brython_div']
)
wn = turtle.Screen() 
wn.bgcolor("black") 
skk = turtle.Turtle() 
skk.speed(10)
skk.shape("circle")
skk.color("blue") 
  
def sqrfunc(size): 
    for i in range(4): 
        skk.fd(size) 
        skk.left(90) 
        size = size-5
  
sqrfunc(146) 
sqrfunc(126) 
sqrfunc(106) 
sqrfunc(86) 
sqrfunc(66) 
sqrfunc(46) 
sqrfunc(26) 
turtle.done()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "turtle8" 的按鈕點按時, 執行 Turtle8 物件中的 prog 方法
doc["turtle8"].bind('click', Turtle8.prog)
</script>
</p>
<!-- turtle8 ends -->
<p></p>
<!-- konva1 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Konva1 = beditor.editor("""# Konva1 繪圖
# 引用 https://konvajs.github.io/ 繪圖
from browser import document, html, window
width = 600
height = 400
konva = window.Konva
# Konva 必須在 canvas 繪圖, 從上方設定,  canvas id 為 "container"
stage = konva.Stage.new({
        "container": 'brython_div',
        "width": width,
        "height": height
    })
layer = konva.Layer.new()
rectX = stage.getWidth() / 2 - 50
rectY = stage.getHeight() / 2 - 25
box = konva.Rect.new({
        "x": rectX,
        "y": rectY,
        "width": 100,
        "height": 50,
        "fill": '#00D2FF',
        "stroke": 'black',
        "strokeWidth": 4,
        "draggable": True
    })
def f1():
    document.body.style.cursor = 'pointer'
    
def f2():
    document.body.style.cursor = 'default'
# add cursor styling
box.on('mouseover', f1())
box.on('mouseout', f2())
layer.add(box)
stage.add(layer)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "konva1" 的按鈕點按時, 執行 Konva1 物件中的 prog 方法
doc["konva1"].bind('click', Konva1.prog)
</script>
</p>
<!-- konva1 ends -->
<p></p>
<!-- ycqsort starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Ycqsort = beditor.editor("""# Ycombinator quicksort example
Y = lambda f: lambda *args: f(Y(f))(*args)
quicksort = Y(lambda f:
    lambda x: (
        f([item for item in x if item < x[0]])
        + [y for y in x if x[0] == y]
        + f([item for item in x if item > x[0]])
    ) if x else [])
    
print(quicksort([1, 3, 5, 4, 1, 3, 2]))
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "ycqsort" 的按鈕點按時, 執行 Ycqsort 物件中的 prog 方法
doc["ycqsort"].bind('click', Ycqsort.prog)
</script>
</p>
<!-- ycqsort ends -->
<p></p>
<!-- ball starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Ball = beditor.editor("""# Ggame ball example
from ggame import (
    App, 
    Color, 
    LineStyle, 
    Sprite, 
    RectangleAsset, 
    ImageAsset,
    CircleAsset, 
    EllipseAsset, 
    PolygonAsset,
)
from browser import document as doc
from browser import html
# for site variable to check socket.gethostname() for image file location
import socket
# 引入既有的id="graphics-column" 標註
graphics_column = doc["graphics-column"]
# 建立內定名稱為 "ggame-canvas" 的 canvas 標註
canvas = html.CANVAS(width = 600, height = 100)
canvas.id = "ggame-canvas"
# 將 canvas 插入 gc 標註中
graphics_column <= canvas
# reverse - change the ball direction
def reverse(b):
    b.direction *= -1
# Set up function for handling screen refresh
def step():
    if ball.go:
        ball.x += ball.direction
        if ball.x + ball.width > myapp.width or ball.x < 0:
            ball.x -= ball.direction
            reverse(ball)
myapp = App()
# Three primary colors with no transparency (alpha = 1.0)
red = Color(0xff0000, 1.0)
green = Color(0x00ff00, 1.0)
blue = Color(0x0000ff, 1.0)
black = Color(0x000000, 1.0)
# define colors and line style
green = Color(0x00ff00, 1)
black = Color(0, 1)
noline = LineStyle(0, black)
# a rectangle asset and sprite to use as background
bg_asset = RectangleAsset(canvas.width, canvas.height, noline, green)
bg = Sprite(bg_asset, (0,0))
# when work with dynamic site
if socket.gethostname() == "localhost":
    site = ""
else:
    # when work with remote site
    site="./.."
ball_asset = ImageAsset(site+"/images/orb-150545_640.png")
ball = Sprite(ball_asset, (0, 0))
# Original image is too big. Scale it to 1/10 its original size
ball.scale = 0.1
# custom attributes
ball.direction = 7
ball.go = True
myapp.run(step)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "ball" 的按鈕點按時, 執行 Ball 物件中的 prog 方法
doc["ball"].bind('click', Ball.prog)
</script>
</p>
<!-- ball ends -->
<p></p>
<!-- nfulist starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Nfulist = beditor.editor("""# nfulist
url = "https://nfulist.herokuapp.com/?semester=1092&courseno=2384&column=True"
data = open(url).read()
print(data)
'''
2021 spring:
0741 1a
0764 2a
0776 2b
2384 5j
'''
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "nfulist" 的按鈕點按時, 執行 Nfulist 物件中的 prog 方法
doc["nfulist"].bind('click', Nfulist.prog)
</script>
</p>
<!-- nfulist ends -->
<p></p>
<!-- clock1 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Clock1 = beditor.editor("""# clock1 in Brython
'''Code for the clock'''
# Line drawing
# 導入 doc
from browser import document as doc
from browser import html
import math
import time
import browser.timer
canvas = html.CANVAS(width = 300, height = 200)
canvas.id = "line_drawing"
brython_div = doc["brython_div"]
brython_div <= canvas
# 準備繪圖畫布
canvas = doc["line_drawing"]
ctx = canvas.getContext("2d")

sin, cos = math.sin, math.cos
width, height = 200, 200 # canvas dimensions
ray = 100 # clock ray

background = "SteelBlue"
digits = "#fff"
border = "blue"

def needle(angle, r1, r2):
    '''Draw a needle at specified angle in specified color.
    r1 and r2 are percentages of clock ray.
    '''
    x1 = width / 2 - ray * cos(angle) * r1
    y1 = height / 2 - ray * sin(angle) * r1
    x2 = width / 2 + ray * cos(angle) * r2
    y2 = height / 2 + ray * sin(angle) * r2
    ctx.beginPath()
    ctx.strokeStyle = "#fff"
    ctx.moveTo(x1, y1)
    ctx.lineTo(x2, y2)
    ctx.stroke()

def set_clock():
    # erase clock
    ctx.beginPath()
    ctx.fillStyle = background
    ctx.arc(width / 2, height / 2, ray * 0.89, 0, 2 * math.pi)
    ctx.fill()

    # redraw hours
    show_hours()

    # print day
    now_time = time.time()
    now = time.localtime(now_time)
    microsecs = now_time - int(now_time)
    day = now.tm_mday
    ctx.font = "bold 14px Arial"
    ctx.textAlign = "center"
    ctx.textBaseline = "middle"
    ctx.fillStyle = "#000"
    ctx.fillText(day, width * 0.7, height * 0.5)

    # draw needles for hour, minute, seconds
    ctx.lineWidth = 2
    hour = now.tm_hour % 12 + now.tm_min / 60
    angle = hour * 2 * math.pi / 12 - math.pi / 2
    needle(angle, 0.05, 0.45)
    minute = now.tm_min
    angle = minute * 2 *math.pi / 60 - math.pi / 2
    needle(angle, 0.05, 0.7)
    ctx.lineWidth = 1
    second = now.tm_sec + microsecs
    angle = second * 2 * math.pi / 60 - math.pi / 2
    needle(angle, 0.05, 0.8)

def show_hours():
    ctx.beginPath()
    ctx.arc(width / 2, height / 2, ray * 0.05, 0, 2 * math.pi)
    ctx.fillStyle = digits
    ctx.fill()
    for i in range(1, 13):
        angle = i * math.pi / 6 - math.pi / 2
        x3 = width / 2 + ray * cos(angle) * 0.82
        y3 = height / 2 + ray * sin(angle) * 0.82
        ctx.font = "18px Arial"
        ctx.textAlign = "center"
        ctx.textBaseline = "middle"
        ctx.fillText(i, x3, y3)
    # cell for day
    ctx.fillStyle = "#fff"
    ctx.fillRect(width * 0.65, height * 0.47, width * 0.1, height * 0.06)

    ctx.beginPath()
ctx.arc(width / 2, height / 2, ray, 0, 2 * math.pi)
ctx.fillStyle = background
ctx.fill()

browser.timer.set_interval(set_clock, 100)
show_hours()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "clock1" 的按鈕點按時, 執行 Clock1 物件中的 prog 方法
doc["clock1"].bind('click', Clock1.prog)
</script>
</p>
<!-- clock1 ends -->
<p></p>
<!-- fourbar linkage starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Fourbar= beditor.editor("""# Fourbar Linkage Simulation
from browser import document, html
import math
import time
import browser.timer
 
class Coord(object):
    def __init__(self,x,y):
        self.x = x
        self.y = y
 
    def __sub__(self,other):
        # This allows you to substract vectors
        return Coord(self.x-other.x,self.y-other.y)
 
    def __repr__(self):
        # Used to get human readable coordinates when printing
        return "Coord(%f,%f)"%(self.x,self.y)
 
    def length(self):
        # Returns the length of the vector
        return math.sqrt(self.x**2 + self.y**2)
 
    def angle(self):
        # Returns the vector's angle
        return math.atan2(self.y,self.x)
 
def normalize(coord):
    return Coord(
        coord.x/coord.length(),
        coord.y/coord.length()
        )
 
def perpendicular(coord):
    # Shifts the angle by pi/2 and calculate the coordinates
    # using the original vector length
    return Coord(
        coord.length()*math.cos(coord.angle()+math.pi/2),
        coord.length()*math.sin(coord.angle()+math.pi/2)
        )
 
# 點類別
class Point(object):
    # 起始方法
    def __init__(self, x, y):
        self.x = x
        self.y = y
 
    # 繪製方法
    def drawMe(self, g, r):
        self.g = g
        self.r = r
        self.g.save()
        self.g.moveTo(self.x,self.y)
        self.g.beginPath()
        # 根據 r 半徑繪製一個圓代表點的所在位置
        self.g.arc(self.x, self.y, self.r, 0, 2*math.pi, True)
        self.g.moveTo(self.x,self.y)
        self.g.lineTo(self.x+self.r, self.y)
        self.g.moveTo(self.x, self.y)
        self.g.lineTo(self.x-self.r, self.y)
        self.g.moveTo(self.x, self.y)
        self.g.lineTo(self.x, self.y+self.r)
        self.g.moveTo(self.x, self.y)
        self.g.lineTo(self.x, self.y-self.r)
        self.g.restore()
        self.g.stroke()
 
    # 加入 Eq 方法
    def Eq(self, pt):
        self.x = pt.x
        self.y = pt.y
 
    # 加入 setPoint 方法
    def setPoint(self, px, py):
        self.x = px
        self.y = py
 
    # 加上 distance(pt) 方法, 計算點到 pt 的距離
    def distance(self, pt):
        self.pt = pt
        x = self.x - self.pt.x
        y = self.y - self.pt.y
        return math.sqrt(x * x + y * y)
 
    # 利用文字標示點的座標位置
    def tag(self, g):
        self.g = g
        self.g.beginPath()
        self.g.fillText("%d, %d"%(self.x, self.y),self.x, self.y)
        self.g.stroke()
 
 
# Line 類別物件
class Line(object):
 
    # 起始方法
    def __init__(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
        # 直線的第一點, 設為線尾
        self.Tail = self.p1
        # 直線組成的第二點, 設為線頭
        self.Head = self.p2
        # 直線的長度屬性
        self.length = math.sqrt(math.pow(self.p2.x-self.p1.x, 2)+math.pow(self.p2.y-self.p1.y,2))
 
    # setPP 以指定頭尾座標點來定義直線
    def setPP(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
        self.Tail = self.p1
        self.Head = self.p2
        self.length = math.sqrt(math.pow(self.p2.x-self.p1.x, 2)+math.pow(self.p2.y-self.p1.y,2))
 
    # setRT 方法 for Line, 應該已經確定 Tail 點, 然後以 r, t 作為設定 Head 的參考
    def setRT(self, r, t):
        self.r = r
        self.t = t
        x = self.r * math.cos(self.t)
        y = self.r * math.sin(self.t)
        self.Tail.Eq(self.p1)
        self.Head.setPoint(self.Tail.x + x,self.Tail.y + y)
 
    # getR 方法 for Line
    def getR(self):
        # x 分量與 y 分量
        x = self.p1.x - self.p2.x
        y = self.p1.y - self.p2.y
        return math.sqrt(x * x + y * y)
 
    # 根據定義 atan2(y,x), 表示 (x,y) 與 正 x 軸之間的夾角, 介於 pi 與 -pi 間
    def getT(self):
        x = self.p2.x - self.p1.x
        y = self.p2.y - self.p1.y
        if (math.fabs(x) < math.pow(10,-100)):
            if(y < 0.0):
                return (-math.pi/2)
            else:
                return (math.pi/2)
        else:
            return math.atan2(y, x)
 
    # setTail 方法 for Line
    def setTail(self, pt):
        self.pt = pt
        self.Tail.Eq(pt)
        self.Head.setPoint(self.pt.x + self.x, self.pt.y + self.y)
 
    # getHead 方法 for Line
    def getHead(self):
        return self.Head
 
    def getTail(self):
        return self.Tail
 
    def drawMe(self, g):
        self.g = g
        self.g.beginPath()
        self.g.moveTo(self.p1.x,self.p1.y)
        self.g.lineTo(self.p2.x,self.p2.y)
        self.g.stroke()
 
    def test(self):
        return ("this is pure test to Inherit")
 
 
class Link(Line):
    def __init__(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
        self.length = math.sqrt(math.pow((self.p2.x - self.p1.x), 2) + math.pow((self.p2.y - self.p1.y), 2))
 
    #g context
    def drawMe(self, g):
        self.g = g
        hole = 5
        radius = 10
        length = self.getR()
        # alert(length)
        # 儲存先前的繪圖狀態
        self.g.save()
        self.g.translate(self.p1.x,self.p1.y)
        #alert(str(self.p1.x)+","+str(self.p1.y))
        #self.g.rotate(-((math.pi/2)-self.getT()))
        self.g.rotate(-math.pi*0.5 + self.getT())
        #alert(str(self.getT()))
        #self.g.rotate(10*math.pi/180)
        #this.g.rotate(-(Math.PI/2-this.getT()));
        # 必須配合畫在 y 軸上的 Link, 進行座標轉換, 也可以改為畫在 x 軸上...
        self.g.beginPath()
        self.g.moveTo(0,0)
        self.g.arc(0, 0, hole, 0, 2*math.pi, True)
        self.g.stroke()
        self.g.moveTo(0,length)
        self.g.beginPath()
        self.g.arc(0,length, hole, 0, 2*math.pi, True)
        self.g.stroke()
        self.g.moveTo(0,0)
        self.g.beginPath()
        self.g.arc(0,0, radius, 0, math.pi, True)
        self.g.moveTo(0+radius,0)
        self.g.lineTo(0+radius,0+length)
        self.g.stroke()
        self.g.moveTo(0,0+length)
        self.g.beginPath()
        self.g.arc(0, 0+length, radius, math.pi, 0, True)
        self.g.moveTo(0-radius,0+length)
        self.g.lineTo(0-radius,0)
        self.g.stroke()
        self.g.restore()
        '''
        self.g.beginPath()
        self.g.fillStyle = "red"
        self.g.font = "bold 18px sans-serif"
        self.g.fillText("%d, %d"%(self.p2.x, self.p2.y),self.p2.x, self.p2.y)
        self.g.stroke()
        '''
 
class Triangle(object):
    def __init__(self, p1, p2, p3):
        self.p1 = p1
        self.p2 = p2
        self.p3 = p3
 
    def getLenp3(self):
        p1 = self.p1
        ret = p1.distance(self.p2)
        return ret
 
    def getLenp1(self):
        p2 = self.p2
        ret = p2.distance(self.p3)
        return ret
 
    def getLenp2(self):
        p1 = self.p1
        ret = p1.distance(self.p3)
        return ret
 
    # 角度
    def getAp1(self):
        ret = math.acos(((self.getLenp2() * self.getLenp2() + self.getLenp3() * self.getLenp3()) - self.getLenp1() * self.getLenp1()) / (2* self.getLenp2() * self.getLenp3()))
        return ret
 
    #
    def getAp2(self):
        ret =math.acos(((self.getLenp1() * self.getLenp1() + self.getLenp3() * self.getLenp3()) - self.getLenp2() * self.getLenp2()) / (2* self.getLenp1() * self.getLenp3()))
        return ret
 
    def getAp3(self):
        ret = math.acos(((self.getLenp1() * self.getLenp1() + self.getLenp2() * self.getLenp2()) - self.getLenp3() * self.getLenp3()) / (2* self.getLenp1() * self.getLenp2()))
        return ret
 
    def drawMe(self, g):
        self.g = g
        r = 5
        # 繪出三個頂點
        self.p1.drawMe(self.g,r)
        self.p2.drawMe(self.g,r)
        self.p3.drawMe(self.g,r)
        line1 = Line(self.p1,self.p2)
        line2 = Line(self.p1,self.p3)
        line3 = Line(self.p2,self.p3)
        # 繪出三邊線
        line1.drawMe(self.g)
        line2.drawMe(self.g)
        line3.drawMe(self.g)
 
    # ends Triangle def
    # 透過三個邊長定義三角形
    def setSSS(self, lenp3, lenp1, lenp2):
        self.lenp3 = lenmidpt = Point(0, 0)
        self.lenp1 = lenp1
        self.lenp2 = lenp2
        self.ap1 = math.acos(((self.lenp2 * self.lenp2 + self.lenp3 * self.lenp3) - self.lenp1 * self.lenp1) / (2* self.lenp2 * self.lenp3))
        self.ap2 = math.acos(((self.lenp1 * self.lenp1 + self.lenp3 * self.lenp3) - self.lenp2 * self.lenp2) / (2* self.lenp1 * self.lenp3))
        self.ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp2 * self.lenp2) - self.lenp3 * self.lenp3) / (2* self.lenp1 * self.lenp2))
 
    # 透過兩個邊長與夾角定義三角形
    def setSAS(self, lenp3, ap2, lenp1):
        self.lenp3 = lenp3
        self.ap2 = ap2
        self.lenp1 = lenp1
        self.lenp2 = math.sqrt((self.lenp3 * self.lenp3 + self.lenp1 * self.lenp1) - 2* self.lenp3 * self.lenp1 * math.cos(self.ap2))
        #等於 SSS(AB, BC, CA)
 
    def setSaSS(self, lenp2, lenp3, lenp1):
        self.lenp2 = lenp2
        self.lenp3 = lenp3
        self.lenp1 = lenp1
        if(self.lenp1 > (self.lenp2 + self.lenp3)):
        #<CAB 夾角為 180 度, 三點共線且 A 介於 BC 之間
            ret = math.pi
        else :
            # <CAB 夾角為 0, 三點共線且 A 不在 BC 之間
            if((self.lenp1 < (self.lenp2 - self.lenp3)) or (self.lenp1 < (self.lenp3 - self.lenp2))):
                ret = 0.0
            else :
            # 透過餘絃定理求出夾角 <CAB 
                ret = math.acos(((self.lenp2 * self.lenp2 + self.lenp3 * self.lenp3) - self.lenp1 * self.lenp1) / (2 * self.lenp2 * self.lenp3))
        return ret
 
    # 取得三角形的三個邊長值
    def getSSS(self):
        temp = []
        temp.append( self.getLenp1() )
        temp.append( self.getLenp2() )
        temp.append( self.getLenp3() )
        return temp
 
    # 取得三角形的三個角度值
    def getAAA(self):
        temp = []
        temp.append( self.getAp1() )
        temp.append( self.getAp2() )
        temp.append( self.getAp3() )
        return temp
 
    # 取得三角形的三個角度與三個邊長
    def getASASAS(self):
        temp = []
        temp.append(self.getAp1())
        temp.append(self.getLenp1())
        temp.append(self.getAp2())
        temp.append(self.getLenp2())
        temp.append(self.getAp3())
        temp.append(self.getLenp3())
        return temp
    #2P 2L return mid P
    def setPPSS(self, p1, p3, lenp1, lenp3):
        temp = []
        self.p1 = p1
        self.p3 = p3
        self.lenp1 = lenp1
        self.lenp3 = lenp3
 
        #bp3 is the angle beside p3 point, cp3 is the angle for line23, p2 is the output
        line31 = Line(p3, p1)
        self.lenp2 = line31.getR()
        #這裡是求角3
        ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp2 * self.lenp2) - self.lenp3 * self.lenp3) / (2 * self.lenp1 * self.lenp2))
        bp3 = line31.getT()
        cp3 = bp3 - ap3
        temp.append(p3.x + self.lenp1*math.cos(cp3))#p2.x
        temp.append(p3.y + self.lenp1*math.sin(cp3))#p2.y
        return temp
 
def tag(g, p):
    None
 
midpt = Point(0, 0)
tippt = Point(0, 0)
contour = []
# 執行繪圖流程, 注意 x, y 為 global variables
def draw():
    global theta, midpt, oldpt
    context.clearRect(0, 0, canvas.width, canvas.height)
    line1.drawMe(context)
    line2.drawMe(context)
    line3.drawMe(context)
    #triangle1.drawMe(context)
    #triangle2.drawMe(context)
    theta += dx
    p2.x = p1.x + line1.length*math.cos(theta*degree)
    p2.y = p1.y - line1.length*math.sin(theta*degree)
    p3.x, p3.y = triangle2.setPPSS(p2,p4,link2_len,link3_len)
    # 計算垂直單位向量
    a = Coord(p3.x, p3.y)
    b = Coord(p2.x, p2.y)
    normal = perpendicular(normalize(a-b))
    midpt.x = (p2.x + p3.x)/2
    midpt.y = (p2.y + p3.y)/2
    tippt.x = midpt.x + 150*normal.x
    tippt.y = midpt.y + 150*normal.y
    if theta < 360:
        contour.append((tippt.x, tippt.y))
    context.beginPath()
    context.moveTo(midpt.x, midpt.y)
    context.lineTo(tippt.x, tippt.y)
    # 利用 fillRect 繪製一個長寬各 1 單位的正方形
    for i in range(len(contour)):
        context.fillRect(contour[i][0], contour[i][1], 1, 1)
    context.stroke()
    #p1.tag(context)
 
# 以上為相關函式物件的定義區
# 全域變數
# 幾何位置輸入變數
x=10
y=10
r=10
 
# 畫布與繪圖內容
# 其他輸入變數
theta = 0
degree = math.pi/180.0
dx = 2
dy = 4
 
#set p1.p2.p3.p4 position
lift = 10
p1 =  Point(150,100+lift)
p2 =  Point(150,200+lift)
p3 =  Point(300,300+lift)
p4 =  Point(350,100+lift)
 
#accord position create link
line1 =  Link(p1,p2)
line2 =  Link(p2,p3)
line3 =  Link(p3,p4)
line4 =  Link(p1,p4)
line5 =  Link(p2,p4)
 
link2_len = p2.distance(p3)
link3_len = p3.distance(p4)
 
#link2_len = line1.getR()
#link3_len = line3.getR()
#alert(str(link2_len)+','+str(link3_len))
 
triangle1 =  Triangle(p1,p2,p4)
triangle2 =  Triangle(p2,p3,p4)
 
# 視窗載入時執行內容
# 繪圖畫布設定

canvas = html.CANVAS(width = 600, height = 450)
canvas.id = "line_drawing"
brython_div = document["brython_div"]
brython_div <= canvas
# 準備繪圖畫布
canvas = document["line_drawing"]
context = canvas.getContext("2d")
 
# 座標轉換, 移動 canvas.height 並且 y 座標變號, 也就是將原點座標移到畫面左下角
context.translate(0,canvas.height)
context.scale(1,-1)
 
#以間隔 20 micro seconds 重複呼叫 draw()
browser.timer.set_interval(draw,20)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "fourbar" 的按鈕點按時, 執行 Fourbar 物件中的 prog 方法
doc["fourbar"].bind('click', Fourbar.prog)
</script>
</p>
<!-- fourbar linkage ends -->
<p></p>
<!-- snake starts -->
<p>
<script type="text/python3">
from browser import document as doc
# 導入位於 static 目錄下的 beditor.py 
import beditor
# 利用 beditor.py 中的 editor 類別建立案例, 對應到 kw1
Snake = beditor.editor("""# 從 browser 導入 document 並設為 doc
from browser import document as doc
# 使用者可以透過 window 當作介面使用其他 Javascript 功能
from browser import html, window
# 用於定時執行特定函式
import browser.timer
# 導入數學模組
import math
# 導入亂數模組
from random import random, randint

def update_score(new_score):
    global high_score
    score_doc.innerHTML = "Score: " + str(new_score)
    if new_score > high_score:
        high_score_doc.innerHTML = "High Score: " + str(new_score)
        high_score = new_score
    
def game():
    global px, py, tc, gs, ax, ay, trail, tail, score
    # px 為 snake 第一個點的 x 座標, 增量值為 xv
    px += xv
    py += yv
    # 允許穿越四面牆, 以 tc 表示牆面座標極限
    # 若 px 為負值則設定為 tc -1, 表示 tc 為 x 方向 limit
    # x 座標方向的穿牆設定
    if px < 0:
        px = tc-1
    if px > tc-1:
        px = 0
    # y 座標方向的穿牆設定
    if py < 0:
        py = tc-1
    if py > tc-1:
        py = 0
    ctx.fillStyle = "black"
    # 畫布填入黑色
    ctx.fillRect(0, 0, canvas.width, canvas.height)
    # snake 為 lime 色
    ctx.fillStyle = "lime"
    # trail 為數列, 代表 snake 各節 [x,y] 座標
    # trail = [[x0,y0], [x1, y1], [x2, y2]...]
    # gs 為方塊邊長 pixel 數
    for i in range(len(trail)):
        # https://developer.mozilla.org/zh-TW/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes
        # fillRect(x, y, width, height)
        ctx.fillRect(trail[i][0]*gs, trail[i][1]*gs, gs-2, gs-2)
        # 若 snake 第一節座標 (px, py)  穿過身體任一節, 則 score 歸零
        if trail[i][0] == px and trail[i][1] == py:
            score = score if paused else 0
            # snake reset 為五節
            tail = 5
    # trail 數列以碰到的 [px, py] 座標數列插入作為第一節
    trail.insert(0, [px, py])
    while len(trail) > tail:
        # pop() 內建移除數列最後一個 element
        trail.pop()
    # ax, ay 為紅點座標
    # 當 snake 第一節座標[px, py] 與紅色食物座標 [ax, ay] 重合
    # 則 tail 增量, 即多一節且得分加 1, 然後食物座標 [ax, ay] 重新以亂數定位
    if ax == px and ay == py:
        tail += 1
        ax = math.floor(random()*tc)
        ay = math.floor(random()*tc)
        score += 1
    # 更新計分顯示
    update_score(score)
    ctx.fillStyle = "red"
    ctx.fillRect(ax*gs, ay*gs, gs-2, gs-2)
  
def key_push(evt):
    global xv, yv, pre_pause, paused
    key = evt.keyCode
    # 37 is left arrow key
    # 74 is j key
    if key == 74 and not paused:
        xv = -1
        yv = 0
    # 38 is up arrow key
    # 73 is i key
    elif key == 73 and not paused:
        xv = 0
        yv = -1
    # 39 is right arrow key
    # 76 is l key
    elif key == 76 and not paused:
        xv = 1
        yv = 0
    # 40 is down arrow key
    # 77 is m key
    elif key == 77 and not paused:
        xv = 0
        yv = 1
    # 32 is pause key
    # 80 is p key
    elif key == 80:
        temp = [xv, yv]
        xv = pre_pause[0]
        yv = pre_pause[1]
        pre_pause = [*temp]
        paused = not paused
  
def show_instructions(evt):
        window.alert("keys to control: i=up, m=down, j=left, l=right, p=pause")
      
# 利用 html 建立 canvas 超文件物件
canvas = html.CANVAS(width = 600, height = 600)
canvas.id = "game-board"
brython_div = doc["brython_div"]
brython_div <= canvas
  
score_doc = html.DIV("score")
score_doc.id = "score"
brython_div <= score_doc
  
high_score_doc = html.DIV("high-score")
high_score_doc.id = "high-score"
brython_div <= high_score_doc
  
button = html.BUTTON("Keys to control")
button.id = "instructions-btn"
brython_div <= button
  
score = 0
high_score = 0
  
px = py = 10
# gs*tc = canvas width and height
gs = 20
tc = 30
ax = ay = 15
xv = yv = 0
trail = []
tail = 5
  
pre_pause = [0,0]
paused = False
ctx = canvas.getContext("2d")
doc.addEventListener("keydown", key_push)
instructions_btn = doc["instructions-btn"]
instructions_btn.addEventListener("click", show_instructions)
browser.timer.set_interval(game, 1000/15)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "snake 的按鈕點按時, 執行 Snake 物件中的 prog 方法
doc["snake"].bind('click', Snake.prog)
</script>
</p>
<!-- snake ends -->
<p></p>
<!-- sudoku starts -->
<p>
<script type="text/python3">
from browser import document as doc
# 導入位於 static 目錄下的 beditor.py 
import beditor
# 利用 beditor.py 中的 editor 類別建立案例, 對應到 kw1
Sudoku = beditor.editor("""# from https://github.com/BHoggs/sudoku-speedtest
#from timeit import default_timer as timer

board = [
    [0,0,0, 0,3,0, 0,0,0],
    [0,0,1, 0,7,6, 9,4,0],
    [0,8,0, 9,0,0, 0,0,0],

    [0,4,0, 0,0,1, 0,0,0],
    [0,2,8, 0,9,0, 0,0,0],
    [0,0,0, 0,0,0, 1,6,0],

    [7,0,0, 8,0,0, 0,0,0],
    [0,0,0, 0,0,0, 4,0,2],
    [0,9,0, 0,1,0, 3,0,0]
]

def print_board():
    global board
    for i in range(9):
        if i % 3 == 0 and i != 0:
            print ("- - - - - - - - - - -")

        for j in range(9):
            if j % 3 == 0 and j != 0:
                print("| ", end='')

            if j == 8:
                print (board[i][j])

            else:
                print (str(board[i][j]) + " ", end='')

def find_empty():
    global board
    for i in range(9):
        for j in range(9):
            if board[i][j] == 0:
                return (i, j)  # row, col

    return None


def valid(num, pos):
    global board
    # Check row
    for i in range(9):
        if board[pos[0]][i] == num and pos[1] != i:
            return False

    # Check column
    for i in range(9):
        if board[i][pos[1]] == num and pos[0] != i:
            return False

    # Check box
    box_x = pos[1] // 3
    box_y = pos[0] // 3

    for i in range(box_y*3, box_y*3 + 3):
        for j in range(box_x*3, box_x*3 + 3):
            if board[i][j] == num and (i,j) != pos:
                return False

    return True

def solve():
    global board
    find = find_empty()
    if not find:
        return True

    else:
        row, col = find
        #print ("Solving... Row: %d, Col: %d" % (row+1,col+1), end='')

    for i in range(1, 10):
        if valid(i, (row, col)):
            board[row][col] = i

            if solve():
                return True

            board[row][col] = 0

    return False


print_board()

#start = timer()
solve()
#print("")
#print("Seconds to Solve: ", timer() - start)

print ("")
print ("_____________________")
print_board()

""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "sudoku 的按鈕點按時, 執行 Sudoku 物件中的 prog 方法
doc["sudoku"].bind('click', Sudoku.prog)
</script>
</p>
<!-- sudoku ends -->
<p></p>
<!-- autosnake starts -->
<p>
<script type="text/python3">
from browser import document as doc
# 導入位於 static 目錄下的 beditor.py 
import beditor
# 利用 beditor.py 中的 editor 類別建立案例, 對應到 kw1
Autosnake = beditor.editor("""# 從 browser 導入 document 並設為 doc
from browser import document as doc
# 使用者可以透過 window 當作介面使用其他 Javascript 功能
from browser import html, window
# 用於定時執行特定函式
import browser.timer
# 導入數學模組
import math
# 導入亂數模組
from random import random, randint
 
def update_score(new_score):
    global high_score
    score_doc.innerHTML = "Score: " + str(new_score)
    if new_score > high_score:
        high_score_doc.innerHTML = "High Score: " + str(new_score)
        high_score = new_score
        
def eat(px, py, ax, ay):
    global xv, yv, pre_pause, paused
    # (px, py) go to (ax, ay) through incremented xv, yv
    if ax != px or ay != py:
        if ax > px and not paused:
            xv = 1
            yv = 0
        if ax < px and not paused:
            xv = -1
            yv = 0
        if ay > py and not paused:
            xv = 0
            yv = 1
        if ay < py and not paused:
            xv = 0
            yv = -1
            
def game():
    global px, py, tc, gs, ax, ay, trail, tail, score
    # px 為 snake 第一個點的 x 座標, 增量值為 xv
    px += xv
    py += yv
    # 允許穿越四面牆, 以 tc 表示牆面座標極限
    # 若 px 為負值則設定為 tc -1, 表示 tc 為 x 方向 limit
    # x 座標方向的穿牆設定
    if px < 0:
        px = tc-1
    if px > tc-1:
        px = 0
    # y 座標方向的穿牆設定
    if py < 0:
        py = tc-1
    if py > tc-1:
        py = 0
    ctx.fillStyle = "black"
    # 畫布填入黑色
    ctx.fillRect(0, 0, canvas.width, canvas.height)
    # snake 為 lime 色
    ctx.fillStyle = "lime"
    # trail 為數列, 代表 snake 各節 [x,y] 座標
    # trail = [[x0,y0], [x1, y1], [x2, y2]...]
    # gs 為方塊邊長 pixel 數
    for i in range(len(trail)):
        # https://developer.mozilla.org/zh-TW/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes
        # fillRect(x, y, width, height)
        ctx.fillRect(trail[i][0]*gs, trail[i][1]*gs, gs-2, gs-2)
        # 若 snake 第一節座標 (px, py)  穿過身體任一節, 則 score 歸零
        if trail[i][0] == px and trail[i][1] == py:
            score = score if paused else 0
            # snake reset 為五節
            tail = 5
    # trail 數列以碰到的 [px, py] 座標數列插入作為第一節
    trail.insert(0, [px, py])
    while len(trail) > tail:
        # pop() 內建移除數列最後一個 element
        trail.pop()
    # ax, ay 為紅點座標
    # 當 snake 第一節座標[px, py] 與紅色食物座標 [ax, ay] 重合
    # 則 tail 增量, 即多一節且得分加 1, 然後食物座標 [ax, ay] 重新以亂數定位
    if ax == px and ay == py:
        tail += 1
        ax = math.floor(random()*tc)
        ay = math.floor(random()*tc)
        score += 1
    # [ax, ay] is known here
    # [px, py] is where the head of the snake
    # xv needed to be incremented from px to ax first
    # and yv needed to be incremented from py to ay
    eat(px, py, ax, ay)
    # 更新計分顯示
    update_score(score)
    ctx.fillStyle = "red"
    ctx.fillRect(ax*gs, ay*gs, gs-2, gs-2)
   
def key_push(evt):
    global xv, yv, pre_pause, paused
    key = evt.keyCode
    # 37 is left arrow key
    # 74 is j key
    if key == 74 and not paused:
        xv = -1
        yv = 0
    # 38 is up arrow key
    # 73 is i key
    elif key == 73 and not paused:
        xv = 0
        yv = -1
    # 39 is right arrow key
    # 76 is l key
    elif key == 76 and not paused:
        xv = 1
        yv = 0
    # 40 is down arrow key
    # 77 is m key
    elif key == 77 and not paused:
        xv = 0
        yv = 1
    # 32 is pause key
    # 80 is p key
    elif key == 80:
        temp = [xv, yv]
        xv = pre_pause[0]
        yv = pre_pause[1]
        pre_pause = [*temp]
        paused = not paused
   
def show_instructions(evt):
        window.alert("keys to control: i=up, m=down, j=left, l=right, p=pause")
       
# 利用 html 建立 canvas 超文件物件
canvas = html.CANVAS(width = 600, height = 600)
canvas.id = "game-board"
brython_div = doc["brython_div"]
brython_div <= canvas
   
score_doc = html.DIV("score")
score_doc.id = "score"
brython_div <= score_doc
   
high_score_doc = html.DIV("high-score")
high_score_doc.id = "high-score"
brython_div <= high_score_doc
   
button = html.BUTTON("Keys to control")
button.id = "instructions-btn"
brython_div <= button
   
score = 0
high_score = 0
   
px = py = 10
# gs*tc = canvas width and height
gs = 20
tc = 30
ax = ay = 15
xv = yv = 0
trail = []
tail = 5
   
pre_pause = [0,0]
paused = False
ctx = canvas.getContext("2d")
doc.addEventListener("keydown", key_push)
instructions_btn = doc["instructions-btn"]
instructions_btn.addEventListener("click", show_instructions)
browser.timer.set_interval(game, 1000/15)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "autosnake 的按鈕點按時, 執行 Autosnake 物件中的 prog 方法
doc["autosnake"].bind('click', Autosnake.prog)
</script>
</p>
<!-- autosnake ends -->
<p><button id="keyword">Keyword</button><button id="ex1">Ex1</button><button id="ex2">Ex2</button><button id="ex3">Ex3</button><button id="ex4">Ex4</button><button id="forloop">Ex5</button><button id="class_ex6">Ex6</button><button id="guess">Guess</button><button id="autoguess">Autoguess</button><button id="lottery">大樂透</button><button id="weleadlottery">威力彩</button><button id="snake">貪食蛇</button><button id="autosnake">貪食蛇2</button><button id="sudoku">Sudoku</button><button id="temp">Temp</button><button id="draw">Draw</button><button id="flag">Flag</button><button id="bezier">Bezier</button><button id="clock1">clock1</button><button id="fourbar">Fourbar</button><button id="turtle1">Turtle1</button><button id="turtle2">Turtle2</button><button id="turtle3">Turtle3</button><button id="turtle4">Turtle4</button><button id="turtle5">Turtle5</button><button id="turtle6">Turtle6</button><button id="turtle7">Turtle7</button><button id="turtle8">Turtle8</button><button id="konva1">Konva1</button><button id="bunny">Bunny</button><button id="ball">Ball</button><button id="spur">Spur</button><button id="ycqsort">Ycqsort</button><button id="nfulist">nfulist</button><button id="clear">Clear</button></p>
<h4>參考資料:</h4>
<p style="padding-left: 30px;"><a href="https://docs.python.org/3/library/turtle.html">https://docs.python.org/3/library/turtle.html</a></p>
<p style="padding-left: 30px;"><a href="https://realpython.com/beginners-guide-python-turtle/">https://realpython.com/beginners-guide-python-turtle/</a></p>
<p>其他擷取程式的方式: <a href="http://mde.tw/2017springvcp/blog/web-based-python.html">http://mde.tw/2017springvcp/blog/web-based-python.html</a></p>
<h3>貪食蛇</h3>
<p><a href="https://zh.wikipedia.org/wiki/%E8%B4%AA%E9%A3%9F%E8%9B%87">貪食蛇遊戲</a></p>
<p>在遊戲中, 玩家操控一條細長的直線 (俗稱蛇或蟲), 它會不停前進, 玩家只能操控蛇的頭部朝向, 上下左右, 一路拾起觸碰到之物 (或稱作豆), 並要避免觸碰到自身或者其他障礙物. 每次貪食蛇吃掉一件食物, 它的身體便增長一段. 吃掉一些食物後會使蛇的移動速度逐漸加快, 讓遊戲的難度漸漸變大. 遊戲設計大致分為四面都有牆 (都不可穿越) 以及某部分的牆可以穿越, 以及四面牆都可以穿越的模式.</p>
<h4>網際 Brython 程式練習:</h4>
<p style="padding-left: 30px;">以下程式已經將 <a href="https://medium.com/swlh/sick-of-javascript-just-use-browser-python-4b9679efe08b">https://medium.com/swlh/sick-of-javascript-just-use-browser-python-4b9679efe08b</a> 中的範例, 改為可直接放入<a href="http://mde.tw/cp2021/content/%E8%A7%A3%E9%A1%8C%E7%B7%B4%E7%BF%92.html">解題練習</a>環境中執行.</p>
<h4 style="padding-left: 30px;">練習1:</h4>
<p style="padding-left: 60px;">請將下列程式改為以 <a href="https://github.com/mdecourse/webgame">webgame</a> 倉儲作為 template, 將程式碼轉移至獨立的網頁中運行.</p>
<h4 style="padding-left: 30px;">練習2:</h4>
<p style="padding-left: 60px;">若紅色方塊座標以亂數產生後, 電腦程式將該座標點告知貪食蛇, 請改寫下列程式, 導引貪食蛇吃下所有紅色方塊食物, 終至前進任何方向移動都無法避免碰觸身體為止.</p>
<h4>Brython 鍵盤按鍵對應編號:</h4>
<p style="padding-left: 30px;"><a href="https://brython.info/static_doc/en/keyboard_events.html">https://brython.info/static_doc/en/keyboard_events.html</a></p>
<p style="padding-left: 30px;">keydown:</p>
<p style="padding-left: 60px;">i code = 73 , up code = 38</p>
<p style="padding-left: 60px;">m code = 77, down code = 40</p>
<p style="padding-left: 60px;">j code = 74, left code = 37</p>
<p style="padding-left: 60px;">l code = 76, right code = 39</p>
<p style="padding-left: 60px;">p code = 80, pause code = 32</p>
<h4>利用 Brython 插入 html:</h4>
<p style="padding-left: 30px;">因為<a href="http://mde.tw/cp2021/content/%E8%A7%A3%E9%A1%8C%E7%B7%B4%E7%BF%92.html">解題練習</a>的網頁中已經事先建立 id="brython_div" 的 div 標註, 因此隨後可以利用此一 div, 插入其他所需要的 html 內容, 例如: 放入指定 id 名稱的 canvas 標註.</p>
<p style="padding-left: 30px;">原始的<a href="https://gist.github.com/mdecourse/3db55f124185def5aac8e5d51579c484">程式碼</a>. 總計需要:</p>
<p style="padding-left: 30px;">id = "game-board" 的 canvas 標註</p>
<p style="padding-left: 30px;">id = "score" 的 div 標註</p>
<p style="padding-left: 30px;">id = "high-score" 的 div 標註</p>
<p style="padding-left: 30px;">id= instructions-btn 的 button, 用來說明控制按鍵</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># 從 browser 導入 document 並設為 doc
from browser import document as doc
# 使用者可以透過 window 當作介面使用其他 Javascript 功能
from browser import html, window
# 用於定時執行特定函式
import browser.timer
# 導入數學模組
import math
# 導入亂數模組
from random import random, randint

def update_score(new_score):
    global high_score
    score_doc.innerHTML = "Score: " + str(new_score)
    if new_score &gt; high_score:
        high_score_doc.innerHTML = "High Score: " + str(new_score)
        high_score = new_score
    
def game():
    global px, py, tc, gs, ax, ay, trail, tail, score
    # px 為 snake 第一個點的 x 座標, 增量值為 xv
    px += xv
    py += yv
    # 允許穿越四面牆, 以 tc 表示牆面座標極限
    # 若 px 為負值則設定為 tc -1, 表示 tc 為 x 方向 limit
    # x 座標方向的穿牆設定
    if px &lt; 0:
        px = tc-1
    if px &gt; tc-1:
        px = 0
    # y 座標方向的穿牆設定
    if py &lt; 0:
        py = tc-1
    if py &gt; tc-1:
        py = 0
    ctx.fillStyle = "black"
    # 畫布填入黑色
    ctx.fillRect(0, 0, canvas.width, canvas.height)
    # snake 為 lime 色
    ctx.fillStyle = "lime"
    # trail 為數列, 代表 snake 各節 [x,y] 座標
    # trail = [[x0,y0], [x1, y1], [x2, y2]...]
    # gs 為方塊邊長 pixel 數
    for i in range(len(trail)):
        # https://developer.mozilla.org/zh-TW/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes
        # fillRect(x, y, width, height)
        ctx.fillRect(trail[i][0]*gs, trail[i][1]*gs, gs-2, gs-2)
        # 若 snake 第一節座標 (px, py)  穿過身體任一節, 則 score 歸零
        if trail[i][0] == px and trail[i][1] == py:
            score = score if paused else 0
            # snake reset 為五節
            tail = 5
    # trail 數列以碰到的 [px, py] 座標數列插入作為第一節
    trail.insert(0, [px, py])
    while len(trail) &gt; tail:
        # pop() 內建移除數列最後一個 element
        trail.pop()
    # ax, ay 為紅點座標
    # 當 snake 第一節座標[px, py] 與紅色食物座標 [ax, ay] 重合
    # 則 tail 增量, 即多一節且得分加 1, 然後食物座標 [ax, ay] 重新以亂數定位
    if ax == px and ay == py:
        tail += 1
        # 請注意, 這裡所產生的 (ax, ay) 並沒有避開 snake 身體所佔據的座標點. 假如要合理考慮此點, 程式該如何修改?
        ax = math.floor(random()*tc)
        ay = math.floor(random()*tc)
        score += 1
    # 更新計分顯示
    update_score(score)
    ctx.fillStyle = "red"
    ctx.fillRect(ax*gs, ay*gs, gs-2, gs-2)
  
def key_push(evt):
    global xv, yv, pre_pause, paused
    key = evt.keyCode
    # 37 is left arrow key
    # 74 is j key
    if key == 74 and not paused:
        xv = -1
        yv = 0
    # 38 is up arrow key
    # 73 is i key
    elif key == 73 and not paused:
        xv = 0
        yv = -1
    # 39 is right arrow key
    # 76 is l key
    elif key == 76 and not paused:
        xv = 1
        yv = 0
    # 40 is down arrow key
    # 77 is m key
    elif key == 77 and not paused:
        xv = 0
        yv = 1
    # 32 is pause key
    # 80 is p key
    elif key == 80:
        temp = [xv, yv]
        xv = pre_pause[0]
        yv = pre_pause[1]
        pre_pause = [*temp]
        paused = not paused
  
def show_instructions(evt):
        window.alert("keys to control: i=up, m=down, j=left, l=right, p=pause")
      
# 利用 html 建立 canvas 超文件物件
canvas = html.CANVAS(width = 600, height = 600)
canvas.id = "game-board"
brython_div = doc["brython_div"]
brython_div &lt;= canvas
  
score_doc = html.DIV("score")
score_doc.id = "score"
brython_div &lt;= score_doc
  
high_score_doc = html.DIV("high-score")
high_score_doc.id = "high-score"
brython_div &lt;= high_score_doc
  
button = html.BUTTON("Keys to control")
button.id = "instructions-btn"
brython_div &lt;= button
  
score = 0
high_score = 0
  
px = py = 10
# gs*tc = canvas width and height
gs = 20
tc = 30
ax = ay = 15
xv = yv = 0
trail = []
tail = 5
  
pre_pause = [0,0]
paused = False
ctx = canvas.getContext("2d")
doc.addEventListener("keydown", key_push)
instructions_btn = doc["instructions-btn"]
instructions_btn.addEventListener("click", show_instructions)
browser.timer.set_interval(game, 1000/15)</pre>
<!-- 以下插入貪食蛇自動執行程式 -->
<p></p>
<!-- 導入 brython -->
<p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
</p>
<p></p>
<!-- 啟動 brython -->
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/']});
}
</script>
</p>
<!-- brython webgl div -->
<div id="brython_div"></div>
<p></p>
<!-- 執行貪食蛇遊戲 -->
<p>
<script type="text/python3">
# 從 browser 導入 document 並設為 doc
from browser import document as doc
# 使用者可以透過 window 當作介面使用其他 Javascript 功能
from browser import html, window
# 用於定時執行特定函式
import browser.timer
# 導入數學模組
import math
# 導入亂數模組
from random import random, randint
 
def update_score(new_score):
    global high_score
    score_doc.innerHTML = "Score: " + str(new_score)
    if new_score > high_score:
        high_score_doc.innerHTML = "High Score: " + str(new_score)
        high_score = new_score
        
def eat(px, py, ax, ay):
    global xv, yv, pre_pause, paused
    # (px, py) go to (ax, ay) through incremented xv, yv
    if ax != px or ay != py:
        if ax > px and not paused:
            xv = 1
            yv = 0
        if ax < px and not paused:
            xv = -1
            yv = 0
        if ay > py and not paused:
            xv = 0
            yv = 1
        if ay < py and not paused:
            xv = 0
            yv = -1
            
def game():
    global px, py, tc, gs, ax, ay, trail, tail, score
    # px 為 snake 第一個點的 x 座標, 增量值為 xv
    px += xv
    py += yv
    # 允許穿越四面牆, 以 tc 表示牆面座標極限
    # 若 px 為負值則設定為 tc -1, 表示 tc 為 x 方向 limit
    # x 座標方向的穿牆設定
    if px < 0:
        px = tc-1
    if px > tc-1:
        px = 0
    # y 座標方向的穿牆設定
    if py < 0:
        py = tc-1
    if py > tc-1:
        py = 0
    ctx.fillStyle = "black"
    # 畫布填入黑色
    ctx.fillRect(0, 0, canvas.width, canvas.height)
    # snake 為 lime 色
    ctx.fillStyle = "lime"
    # trail 為數列, 代表 snake 各節 [x,y] 座標
    # trail = [[x0,y0], [x1, y1], [x2, y2]...]
    # gs 為方塊邊長 pixel 數
    for i in range(len(trail)):
        # https://developer.mozilla.org/zh-TW/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes
        # fillRect(x, y, width, height)
        ctx.fillRect(trail[i][0]*gs, trail[i][1]*gs, gs-2, gs-2)
        # 若 snake 第一節座標 (px, py)  穿過身體任一節, 則 score 歸零
        if trail[i][0] == px and trail[i][1] == py:
            score = score if paused else 0
            # snake reset 為五節
            tail = 5
    # trail 數列以碰到的 [px, py] 座標數列插入作為第一節
    trail.insert(0, [px, py])
    while len(trail) > tail:
        # pop() 內建移除數列最後一個 element
        trail.pop()
    # ax, ay 為紅點座標
    # 當 snake 第一節座標[px, py] 與紅色食物座標 [ax, ay] 重合
    # 則 tail 增量, 即多一節且得分加 1, 然後食物座標 [ax, ay] 重新以亂數定位
    if ax == px and ay == py:
        tail += 1
        ax = math.floor(random()*tc)
        ay = math.floor(random()*tc)
        score += 1
    # [ax, ay] is known here
    # [px, py] is where the head of the snake
    # xv needed to be incremented from px to ax first
    # and yv needed to be incremented from py to ay
    eat(px, py, ax, ay)
    # 更新計分顯示
    update_score(score)
    ctx.fillStyle = "red"
    ctx.fillRect(ax*gs, ay*gs, gs-2, gs-2)
   
def key_push(evt):
    global xv, yv, pre_pause, paused
    key = evt.keyCode
    # 37 is left arrow key
    # 74 is j key
    if key == 74 and not paused:
        xv = -1
        yv = 0
    # 38 is up arrow key
    # 73 is i key
    elif key == 73 and not paused:
        xv = 0
        yv = -1
    # 39 is right arrow key
    # 76 is l key
    elif key == 76 and not paused:
        xv = 1
        yv = 0
    # 40 is down arrow key
    # 77 is m key
    elif key == 77 and not paused:
        xv = 0
        yv = 1
    # 32 is pause key
    # 80 is p key
    elif key == 80:
        temp = [xv, yv]
        xv = pre_pause[0]
        yv = pre_pause[1]
        pre_pause = [*temp]
        paused = not paused
   
def show_instructions(evt):
        window.alert("keys to control: i=up, m=down, j=left, l=right, p=pause")
       
# 利用 html 建立 canvas 超文件物件
canvas = html.CANVAS(width = 600, height = 600)
canvas.id = "game-board"
brython_div = doc["brython_div"]
brython_div <= canvas
   
score_doc = html.DIV("score")
score_doc.id = "score"
brython_div <= score_doc
   
high_score_doc = html.DIV("high-score")
high_score_doc.id = "high-score"
brython_div <= high_score_doc
   
button = html.BUTTON("Keys to control")
button.id = "instructions-btn"
brython_div <= button
   
score = 0
high_score = 0
   
px = py = 10
# gs*tc = canvas width and height
gs = 20
tc = 30
ax = ay = 15
xv = yv = 0
trail = []
tail = 5
   
pre_pause = [0,0]
paused = False
ctx = canvas.getContext("2d")
doc.addEventListener("keydown", key_push)
instructions_btn = doc["instructions-btn"]
instructions_btn.addEventListener("click", show_instructions)
browser.timer.set_interval(game, 1000/15)
</script>
</p>
<!-- 以上為貪食蛇自動執行程式 -->
<h4>References:</h4>
<p style="padding-left: 30px;"><a href="/downloads/Greedy Best First Search in Automated Snake Game Solvers.pdf">Greedy Best First Search in Automated Snake Game Solvers.pdf</a></p>
<p style="padding-left: 60px;"><a href="https://github.com/mdecourse/snake-bot">https://github.com/mdecourse/snake-bot</a></p>
<p style="padding-left: 60px;"><a href="/downloads/py/snake_bot.py">snake_bot.py</a></p>
<h4 style="padding-left: 30px;">Snake in Pygame:</h4>
<p style="padding-left: 60px;"><a href="https://github.com/mdecourse/python_projects">https://github.com/mdecourse/python_projects</a> (<a href="https://www.youtube.com/watch?v=8dfePlONtls">Tutorial Video</a>)</p>
<h4>全自動或導引連結車 (fully automated or guided tractor)應用:</h4>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/V0OORhwtibQ" title="YouTube video player" width="560"></iframe></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/feAmPDIIZDg" title="YouTube video player" width="560"></iframe></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/zEBItNdBbgQ" title="YouTube video player" width="560"></iframe></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/LXuUThQOHAU" title="YouTube video player" width="560"></iframe></p>
<h3>期中專案</h3>
<p>這個計算機程式<span style="background-color: #ffff99;">個人專案</span>將從 Week1-Week7 期間執行, 並在 Week8-Week9 採網際簡報 (<a href="https://revealjs.com/">Reveal.js</a>) 與 OBS + Youtube 直播並錄影方式發表.</p>
<h4>個人專案 template:</h4>
<p style="padding-left: 30px;"><a href="https://github.com/mdecourse/webgame">https://github.com/mdecourse/webgame</a></p>
<h4>利用 <a href="https://brython.info/">Brython</a> 程式庫 <a href="https://github.com/mdecourse/ggame">ggame</a> 來開發網際遊戲或設計模擬程式:</h4>
<p style="padding-left: 30px;"><a href="https://mdecourse.github.io/webgame/bs.html" rel="nofollow">https://mdecourse.github.io/webgame/bs.html</a></p>
<p style="padding-left: 30px;"><a href="https://mdecourse.github.io/webgame/bunny.html" rel="nofollow">https://mdecourse.github.io/webgame/bunny.html</a></p>
<p style="padding-left: 30px;"><a href="https://mdecourse.github.io/webgame/spacewar.html" rel="nofollow">https://mdecourse.github.io/webgame/spacewar.html</a></p>
<h4>Brython documentation:</h4>
<p style="padding-left: 30px;"><a href="https://brython.info/static_doc/en/intro.html">https://brython.info/static_doc/en/intro.html</a></p>
<h4>ggame documentation:</h4>
<p style="padding-left: 30px;"><a href="https://ggame.readthedocs.io/en/latest/index.html">https://ggame.readthedocs.io/en/latest/index.html</a></p>
<p><a href="http://mde.tw/cp2021/downloads/ggame-readthedocs-io-en-latest.pdf">http://mde.tw/cp2021/downloads/ggame-readthedocs-io-en-latest.pdf</a></p>
<h4>參考資料:</h4>
<p style="padding-left: 30px;"><a href="https://link.springer.com/book/10.1007/978-1-4302-4717-3">Foundation Game Design with HTML5 and JavaScript</a> (校園網路下載電子書)</p>
<p style="padding-left: 30px;"><a href="https://link.springer.com/book/10.1007/978-1-4302-5801-8">Advanced Game Design with HTML5 and JavaScript</a> (校園網路下載電子書)</p>
<p style="padding-left: 30px;"><a href="https://link.springer.com/book/10.1007/978-1-4842-3252-1">Introducing JavaScript Game Development</a> (校園網路下載電子書)</p>
<p style="padding-left: 30px;"><a href="https://link.springer.com/book/10.1007/978-1-4302-6338-8">Physics for JavaScript Games, Animation, and Simulations</a> (校園網路下載電子書)</p>
<p style="padding-left: 30px;"><a href="https://link.springer.com/book/10.1007/978-1-4302-6539-9">Building JavaScript Games</a> (校園網路下載電子書)</p>
<p style="padding-left: 30px;"><a href="https://link.springer.com/book/10.1007/978-1-4842-0952-3">Build Your Own 2D Game Engine and Create Great Web Games</a> (校園網路下載電子書)</p>
<p style="padding-left: 30px;"><a href="https://link.springer.com/book/10.1007/978-1-4842-2583-7">Building a 2D Game Physics Engine</a> (校園網路下載電子書)</p>
<h2>ggame</h2>
<p>參考的網際程式庫: <a href="https://github.com/mdecourse/ggame">https://github.com/mdecourse/ggame</a>, 使用說明: <a href="https://ggame.readthedocs.io/en/latest/index.html">https://ggame.readthedocs.io/en/latest/index.html</a></p>
<p>由於此 ggame 程式庫使用</p>
<p>jquery-3.3.1.min.js - <a href="https://jquery.com/">https://jquery.com/</a> <br/>jquery-ui.1.12.1.min.js - <a href="https://jqueryui.com/">https://jqueryui.com/</a> <br/>pixi-4.8.2.min.js - <a href="http://www.pixijs.com/">http://www.pixijs.com/</a> <br/>buzz-1.2.1.js - <a href="http://buzz.jaysalvat.com/">http://buzz.jaysalvat.com/</a> <br/>brython-3.7.0.js - <a href="https://brython.info/">https://brython.info/</a> <br/>brython_stdlib-3.7.0.js</p>
<p>因此使用者必須對上述程式庫有些了解後, 再深入研究如何使用  ggame 程式庫開發專案套件.</p>
<h4>參考資料:</h4>
<p style="padding-left: 30px;"><a href="https://github.com/Runpython-IntroProgramming/Course-Syllabus/wiki">https://github.com/Runpython-IntroProgramming/Course-Syllabus/wiki</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/Runpython-IntroProgramming">https://github.com/Runpython-IntroProgramming</a></p>
<h4>module_exists</h4>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># ggame source code
# prepared for cp2021
def module_exists(module_name):
    try:
        __import__(module_name)
    except ImportError:
        return False
    else:
        return True

if module_exists('browser') and module_exists('javascript'):

    from browser import window, document
    #from javascript import JSObject, JSConstructor

    # 利用 Brython browser 模組中的 window 物件導入  PIXI Javascript 程式庫
    # 其中 JSObject 可以直接透過 window 導入 Javascript function
    # JSConstructor 則用來轉換 class 物件
    GFX = window.PIXI
    GFX_Rectangle = GFX.Rectangle.new
    GFX_Texture = GFX.Texture.new
    GFX_Texture_fromImage = GFX.Texture.fromImage.new
    GFX_Sprite = GFX.Sprite.new
    GFX_Graphics = GFX.Graphics.new()
    GFX_Text = GFX.Text.new
    # need to check with PIXI source code for autoDetectRender
    GFX_DetectRenderer = GFX.autoDetectRenderer
    # 利用 JSObject 以及 window 導入 buzz.js
    SND = window.buzz
    SND_Sound = SND.sound.new
    
    class GFX_Window(object):
    
        def __init__(self, width, height, onclose):
            # 假如要執行時額外跳出一個視窗
            #self._w = window.open("", "")
            # 在原先的視窗中執行
            self._w = window
            self._stage = GFX.Container.new()
            self.width = width if width != 0 else int(window.innerWidth * 0.9)
            self.height = height if height != 0 else int(window.innerHeight * 0.9)
            self._renderer = GFX.autoDetectRenderer(self.width, self.height, {'transparent':True})
            self._w.document.body.appendChild(self._renderer.view)
            self._w.onunload = onclose
  
        def bind(self, evtspec, callback):
            self._w.document.body.bind(evtspec, callback)
      
        def add(self, obj):
            self._stage.addChild(obj)
        
        def remove(self, obj):
            self._stage.removeChild(obj)
        
        def animate(self, stepcallback):
            self._renderer.render(self._stage)
            self._w.requestAnimationFrame(stepcallback)
        
        def destroy(self):
            SND.all().stop()
            self._stage.destroy()

</pre>
<h4>class App</h4>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">class App(object):
    """
    The `ggame.App` class is a (typically subclassed) class that encapsulates
    handling of the display system, and processing user events. The `ggame.App` 
    class also manages lists of all `ggame.Sprite` instances in the application.

    When subclassing `ggame.App` you may elect to instantiate most of your
    sprite objects in the initialization section.

    Processing that must occur on a per-frame basis may be included by overriding
    the `ggame.App.step` method. This is also an appropriate location to call
    similar 'step' methods for your various customized sprite classes.

    Once your application class has been instantiated, begin the frame drawing
    process by calling its `ggame.App.run` method.

    NOTE: Only **one** instance of an `ggame.App` class or subclass may be 
    instantiated at a time.
    """
    spritelist = []
    """List of all sprites currently active in the application."""
    _eventdict = {}
    _spritesdict = {}
    _spritesadded = False
    _win = None

    def __init__(self, *args):
        """
        The `ggame.App` class is called either by specifying the desired app window size
        in pixels, as two parameters (e.g. `myapp = App(640,480)`), or by providing
        no size parameters at all (e.g. `myapp = App()`), in which case, the full browser
        window size is used.
        """
        if App._win == None and (len(args) == 0 or len(args) == 2):
            x = y = 0
            if len(args) == 2:
                x = args[0]
                y = args[1]
            App._win = GFX_Window(x, y, App._destroy)
            self.width = App._win.width
            self.height = App._win.height
            # Add existing sprites to the window
            if not App._spritesadded and len(App.spritelist) &gt; 0:
                App._spritesadded = True
                for sprite in App.spritelist:
                    App._win.add(sprite.GFX)
            App._win.bind(KeyEvent.keydown, self._keyEvent)
            App._win.bind(KeyEvent.keyup, self._keyEvent)
            App._win.bind(KeyEvent.keypress, self._keyEvent)
            App._win.bind(MouseEvent.mousewheel, self._mouseEvent)
            App._win.bind(MouseEvent.mousemove, self._mouseEvent)
            App._win.bind(MouseEvent.mousedown, self._mouseEvent)
            App._win.bind(MouseEvent.mouseup, self._mouseEvent)
            App._win.bind(MouseEvent.click, self._mouseEvent)
            App._win.bind(MouseEvent.dblclick, self._mouseEvent)

        
    def _routeEvent(self, event, evtlist):
        for callback in reversed(evtlist):
            if not event.consumed:
                callback(event)
        
    def _keyEvent(self, hwevent):
        evtlist = App._eventdict.get(
            (hwevent.type, KeyEvent.keys.get(hwevent.keyCode,0)), [])
        evtlist.extend(App._eventdict.get((hwevent.type, '*'), []))
        if len(evtlist) &gt; 0:
            evt = KeyEvent(hwevent)
            self._routeEvent(evt, evtlist)

    def _mouseEvent(self, hwevent):
        evtlist = App._eventdict.get(hwevent.type, [])
        if len(evtlist) &gt; 0:
            evt = MouseEvent(hwevent)
            self._routeEvent(evt, evtlist)

    @classmethod
    def _add(cls, obj):
        if App._win != None:
            App._win.add(obj.GFX)
        App.spritelist.append(obj)
        if type(obj) not in App._spritesdict:
            App._spritesdict[type(obj)] = []
        App._spritesdict[type(obj)].append(obj)

    @classmethod
    def _remove(cls, obj):
        if App._win != None:
            App._win.remove(obj.GFX)
        App.spritelist.remove(obj)
        App._spritesdict[type(obj)].remove(obj)
        
    def _animate(self, dummy):
        if self.userfunc:
            self.userfunc()
        else:
            self.step()
        App._win.animate(self._animate)

    @classmethod
    def _destroy(cls, *args):
        """
        This will close the display window/tab, remove all references to 
        sprites and place the `App` class in a state in which a new 
        application could be instantiated.
        """ 
        App._win.destroy()
        App._win = None
        for s in list(App.spritelist):
            s.destroy()
        App.spritelist = []
        App._spritesdict = {}
        App._eventdict = {}
        App._spritesadded = False

    @classmethod
    def listenKeyEvent(cls, eventtype, key, callback):
        """
        Register to receive keyboard events. The `eventtype` parameter is a 
        string that indicates what type of key event to receive (value is one
        of: `'keydown'`, `'keyup'` or `'keypress'`). The `key` parameter is a 
        string indicating which key (e.g. `'space'`, `'left arrow'`, etc.) to 
        receive events for. The `callback` parameter is a reference to a 
        function or method that will be called with the `ggame.KeyEvent` object
        when the event occurs.

        See the source for `ggame.KeyEvent.keys` for a list of key names
        to use with the `key` paramter.
        """
        evtlist = App._eventdict.get((eventtype, key), [])
        evtlist.append(callback)
        App._eventdict[(eventtype, key)] = evtlist

    @classmethod
    def listenMouseEvent(cls, eventtype, callback):
        """
        Register to receive mouse events. The `eventtype` parameter is
        a string that indicates what type of mouse event to receive (
        value is one of: `'mousemove'`, `'mousedown'`, `'mouseup'`, `'click'`, 
        `'dblclick'` or `'mousewheel'`). The `callback` parameter is a 
        reference to a function or method that will be called with the 
        `ggame.MouseEvent` object when the event occurs.
        """
        evtlist = App._eventdict.get(eventtype, [])
        evtlist.append(callback)
        App._eventdict[eventtype] = evtlist

    @classmethod
    def unlistenKeyEvent(cls, eventtype, key, callback):
        """
        Use this method to remove a registration to receive a particular
        keyboard event. Arguments must exactly match those used when
        registering for the event.
        """
        App._eventdict[(eventtype,key)].remove(callback)

    @classmethod
    def unlistenMouseEvent(cls, eventtype, callback):
        """
        Use this method to remove a registration to receive a particular
        mouse event. Arguments must exactly match those used when
        registering for the event.
        """
        App._eventdict[eventtype].remove(callback)

    @classmethod
    def getSpritesbyClass(cls, sclass):
        """
        Returns a list of all active sprites of a given class.
        """
        return App._spritesdict.get(sclass, [])
        
    def step(self):
        """
        The `ggame.App.step` method is called once per animation frame. Override
        this method in your own subclass of `ggame.App` to perform periodic 
        calculations, such as checking for sprite collisions, or calling
        'step' functions in your own customized sprite classes.

        The base class `ggame.App.step` method is empty and is intended to be overriden.
        """
        pass

    def run(self, userfunc = None):
        """
        Calling the `ggame.App.run` method begins the animation process whereby the 
        `ggame.App.step` method is called once per animation frame.
        """
        self.userfunc = userfunc
        App._win.animate(self._animate)
</pre>
<h4>class Sprite</h4>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">class Sprite(object):
    """
    The `ggame.Sprite` class combines the idea of a visual/graphical asset, a
    position on the screen, and *behavior*. Although the `ggame.Sprite` can be
    used as-is, it is generally subclassed to give it the desired behavior.

    When subclassing the `ggame.Sprite` class, you may customize the initialization
    code to use a specific asset. A 'step' or 'poll' method may be added
    for handling per-frame actions (e.g. checking for collisions). Step or poll
    functions are not automatically called by the `ggame.App` class, but you
    may subclass the `ggame.App` class in order to do this.

    Furthermore, you may wish to define event callback methods in your customized
    sprite class. With customized creation, event handling, and periodic processing
    you can achieve fully autonomous behavior for your class. 
    """
 
    _rectCollision = "rect"
    _circCollision = "circ"
    
    def __init__(self, asset, pos=(0,0)):
        """
        The `ggame.Sprite` must be created with an existing graphical `asset`.
        An optional `pos` or position may be provided, which specifies the 
        starting (x,y) coordinates of the sprite on the screen. By default,
        the position of a sprite defines the location of its upper-left hand
        corner. This behavior can be modified by customizing the `center` of
        the sprite.

        Example: player = Sprite(ImageAsset("player.png", (100,100))
        """
        self._index = 0
        if type(asset) == ImageAsset:
            self.asset = asset
            try:
                #self.GFX = GFX_Sprite()
                self.GFX = GFX_Sprite(asset.GFX) # GFX is PIXI Sprite
            except:
                self.GFX = None
        elif type(asset) in [RectangleAsset, 
            CircleAsset, 
            EllipseAsset, 
            PolygonAsset,
            LineAsset,
            ]:
            self.asset = asset
            self.GFX = asset.GFX.clone() # GFX is PIXI Graphics (from Sprite)
            self.GFX.visible = True
        elif type(asset) in [TextAsset]:
            self.asset = asset._clone()
            self.GFX = self.asset.GFX # GFX is PIXI Text (from Sprite)
            self.GFX.visible = True
        self.position = pos
        """Tuple indicates the position of the sprite on the screen."""
        self._setExtents()
        self.rectangularCollisionModel()
        App._add(self)
        
    def _setExtents(self):
        """
        update min/max x and y based on position, center, width, height
        """
        self.xmin = int(self.x - self.fxcenter * self.width)
        self.xmax = int(self.x + (1 - self.fxcenter) * self.width)
        self.ymin = int(self.y - self.fycenter * self.height)
        self.ymax = int(self.y + (1 - self.fycenter) * self.height)
        self.radius = int((self.width + self.height)/4)
        #self.xcenter = int(self.x + (1 - self.fxcenter) * self.width / 2)
        #self.ycenter = int(self.y + (1 - self.fycenter) * self.height / 2)

    def firstImage(self):
        """
        Select and display the *first* image used by this sprite.
        """
        self.GFX.texture = self.asset[0]

    def lastImage(self):
        """
        Select and display the *last* image used by this sprite.
        """
        self.GFX.texture = self.asset[-1]

    def nextImage(self, wrap = False):
        """
        Select and display the *next* image used by this sprite.
        If the current image is already the *last* image, then
        the image is not advanced.

        If the optional `wrap` parameter is set to `True`, then calling
        `ggame.Sprite.nextImage` on the last image will cause the *first*
        image to be loaded.
        """
        self._index += 1
        if self._index &gt;= len(self.asset):
            if wrap:
                self._index = 0
            else:
                self._index = len(self.asset)-1
        self.GFX.texture = self.asset[self._index]

    def prevImage(self, wrap = False):
        """
        Select and display the *previous* image used by this sprite.
        If the current image is already the *first* image, then
        the image is not changed.

        If the optional `wrap` parameter is set to `True`, then calling
        `ggame.Sprite.prevImage` on the first image will cause the *last*
        image to be loaded.
        """
        self._index -= 1
        if self._index &lt; 0:
            if wrap:
                self._index = len(self.asset)-1
            else:
                self._index = 0
        self.GFX.texture = self.asset[self._index]

    def setImage(self, index=0):
        """
        Select the image to display by giving its `index`, where an index
        of zero represents the *first* image in the asset.

        This is equivalent to setting the `ggame.Sprite.index` property
        directly.
        """
        self.index = index

    def rectangularCollisionModel(self):
        """
        Calling this method will configure the sprite to use a simple 
        rectangular collision model when checking for overlap with 
        other sprites. In this model, the "collideable" area of the sprite
        is equal to the rectangle of the asset image. If the sprite asset
        image includes a large transparent margin, this may cause the 
        collision box to be larger than desired.
        """
        self._collisionStyle = type(self)._rectCollision

    def circularCollisionModel(self):
        """
        Calling the sprite's `ggame.Sprite.circularCollisionModel` method 
        will configure the sprite to use a simple circular collision model 
        when checking for overlap with other sprites. In this model, the
        "collideable" area of the sprite is regarded as a circle whose
        diameter is equal to the mean of the width and height of the 
        asset image.
        """
        self._collisionStyle = type(self)._circCollision

    @property
    def index(self):
        """This is an integer index in to the list of images available for this sprite."""
        return self._index
        
    @index.setter
    def index(self, value):
        self._index = value
        try:
            self.GFX.texture = self.asset[self._index]
        except:
            self._index = 0
            self.GFX.texture = self.asset[self._index]

    @property
    def width(self):
        """
        This is an integer representing the display width of the sprite.
        Assigning a value to the width will scale the image horizontally.
        """
        return self.GFX.width
        
    @width.setter
    def width(self, value):
        self.GFX.width = value
        self._setExtents()

    @property
    def height(self):
        """
        This is an integer representing the display height of the sprite.
        Assigning a value to the height will scale the image vertically.
        """
        return self.GFX.height

    @height.setter
    def height(self, value):
        self.GFX.height = value
        self._setExtents()
        
    @property
    def x(self):
        """
        This represents the x-coordinate of the sprite on the screen. Assigning
        a value to this attribute will move the sprite horizontally.
        """
        return self.GFX.position.x
        
    @x.setter
    def x(self, value):
        self.GFX.position.x = value
        self._setExtents()
        
    @property
    def y(self):
        """
        This represents the y-coordinate of the sprite on the screen. Assigning
        a value to this attribute will move the sprite vertically.
        """
        return self.GFX.position.y
        
    @y.setter
    def y(self, value):
        self.GFX.position.y = value
        self._setExtents()

    @property
    def position(self):
        """
        This represents the (x,y) coordinates of the sprite on the screen. Assigning
        a value to this attribute will move the sprite to the new coordinates.
        """
        return (self.GFX.position.x, self.GFX.position.y)
        
    @position.setter
    def position(self, value):
        self.GFX.position.x = value[0]
        self.GFX.position.y = value[1]
        self._setExtents()
        
    @property
    def fxcenter(self):
        """
        This represents the horizontal position of the sprite "center", as a floating
        point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
        of the sprite refers to its left hand edge. A value of 1.0 refers to its 
        right hand edge. Any value in between may be specified. Values may be assigned
        to this attribute. 
        """
        try:
            return self.GFX.anchor.x
            self._setExtents()
        except:
            return 0.0
        
    @fxcenter.setter
    def fxcenter(self, value):
        """
        Float: 0-1
        """
        try:
            self.GFX.anchor.x = value
            self._setExtents()
        except:
            pass
        
    @property
    def fycenter(self):
        """
        This represents the vertical position of the sprite "center", as a floating
        point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
        of the sprite refers to its top edge. A value of 1.0 refers to its 
        bottom edge. Any value in between may be specified. Values may be assigned
        to this attribute. 
        """
        try:
            return self.GFX.anchor.y
        except:
            return 0.0
        
    @fycenter.setter
    def fycenter(self, value):
        """
        Float: 0-1
        """
        try:
            self.GFX.anchor.y = value
            self._setExtents()
        except:
            pass

    @property
    def center(self):
        """
        This attribute represents the horizontal and vertical position of the 
        sprite "center" as a tuple of floating point numbers. See the 
        descriptions for `ggame.Sprite.fxcenter` and `ggame.Sprite.fycenter` for 
        more details.
        """
        try:
            return (self.GFX.anchor.x, self.GFX.anchor.y)
        except:
            return (0.0, 0.0)
        
    @center.setter
    def center(self, value):
        try:
            self.GFX.anchor.x = value[0]
            self.GFX.anchor.y = value[1]
            self._setExtents()
        except:
            pass

    @property
    def visible(self):
        """
        This boolean attribute may be used to change the visibility of the sprite. Setting
        `ggame.Sprite.visible` to `False` will prevent the sprite from rendering on the 
        screen.
        """
        return self.GFX.visible

    @visible.setter
    def visible(self, value):
        self.GFX.visible = value

    @property
    def scale(self):
        """
        This attribute may be used to change the size of the sprite ('scale' it) on the 
        screen. Value may be a floating point number. A value of 1.0 means that the sprite
        image will keep its original size. A value of 2.0 would double it, etc.
        """
        return self.GFX.scale.x
        
    @scale.setter
    def scale(self, value):
        self.GFX.scale.x = value
        self.GFX.scale.y = value
        self._setExtents()

    @property
    def rotation(self):
        """
        This attribute may be used to change the rotation of the sprite on the screen.
        Value may be a floating point number. A value of 0.0 means no rotation. A value 
        of 1.0 means  a rotation of 1 radian in a counter-clockwise direction. One radian
        is 180/pi or approximately 57.3 degrees.
        """
        return -self.GFX.rotation
        
    @rotation.setter
    def rotation(self, value):
        self.GFX.rotation = -value

    def collidingWith(self, obj):
        """
        Return a boolean True if this sprite is currently overlapping the sprite 
        referenced by `obj`. Uses the collision model specified (rectangular, by 
        default). Collision/overlap decision is based purely on the overall, gross
        dimensions of the image rectangle. There is no attempt to verify that 
        non-transparent pixels in one sprite are actually overlapping visible
        pixels in another.
        """
        if self is obj:
            return False
        elif self._collisionStyle == obj._collisionStyle == type(self)._circCollision:
            dist2 = (self.x - obj.x)**2 + (self.y - obj.y)**2
            return dist2 &lt; (self.radius + obj.radius)**2
        else:
            return (not (self.xmin &gt; obj.xmax
                or self.xmax &lt; obj.xmin
                or self.ymin &gt; obj.ymax
                or self.ymax &lt; obj.ymin))

    def collidingWithSprites(self, sclass = None):
        """
        Return a list of sprite objects identified by the `sclass` parameter
        that are currently colliding with (that is, with which the `ggame.Sprite.collidingWith`
        method returns True) this sprite. If `sclass` is set to `None` (default), then
        all other sprites are checked for collision, otherwise, only sprites whose
        class matches `sclass` are checked.
        """
        if sclass is None:
            slist = App.spritelist
        else:
            slist = App.getSpritesbyClass(sclass)
        return list(filter(self.collidingWith, slist))

    def destroy(self):
        """
        Call the `ggame.Sprite.destroy` method to prevent the sprite from being displayed,
        or checked in collision detection. If you only want to prevent a sprite from being
        displayed, set the `ggame.Sprite.visible` attribute to `False`.
        """
        App._remove(self)
        self.GFX.destroy()

</pre>
<h4>class Frame</h4>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">class Frame(object):
    """
    Frame is a utility class for expressing the idea of a rectangular region.
    """
    
    def __init__(self, x, y, w, h):
        """
        Initialization for the `ggame.Frame` objects.

        `x` and `y` are coordinates of the upper left hand corner of the frame.
     
        `w` and `h` are the width and height of the frame rectangle.
        """

        self.GFX = GFX_Rectangle(x,y,w,h)
        """
        `GFX` is a reference to the underlying object provided by the system.
        """
        self.x = x
        """
        X-coordinate of the upper left hand corner of this `ggame.Frame`.
        """
        self.y = y
        """
        Y-coordinate of the upper left hand corner of this `ggame.Frame`.
        """
        self.w = w
        """
        Width of the `ggame.Frame`.
        """
        self.h = h
        """
        Height of the `ggame.Frame`.
        """

    @property
    def x(self):
        return self.GFX.x

    @x.setter
    def x(self, value):
        self.GFX.x = value
        
    @property
    def y(self):
        return self.GFX.y

    @y.setter
    def y(self, value):
        self.GFX.y = value

    @property
    def w(self):
        return self.GFX.width

    @w.setter
    def w(self, value):
        self.GFX.width = value
        
    @property
    def h(self):
        return self.GFX.height
        
    @h.setter
    def h(self, value):
        self.GFX.height = value

    @property
    def center(self):
        """
        `center` property computes a coordinate pair (tuple) for the 
        center of the frame.

        The `center` property, when set, redefines the `x` and `y` properties
        of the frame in order to make the center agree with the coordinates
        (tuple) assigned to it.
        """

        return (self.x + self.w//2, self.y + self.h//2)

    @center.setter
    def center(self, value):
        c = self.center
        self.x += value[0] - c[0]
        self.y += value[1] - c[1]</pre>
<h4>class _Asset</h4>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">class _Asset(object):
    """
    Base class for all game asset objects.
    
    The `ggame.Asset` class is set up to understand the concept
    of multiple instances of an asset. This is currently only used for image-based
    assets.
    """

    def __init__(self):
        self.GFXlist = [None,]
        """A list of the underlying system objects used to represent this asset."""

    @property
    def GFX(self):
        """
        `GFX` property represents the underlying system object used to represent
        this asset. If this asset is composed of multiple assets, then the **first**
        asset is referenced by `GFX`.
        """
        return self.GFXlist[0]
        
    @GFX.setter
    def GFX(self, value):
        self.GFXlist[0] = value
        
    def __len__(self):
        return len(self.GFXlist)
        
    def __getitem__(self, key):
        return self.GFXlist[key]
        
    def __setitem__(self, key, value):
        self.GFXlist[key] = value
        
    def __iter__(self):
        class Iter():
            def __init__(self, image):
                self.obj = image
                self.n = len(image.GFXlist)
                self.i = 0
                
            def __iter__(self):
                return self
                
            def __next__(self):
                if self.i ==self.n:
                    raise StopIteration
                self.i += 1
                return self.obj.GFXlist[self.i]
        return Iter(self)

    def destroy(self):
        if hasattr(self, 'GFX'):
            try:
                for gfx in self.GFXlist:
                    try:
                        gfx.destroy(True)
                    except:
                        pass
            except:
                pass
        
        </pre>
<h4>class ImageAsset</h4>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">class ImageAsset(_Asset):
    """
    The `ImageAsset` class connects ggame to a specific image **file**.
    """

    def __init__(self, url, frame=None, qty=1, direction='horizontal', margin=0):
        """
        All `ggame.ImageAsset` instances must specify a file name or url with
        the `url` parameter.

        If the desired sprite image exists in only a smaller sub-section of the 
        original image, then the are can be specified by providing the
        `frame` parameter, which must be a valid `ggame.Frame` object.

        If image file actually is a *collection* of images, such as a so-called
        *sprite sheet*, then the `ImageAsset` class supports defining a list
        of images, provided they exist in the original image as a **row**
        of evenly spaced images or a **column** of images. To specify this,
        provide the `qty` (quantity) of images in the row or column, the
        `direction` of the list ('horizontal' or 'vertical' are supported),
        and an optional `margin`, if there is a gap between successive 
        images. When used in this way, the `frame` parameter must define the
        area of the **first** image in the collection; all subsequent images
        in the list are assumed to be the same size.
        """
        super().__init__()
        self.url = url
        """
        A string that represents the path or url of the original file.
        """
        del self.GFXlist[0]
        self.append(url, frame, qty, direction, margin)

    def _subframe(self, texture, frame):
        return GFX_Texture(texture, frame.GFX)
        
    def append(self, url, frame=None, qty=1, direction='horizontal', margin=0):
        """
        Append a texture asset from a new image file (or url). This method
        allows you to build a collection of images into an asset (such as you
        might need for an animated sprite), but without using a single 
        sprite sheet image.

        The parameters for the `append` method are identical to those 
        supplied to the `ggame.ImageAsset` initialization method. 

        This method allows you to build up an asset that consists of 
        multiple rows or columns of images in a sprite sheet or sheets.
        """
        GFX = GFX_Texture_fromImage(url, False)
        dx = 0
        dy = 0
        for i in range(qty):
            if not frame is None:
                if direction == 'horizontal':
                    dx = frame.w + margin
                elif direction == 'vertical':
                    dy = frame.h + margin
                f = Frame(frame.x + dx * i, frame.y + dy * i, frame.w, frame.h)
                GFX = self._subframe(GFX, f)
            self.GFXlist.append(GFX)

</pre>
<h4>various classes</h4>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">class Color(object):
    """
    The `ggame.Color` class is used to represent colors and/or colors with
    transparency.
    """

    def __init__(self, color, alpha):
        """
        A `ggame.Color` instance must specify both a `color` as an integer
        in the conventional format (usually as a hexadecimal literal, e.g.
        0xffbb33 that represents the three color components, red, green 
        and blue), and a transparency value, or `alpha` as a floating
        point number in the range of 0.0 to 1.0 where 0.0 represents 
        completely transparent and 1.0 represents completely solid.

        Example: `red = Color(0xff0000, 1.0)`

        """
        self.color = color
        self.alpha = alpha
        

class LineStyle(object):
    """
    The `ggame.LineStyle` class is used to represent line style when
    drawing geometrical objects such as rectangles, ellipses, etc.
    """
    
    def __init__(self, width, color):
        """
        When creating a `ggame.LineStyle` instances you must specify 
        the `width` of the line in pixels and the `color` as a valid
        `ggame.Color` instance.

        Example: `line = LineStyle(3, Color(0x00ff00, 1.0))` will define
        a 3 pixel wide green line.
        """
        self.width = width
        self.color = color

class _GraphicsAsset(_Asset):
    
    def __init__(self):
        super().__init__()
        GFX_Graphics.clear()
        

class _CurveAsset(_GraphicsAsset):

    def __init__(self, line):
        super().__init__()
        GFX_Graphics.lineStyle(line.width, line.color.color, line.color.alpha)

class _ShapeAsset(_CurveAsset):

    def __init__(self, line, fill):
        super().__init__(line)
        GFX_Graphics.beginFill(fill.color, fill.alpha)


class RectangleAsset(_ShapeAsset):
    """
    The `ggame.RectangleAsset` is a "virtual" asset that is created on the
    fly without requiring creation of an image file.
    """

    def __init__(self, width, height, line, fill):
        """
        Creation of a `ggame.RectangleAsset` requires specification of the 
        rectangle `width` and `height` in pixels, the `line` (as a proper
        `ggame.LineStyle` instance) and fill properties (as a `ggame.Color`
        instance).
        """
        super().__init__(line, fill)
        self.width = width
        self.height = height
        self.GFX = GFX_Graphics.drawRect(0, 0, self.width, self.height).clone()
        """The `GFX` property represents the underlying system object."""
        self.GFX.visible = False
        

class CircleAsset(_ShapeAsset):
    """
    The `ggame.CircleAsset` is a "virtual" asset that is created on the
    fly without requiring creation of an image file.
    """    

    def __init__(self, radius, line, fill):
        """
        Creation of a `ggame.CircleAsset` requires specification of the circle
        `radius` in pixels, the `line` (as a proper `ggame.LineStyle` instance)
        and fill properties (as a `ggame.Color` instance).
        """
        super().__init__(line, fill)
        self.radius = radius
        self.GFX = GFX_Graphics.drawCircle(0, 0, self.radius).clone()
        """The `GFX` property represents the underlying system object."""
        self.GFX.visible = False
        
class EllipseAsset(_ShapeAsset):
    """
    The `ggame.EllipseAsset` is a "virtual" asset that is created on the 
    fly without requiring creation of an image file.
    """

    def __init__(self, halfw, halfh, line, fill):
        """
        Creation of a `ggame.EllipseAsset` requires specification of the ellipse
        `halfw`, or semi-axis length in the horizontal direction (half of the
        ellipse width) and the `halfh`, or semi-axis length in the vertical direction.
        `line` (as `ggame.LineStyle` instance) and `fill` (as `ggame.Color` instance)
        must also be provided.
        """
        super().__init__(line, fill)
        self.halfw = halfw
        self.halfh = halfh
        self.GFX = GFX_Graphics.drawEllipse(0, 0, self.halfw, self.halfh).clone()
        """The `GFX` property represents the underlying system object."""
        self.GFX.visible = False
        
class PolygonAsset(_ShapeAsset):
    """
    The `ggame.PolygonAsset` is a "virtual" asset that is created on the
    fly without requiring creation of an image file.
    """

    def __init__(self, path, line, fill):
        """
        Creation of a `ggame.PolygonAsset` requires specification of a 
        `path` consisting of a list of coordinate tuples. `line` and 
        `fill` arguments (instances of `ggame.LineStyle` and `ggame.Color`,
        respectively) must also be supplied. The final coordinate in the 
        list must be the same as the first.

        Example: `poly = PolygonAsset([(0,0), (50,50), (50,100), (0,0)], linesty, fcolor)`
        """
        super().__init__(line, fill)
        self.path = path
        jpath = []
        for point in self.path:
            jpath.extend(point)
        self.GFX = GFX_Graphics.drawPolygon(jpath).clone()
        """The `GFX` property represents the underlying system object."""
        self.GFX.visible = False


class LineAsset(_CurveAsset):
    """
    The `ggame.LineAsset` is a "virtual" asset that is created on the
    fly without requiring creation of an image file. A `LineAsset` instance
    represents a single line segment.
    """

    def __init__(self, x, y, line):
        """
        Creation of a `ggame.LineAsset` requires specification of an `x` and
        `y` coordinate for the endpoint of the line. The starting point of the
        line is implied as coordinates (0,0). Note that when this asset is 
        used in a `ggame.Sprite` class, the sprite's `x` and `y` coordinates
        will control the location of the line segment on the screen.

        As the `ggame.LineAsset` does not cover a region, only a `ggame.LineStyle` 
        argument must be supplied (`line`).
        """
        super().__init__(line)
        self.deltaX = x
        """This attribute represents the `x` parameter supplied during instantiation."""
        self.deltaY = y
        """This attribute represents the `y` parameter supplied during instantiation."""
        GFX_Graphics.moveTo(0, 0)
        self.GFX = GFX_Graphics.lineTo(self.deltaX, self.deltaY).clone()
        """The `GFX` property represents the underlying system object."""
        self.GFX.visible = False

class TextAsset(_GraphicsAsset):
    """
    The `ggame.TextAsset` is a "virtual" asset that is created on the fly
    without requiring creation of an image file. A `TextAsset` instance
    represents a block of text, together with its styling (font, color, etc.).
    """
 
    def __init__(self, text, **kwargs):
        """
        The `ggame.TextAsset` must be created with a string as the `text` parameter.
        
        The remaining optional arguments must be supplied as keyword parameters. These
        parameters are described under the class attributes, below:
        """
        super().__init__()
        self.text = text
        self.style = kwargs.get('style', '20px Arial')
        """A string that specifies style, size and typeface (e.g. `'italic 20pt Helvetica'` or `'20px Arial'`)"""
        self.width = kwargs.get('width', 100)
        """Width of the text block on the screen, in pixels."""
        self.fill = kwargs.get('fill', Color(0, 1))
        """A valid `ggame.Color` instance that specifies the color and transparency of the text."""
        self.align = kwargs.get('align', 'left')
        """The alignment style of the text. One of: `'left'`, `'center'`, or `'right'`."""
        self.GFX = GFX_Text(self.text, 
            {'font': self.style,
                'fill' : self.fill.color,
                'align' : self.align,
                'wordWrap' : True,
                'wordWrapWidth' : self.width,
                })
        """The `GFX` property represents the underlying system object."""
        self.GFX.alpha = self.fill.alpha
        self.GFX.visible = False
        
    def _clone(self):
        return type(self)(self.text,
            style = self.style,
            width = self.width,
            fill = self.fill,
            align = self.align)

</pre>
<h4>class sound and mouse event</h4>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">class SoundAsset(object):
    """
    Class representing a single sound asset (sound file, such as .mp3 or .wav).
    """    
    def __init__(self, url):
        """
        Create a `ggame.SoundAsset` instance by passing in the URL or file name
        of the desired sound. Sound file formats may include `.wav` or `.mp3`, subject
        to browser compatibility. 
        """
        self.url = url
        """
        A string containing the url or name of the asset file.
        """

        
class Sound(object):
    """
    The `ggame.Sound` class represents a sound, with methods for controlling
    when and how the sound is played in the application.
    """

    def __init__(self, asset):
        """
        Pass a valid `ggame.SoundAsset` instance when creating a `ggame.Sound` object.
        """
        self.asset = asset
        """
        A reference to the `ggame.SoundAsset` instance.
        """
        self.SND = SND_Sound(self.asset.url)
        """
        A reference to the underlying sound object provided by the system.
        """
        self.SND.load()
        
    def play(self):
        """
        Play the sound once.
        """
        self.stop()
        self.SND.play()

    def loop(self):
        """
        Play the sound continuously, looping forever.
        """
        self.stop()
        self.SND.loop()
        self.SND.play()
        
    def stop(self):
        """
        Stop playing the sound.
        """
        self.SND.stop()
        
    @property
    def volume(self):
        """
        The `ggame.Sound.volume` property is a number ranging from 0-100, that 
        represents the volume or intensity of the sound when it is playing.
        """
        return self.SND.getVolume()
        
    @volume.setter
    def volume(self, value):
        self.SND.setVolume(value)


class _Event(object):

    def __init__(self, hwevent):
        self.hwevent = hwevent
        """The underlying system event object."""
        self.type = hwevent.type
        """String representing the type of received event."""
        self.consumed = False
        """
        Set the `consumed` member of the event to prevent the event
        from being received by any more handler methods.
        """
        
class MouseEvent(_Event):
    """
    The `ggame.MouseEvent` class encapsulates information regarding a user mouse
    action that is being reported by the system.
    """    

    mousemove = "mousemove"
    """Constant identifying a `mousemove` event."""
    mousedown = "mousedown"
    """Constant identifying a `mousedown` event."""
    mouseup = "mouseup"
    """Constant identifying a `mouseup` event."""
    click = "click"
    """Constant identifying a button `click` event."""
    dblclick = "dblclick"
    """Constant identifying a button `dblclick` event."""
    mousewheel = "wheel"
    """Constant identifying a mouse `wheel` scroll event."""
    
    def __init__(self, hwevent):
        """
        The event is initialized by the system, with a `hwevent` input parameter.
        """
        super().__init__(hwevent)
        self.wheelDelta = 0
        """Integer representing up/down motion of the scroll wheel."""
        if self.type == self.mousewheel:
            self.wheelDelta = hwevent.deltaY
        else:
            self.wheelDelta = 0
        self.x = hwevent.clientX
        """The window x-coordinate of the mouse pointer when the event occurred."""
        self.y = hwevent.clientY
        """The window y-coordinate of the mouse pointer when the event occurred."""


class KeyEvent(_Event):
    """
    The `ggame.KeyEvent` class encapsulates information regarding a user keyboard
    action that is being reported by the system.
    """    

    no_location = 0
    """Constant indicating no specific location for the key event."""
    right_location = 2
    """Constant indicating the key event was on the right hand side of the keyboard."""
    left_location = 1
    """Constant indicating the key event was on the left hand side of the keyboard."""
    keydown = "keydown"
    """Constant indicating the key was pressed down."""
    keyup = "keyup"
    """Constant indicating the key was released."""
    keypress = "keypress"
    """Constant indicating the combination of keydown, followed by keyup."""
    keys = {8: 'backspace',
        9: 'tab',
        13: 'enter',
        16: 'shift',
        17: 'ctrl',
        18: 'alt',
        19: 'pause/break',
        20: 'caps lock',
        27: 'escape',
        32: 'space',
        33: 'page up',
        34: 'page down',
        35: 'end',
        36: 'home',
        37: 'left arrow',
        38: 'up arrow',
        39: 'right arrow',
        40: 'down arrow',
        45: 'insert',
        46: 'delete',
        48: '0',
        49: '1',
        50: '2',
        51: '3',
        52: '4',
        53: '5',
        54: '6',
        55: '7',
        56: '8',
        57: '9',
        65: 'a',
        66: 'b',
        67: 'c',
        68: 'd',
        69: 'e',
        70: 'f',
        71: 'g',
        72: 'h',
        73: 'i',
        74: 'j',
        75: 'k',
        76: 'l',
        77: 'm',
        78: 'n',
        79: 'o',
        80: 'p',
        81: 'q',
        82: 'r',
        83: 's',
        84: 't',
        85: 'u',
        86: 'v',
        87: 'w',
        88: 'x',
        89: 'y',
        90: 'z',
        91: 'left window key',
        92: 'right window key',
        93: 'select key',
        96: 'numpad 0',
        97: 'numpad 1',
        98: 'numpad 2',
        99: 'numpad 3',
        100: 'numpad 4',
        101: 'numpad 5',
        102: 'numpad 6',
        103: 'numpad 7',
        104: 'numpad 8',
        105: 'numpad 9',
        106: 'multiply',
        107: 'add',
        109: 'subtract',
        110: 'decimal point',
        111: 'divide',
        112: 'f1',
        113: 'f2',
        114: 'f3',
        115: 'f4',
        116: 'f5',
        117: 'f6',
        118: 'f7',
        119: 'f8',
        120: 'f9',
        121: 'f10',
        122: 'f11',
        123: 'f12',
        144: 'num lock',
        145: 'scroll lock',
        186: 'semicolon',
        187: 'equal sign',
        188: 'comma',
        189: 'dash',
        190: 'period',
        191: 'forward slash',
        192: 'grave accent',
        219: 'open bracket',
        220: 'back slash',
        221: 'close bracket',
        222: 'single quote'}    
    """Dictionary mapping key code integers to textual key description."""
    
    def __init__(self, hwevent):
        """
        The event is initialized by the system, with a `hwevent` input parameter.
        """
        super().__init__(hwevent)
        self.keynum = hwevent.keyCode
        """The `keynum` attribute identifies a keycode (number)."""
        self.key = self.keys[hwevent.keyCode]
        """The `key` attribute identifes the key in text form (e.g. 'back slash')."""


</pre>
<p></p>
<h3>Deno</h3>
<p><a href="https://deno.land/">https://deno.land/</a></p>
<p>單一執行檔案, 可以讓使用者直接採用 deno run your_typescript.ts 執行 Typescript 程式.</p>
<h4>Javascript Ecosystem:</h4>
<p style="padding-left: 30px;"><a href="https://www.imaginarycloud.com/blog/a-javascript-ecosystem-overview/">https://www.imaginarycloud.com/blog/a-javascript-ecosystem-overview/</a></p>
<p style="padding-left: 30px;">網際 Javascript 執行: <a href="http://mde.tw/cp2019/content/Javascript.html">http://mde.tw/cp2019/content/Javascript.html</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/mdecourse/hexapod">https://github.com/mdecourse/hexapod</a> (Robotic Inverse Kinematics)</p>
<p style="padding-left: 30px;">Dart Web: <a href="http://mde.tw/cp2019/content/Task2.html">http://mde.tw/cp2019/content/Task2.html</a> (Dart 轉為 Javascript)</p>
<p style="padding-left: 30px;">Flutter Web: <a href="http://mde.tw/cp2019/content/Flutter%20Web.html">http://mde.tw/cp2019/content/Flutter%20Web.html</a> (Dart 轉為 Javascript)</p>
<h4>User Interface:</h4>
<p style="padding-left: 30px;"><a href="https://reactjs.org/">https://reactjs.org/</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/typescript-cheatsheets/react#reacttypescript-cheatsheets">https://github.com/typescript-cheatsheets/react#reacttypescript-cheatsheets</a></p>
<h4>Web based 3D rendering:</h4>
<p style="padding-left: 30px;"><a href="https://github.com/BabylonJS/Babylon.js">https://github.com/BabylonJS/Babylon.js</a></p>
<p style="padding-left: 30px;"><a href="https://www.babylonjs.com/community/">https://www.babylonjs.com/community/</a></p>
<h4>Deno JS and TS runtime:</h4>
<p style="padding-left: 30px;"><a href="https://deno.com/blog/the-deno-company">https://deno.com/blog/the-deno-company</a></p>
<p style="padding-left: 30px;">Deno 1.11.5: <a href="https://github.com/denoland/deno/releases/">https://github.com/denoland/deno/releases/</a> 直接下載 Windows 版本解開壓縮後 55MB, 放入可攜系統 data 目錄中即可執行.</p>
<p style="padding-left: 30px;"><a href="https://deno.land/x/">https://deno.land/x/</a></p>
<p style="padding-left: 30px;"><a href="https://deno.com/deploy">https://deno.com/deploy</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/lucacasonato/deploy_chat">https://github.com/lucacasonato/deploy_chat</a></p>
<p style="padding-left: 30px;">Deno <a href="https://deno.com/blog/v1.8#experimental-support-for-the-webgpu-api">supports</a> <a href="https://gpuweb.github.io/gpuweb/">WebGPU</a></p>
<p style="padding-left: 30px;"><a href="https://www.freecodecamp.org/news/the-deno-handbook/">https://www.freecodecamp.org/news/the-deno-handbook/</a></p>
<p style="padding-left: 30px;"><a href="https://deno.land/manual@v1.11.5/typescript">https://deno.land/manual@v1.11.5/typescript</a></p>
<p style="padding-left: 60px;"><a href="https://deno.land/manual@v1.11.5/typescript/overview">https://deno.land/manual@v1.11.5/typescript/overview</a></p>
<p style="padding-left: 30px;"><a href="https://deno.land/">https://deno.land/</a> (Javascript and Typescript runtime written in Rust)</p>
<p style="padding-left: 60px;"><a href="https://link.springer.com/book/10.1007/978-1-4842-4979-6">Essential Typescript</a> (從校園網路下載電子書)</p>
<p style="padding-left: 60px;"><a href="https://link.springer.com/book/10.1007/978-1-4842-3249-1">Pro Typescript</a> (從校園網路下載電子書)</p>
<p style="padding-left: 60px;"><a href="https://link.springer.com/book/10.1007/978-1-4842-6197-2">Introducing Deno</a> (從校園網路下載電子書)</p>
<p style="padding-left: 60px;"><a href="https://itnext.io/typescript-machine-learning-simplicity-kalimdor-js-bb1ccadf0ad3">https://itnext.io/typescript-machine-learning-simplicity-kalimdor-js-bb1ccadf0ad3</a></p>
<h4>References:</h4>
<p style="padding-left: 30px;"><a href="https://stackoverflow.com/questions/61710787/how-to-run-a-python-script-from-deno">在 Deno 執行 Python 程式.</a></p>
<p style="padding-left: 60px;">Genetic Algorithm:</p>
<p style="padding-left: 90px;"><a href="https://github.com/mdecourse/genetic">https://github.com/mdecourse/genetic</a> </p>
<p style="padding-left: 90px;"><a href="https://link.springer.com/content/pdf/10.1007/s11042-020-10139-6.pdf">A review on genetic algorithm: past,present, and future</a></p>
<p style="padding-left: 30px;"><a href="https://link.springer.com/book/10.1007/978-1-4842-5394-6">Javascript Next</a> (從校園網路下載電子書)</p>
<p style="padding-left: 30px;"><a href="https://link.springer.com/book/10.1007/978-1-4842-2623-0">E6S for Humans</a> (從校園網路下載電子書)</p>
<p style="padding-left: 30px;"><a href="https://link.springer.com/book/10.1007/978-1-4842-3988-9">JavaScript Data Structures and Algorithms</a> (從校園網路下載電子書)</p>
<p style="padding-left: 30px;"><a href="https://link.springer.com/book/10.1007/978-1-4842-2656-8">Beginning Functional Javascript</a> (從校園網路下載電子書)</p>
<h4 style="padding-left: 30px;">jQuery</h4>
<p style="padding-left: 30px;"><a href="https://jquery.com/">https://jquery.com/</a></p>
<h4 style="padding-left: 30px;">jQuery-UI</h4>
<p style="padding-left: 30px;"><a href="https://jqueryui.com/">https://jqueryui.com/</a></p>
<h4 style="padding-left: 30px;">buzz</h4>
<p style="padding-left: 30px;"><a href="https://buzz.jaysalvat.com/">https://buzz.jaysalvat.com/</a></p>
<h3>TypeScript</h3>
<p>能否將 <a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> 以 TypeScript 改寫,或者轉為 VSCode 的 Extension?</p>
<p style="padding-left: 30px;"><a href="https://code.visualstudio.com/api/get-started/your-first-extension">https://code.visualstudio.com/api/get-started/your-first-extension</a></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/a5DX5pQ9p5M" title="YouTube video player" width="560"></iframe></p>
<p><a href="https://www.typescriptlang.org/">https://www.typescriptlang.org/</a></p>
<p><a href="https://github.com/microsoft/vscode">https://github.com/microsoft/vscode</a></p>
<p style="padding-left: 30px;">在隨身系統啟動時, 需要 Y:\home_ipv6\AppData\Roaming 目錄才能開啟, 因為需要新增 Y:\home_ipv6\AppData\Roaming\Code\Dictionaries 目錄備用.</p>
<p style="padding-left: 30px;">Command Palette (Ctrl+Shift+P)</p>
<p><a href="https://github.com/boltex/leointeg">https://github.com/boltex/leointeg</a></p>
<p style="padding-left: 30px;">以 TypeScript 編寫將 Leo Editor 功能轉為 VSCode 的 Extension.</p>
<p>2013 <a href="https://link.springer.com/book/10.1007/978-1-4302-5726-4">TypeScript Revealed</a> (請從校園網路下載）</p>
<p>2018 <a href="https://link.springer.com/book/10.1007/978-1-4842-3249-1">Pro TypeScript</a> (請從校園網路下載）</p>
<p>2019 <a href="https://link.springer.com/book/10.1007/978-1-4842-4979-6">Essential TypeScript</a> (請從校園網路下載）</p>
<p>2019 <a href="https://link.springer.com/book/10.1007/978-1-4842-4395-4">Beginning Javascript</a> (請從校園網路下載）</p>
<p>2019 <a href="https://link.springer.com/book/10.1007/978-1-4842-4224-7">Visual Studio Code Distilled</a></p>
<h3>pixijs</h3>
<p>PixiJS — The HTML5 Creation Engine</p>
<p>Create Great Interactive Graphics or Games and the Web</p>
<p><a href="https://link.springer.com/book/10.1007/978-1-4842-1094-9">Learn Pixi.js</a> (從校園網路中下載電子書)</p>
<p style="padding-left: 30px;">Pixi.js <a href="https://pixijs.io/examples-v4/#/demos-basic/container.js">4.X.X</a> 與 <a href="https://pixijs.io/examples/#/demos-basic/container.js">5.X.X</a> 之間的差異.</p>
<p><a href="https://github.com/pixijs/pixijs">https://github.com/pixijs/pixijs</a></p>
<p>如何使用 pixi.js</p>
<p>以下利用 Bython 與 <a href="https://github.com/mdecourse/nfulist">https://github.com/mdecourse/nfulist</a> on Heroku 結合, 列出 1092 學期各課程修課人員學號,  程式執行流程先從一個<span style="background-color: #ccffcc;">全球資訊網伺服器</span> (位於 Github, 伺服器 1) 將此網頁送到使用者的<span style="background-color: #ccffcc;">瀏覽器</span> (客戶端電腦) 中, 並且執行 Brython javascript 程式, 將頁面中的 Python 程式轉為 Javascript 後, 因為其中導入 Open() 函式採用 ajax 模式至使用者指定的 URL 中擷取資料, 而此一位於 <span style="background-color: #ccffcc;">Heroku 雲端</span> (位於 Heroku, 伺服器 2) 的 Python Flask 程式也是採用 ajax 方式對<span style="background-color: #ccffcc;">學校教務處</span> (位於虎尾, 伺服器 3) 伺服主機發出 post 表單資料, 並從教務主機中取出特定學期, 特定課號的修課人員名單, 然後所截取出來的資料, 再由 Brython 程式發布到特定網頁中的位置. 因此以下學員資料的擷取包括客戶端電腦, 程式執行總共牽涉到其他位於不同地理位置的 3 台主機.</p>
<p>這個網際程式的執行, 代表的是利用計算機程式, 電腦軟硬體與網路技術, 各位於不同地理位置的電腦只要各自扮演好自己的角色, 能夠獨立完成一項任務中的協同任務, 使用者只要了解各種協定的特性, 就可以完成原先需要四處實地奔走才能完成的任務. <span style="background-color: #ffff99;">少負擔, 多建樹應該就是應用計算機程式與電腦輔助設計的本質</span> (Less burden, more achievements should be the essence of application of the computer programs and computer-aided design.).</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.1.3/pixi.min.js"&gt;&lt;/script&gt;
&lt;script src="/static/brython.js"&gt;&lt;/script&gt;
&lt;script src="/static/brython_stdlib.js"&gt;&lt;/script&gt;
&lt;script&gt;// &lt;![CDATA[
window.onload=function(){
brython({debug:1, pythonpath:['/static/']});
}
// ]]&gt;&lt;/script&gt;
&lt;div id="brython_text1"&gt;&lt;/div&gt;
&lt;script type="text/python"&gt;// &lt;![CDATA[
from browser import document as doc
from browser import html

'''
2021 spring (1092):
0741 1a
0764 2a
0776 2b
2384 5j
'''
# setup up basic data
semester_code = "1092"
class_code = ["0741", "0764", "0776", "2384"]
# add a vacant string
stud_list = ""

# go through class_code one by one
for i in class_code:
    url = "https://nfulist.herokuapp.com/?semester="+semester_code+"&amp;courseno="+i+"&amp;column=False"
    title = html.H4("Semester:"+semester_code+" - "+i+" course student list:")
    stud_list += title + open(url).read()

doc["brython_text1"] &lt;= stud_list
// ]]&gt;&lt;/script&gt;</pre>
<p>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.1.3/pixi.min.js"></script>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/']});
}
</script>
</p>
<div id="brython_text1"></div>
<p>
<script type="text/python">
from browser import document as doc
from browser import html

'''
2021 spring (1092):
0741 1a
0764 2a
0776 2b
2384 5j
'''
# setup up basic data
semester_code = "1092"
class_code = ["0741", "0764", "0776", "2384"]
# add a vacant string
stud_list = ""

# go through class_code one by one
for i in class_code:
    url = "https://nfulist.herokuapp.com/?semester="+semester_code+"&courseno="+i+"&column=False"
    title = html.H4("Semester:"+semester_code+" - "+i+" course student list:")
    stud_list += title + open(url).read()

doc["brython_text1"] <= stud_list
</script>
</p>
<h3>pixijs1</h3>
<p><a href="https://mdecp2018.github.io/finalproject-bgx/content/%E7%B6%B2%E9%9A%9B%E6%A8%A1%E6%93%AC%E7%A8%8B%E5%BC%8F.html">2018 參考資料</a></p>
<p>ggame is for <a href="https://pixijs.io/examples-v4/#/demos-basic/container.js">pixi 4.8.2</a></p>
<h4>Brython and pixi.js integrated html5 result:</h4>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.8.2/pixi.min.js"&gt;&lt;/script&gt;
&lt;script src="/static/brython.js"&gt;&lt;/script&gt;
&lt;script src="/static/brython_stdlib.js"&gt;&lt;/script&gt;
&lt;script&gt;// &lt;![CDATA[
window.onload=function(){
brython({debug:1, pythonpath:['/static/']});
}
// ]]&gt;&lt;/script&gt;
&lt;div id="brython_div"&gt;&lt;/div&gt;
&lt;div id="line_drawing"&gt;&lt;/div&gt;
&lt;script type="text/python"&gt;// &lt;![CDATA[
# from browser import window, document and html
from browser import window, document, html
# this is for animation, which is different from what javascipt implemented
import browser.timer
# use socket.gethostname() to differentiate where script is executed
import socket

# if executed under localhost
if socket.gethostname() == "localhost":
    site = ""
else:
    # when executed in remote site
    site="./.."

# let brython_div to be the div with id=brython_div
brython_div = document["brython_div"]
# use window to get PIXI object and let it be GFX
GFX = window.PIXI
# create new PIXI application
App = GFX.Application.new
# set application size and background
app = App(400, 300, { 'transparent': True })
# add application view into div markup
brython_div.appendChild(app.view)
# create Sprite from image file
bunny = GFX.Sprite.fromImage(site+'/images/bunny.png')
# center the sprite's anchor point, this is the center for the rotation of the graphics
bunny.anchor.set(0.5)
# move the sprite to the center of the screen
bunny.x = app.screen.width / 2
bunny.y = app.screen.height / 2
# add Sprite into the application stage
app.stage.addChild(bunny)

def bunnyRotate():
    bunny.rotation += 0.1

browser.timer.set_interval(bunnyRotate, 30)
// ]]&gt;&lt;/script&gt;</pre>
<p>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.8.2/pixi.min.js"></script>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/']});
}
</script>
</p>
<div id="brython_div"></div>
<div id="line_drawing"></div>
<p>
<script type="text/python">
# from browser import window, document and html
from browser import window, document, html
# this is for animation, which is different from what javascipt implemented
import browser.timer
# use socket.gethostname() to differentiate where script is executed
import socket

# if executed under localhost
if socket.gethostname() == "localhost":
    site = ""
else:
    # when executed in remote site
    site="./.."

# let brython_div to be the div with id=brython_div
brython_div = document["brython_div"]
# use window to get PIXI object and let it be GFX
GFX = window.PIXI
# create new PIXI application
App = GFX.Application.new
# set application size and background
app = App(400, 300, { 'transparent': True })
# add application view into div markup
brython_div.appendChild(app.view)
# create Sprite from image file
bunny = GFX.Sprite.fromImage(site+'/images/bunny.png')
# center the sprite's anchor point, this is the center for the rotation of the graphics
bunny.anchor.set(0.5)
# move the sprite to the center of the screen
bunny.x = app.screen.width / 2
bunny.y = app.screen.height / 2
# add Sprite into the application stage
app.stage.addChild(bunny)

def bunnyRotate():
    bunny.rotation += 0.1

browser.timer.set_interval(bunnyRotate, 30)
</script>
</p>
<h2>Brython-server</h2>
<p><a href="https://github.com/mdecourse/brython-server">https://github.com/mdecourse/brython-server</a></p>
<h4>Heroku:</h4>
<p style="padding-left: 30px;"><a href="https://heroku.com">https://heroku.com</a></p>
<h2>虛擬主機</h2>
<p>這裡的虛擬主機系統指利用 <a href="https://www.virtualbox.org/">https://www.virtualbox.org/</a> 所建立的 Windows 或 Ubuntu 操作系統檔案, 可以在不同實體操作系統中, 進行轉移運作.</p>
<p>透過虛擬主機與實體主機間的網路設定, 可以讓使用者進行網際程式開發.</p>
<p>Virtualbox 網路設定:</p>
<p>Nat - 虛擬主機可以藉由實體主機的網路架構上網, 但必須透過 Port Mapping 才能以實體主機的網路位址設為聯外 server.</p>
<p>Host-only Adaptor - 虛擬主機的網路設定自外於任何聯外網路, 因此無法直接上網, 但各 Host 間同群電腦可以互通.</p>
<p>Bridged Adaptor - 虛擬主機的網路設定與實體主機的網路位階相同, 若實體主機位於外部網段, 則虛擬主機可設為聯外 server.</p>
<p><a href="https://link.springer.com/content/pdf/10.1007%2F978-3-319-92429-8.pdf">Systems Programming in Unix/Linux</a> (校園網路下載電子書)</p>
<h4>Github Actions:</h4>
<p style="padding-left: 30px;"><a href="https://github.com/features/actions">https://github.com/features/actions</a></p>
<h4 style="padding-left: 30px;">應用範例:</h4>
<p style="padding-left: 60px;"><a href="https://github.com/mdecourse/report/blob/main/.github/workflows/demo.yaml">https://github.com/mdecourse/report/blob/main/.github/workflows/demo.yaml</a></p>
<p style="padding-left: 60px;"><a href="https://github.com/mdecourse/4072pj1">https://github.com/mdecourse/4072pj1</a></p>
<h1>實習內容</h1>
<p>計算機程式在學習如何將做事的過程 (process) 及直覺 (intuitions) 予以形式化 (formalize), 並且著手開發一種方式來準確地 (precisely) 討論如何運用知識 (knowledge).</p>
<p><a href="https://www.merriam-webster.com/dictionary/formalize">Formalize</a> 在字義上為 "to give a certain or definite form to".</p>
<p>Certain 與 definite 都是明確的意思. 因此所謂將做事過程 (也就是解題過程) 與直覺 (也就是認為可以解題的方式), 用明確的方式加以表示, 才能放入電腦要求計算機執行運算, 最終得到工程師想要的結果.</p>
<p>至於準確運用知識, 是站在使用電腦當下工程師的認知行事, 擁有對計算機運作流程越多知識與經驗的人, 就越能夠發揮計算機的功能.</p>
<p>學習計算機程式的過程, 學習者將會面臨何種挑戰?</p>
<h4 style="padding-left: 30px;">挑戰一:</h4>
<p style="padding-left: 60px;">是否已經做好了與電腦溝通的準備?</p>
<h4 style="padding-left: 30px;">挑戰二:</h4>
<p style="padding-left: 60px;">到底要用電腦解決什麼問題?</p>
<h4>電腦打字競賽:</h4>
<p style="padding-left: 30px;">與電腦溝通可以透過鍵盤, 滑鼠, 觸控, 聲控, 影像辨識及手勢等方式. 我們先來接受第一個利用鍵盤輸入與電腦溝通的挑戰:</p>
<p style="padding-left: 60px;">我們從<a href="https://www.snhu.edu/about-us/newsroom/2018/06/what-is-computer-programming">這裡</a>取出以下這四個英文句子, 然後要請大家在 <a href="https://translate.google.com.tw/?hl=zh-TW">Google 翻譯頁面</a>中的左側 (也就是英文輸入框) 用鍵盤打字輸入下列四段英文, 然後 Google Translate 服務就會幫我們翻譯成右方的繁體中文內容.</p>
<p style="padding-left: 60px;">你必須設法調整好兩個瀏覽器的畫面 (一上一下 或一左一右), 然後準備好一邊看著下面這段英文內容, 一方面用鍵盤打字逐一輸入每個單字, 準備好了, 我們就要開始來進行英文輸入挑戰比賽 (但是不可以使用 Ctrl + C 與 Ctrl + V 複製與貼上作弊, 雖然我們知道這是大學生最熟悉且擅長的三種技能:-), 大家都準備好之後, 老師喊開始, 才能著手打字, 快速打完這段文字的, 就可以舉手, 我們將要找出全班英文打字速度最快的前六名同學.</p>
<p>What is Computer Programming and How to Become a Computer Programmer</p>
<p>Computer programming is the process that professionals use to write code that instructs how a computer, application or software program performs.</p>
<p>At its most basic, computer programming is a set of instructions to facilitate specific actions.</p>
<p>If you're wondering what a computer programmer is, it's a professional that creates instructions for a computer to execute by writing and testing code that enables applications and software programs to operate successfully.</p>
<h4>課程挑戰二:</h4>
<p style="padding-left: 30px;">假如我們上一個挑戰競賽順利進行的話, 各班已經出現英文打字速度最快的前六名學員, 接下來我們要接受計算機程式課程的第二個挑戰:</p>
<p style="padding-left: 60px;">我們將在每一個座位橫排中 (每 9 位同學) 抽出一位同學, 請他(她) 告訴我們機械設計工程師到底希望用電腦解決什麼問題?</p>
<p style="padding-left: 60px;">這裡將牽涉:</p>
<ol>
<li>要如何"公平地"抽出每一座位橫排中的某一位同學? (我們知道通常不會有自願舉手, 勇於表達的同學)</li>
<li>要如何(長期)收集被抽中同學所發表的內容? (假如我們接下來每個禮拜都來玩這個挑戰"遊戲"的話!)</li>
<li>或者我們不要用抽的, 我們想要重新玩挑戰一, 讓全班所有學員都同時在同一個電腦畫面上進行英文打字輸入比賽, 而且要同時接受挑戰二, 在同一個電腦畫面上收集每一位同學的發言內容.</li>
</ol>
<h2>分散式版次管理</h2>
<h4>請分別至下列網站申請帳號:</h4>
<p style="padding-left: 30px;">Github: <a href="https://github.com/">https://github.com/</a></p>
<h4 style="padding-left: 60px;">實作:</h4>
<p style="padding-left: 90px;"><a href="https://backlog.com/git-tutorial/tw/">https://backlog.com/git-tutorial/tw/</a></p>
<p style="padding-left: 90px;"><a href="https://github.com/doggy8088/Learn-Git-in-30-days/blob/master/zh-tw/README.md">https://github.com/doggy8088/Learn-Git-in-30-days/blob/master/zh-tw/README.md</a></p>
<p style="padding-left: 90px;"><a href="https://gitbook.tw/interview">https://gitbook.tw/interview</a></p>
<p style="padding-left: 90px;"><a href="https://git-scm.com/book/zh-tw/v2/">https://git-scm.com/book/zh-tw/v2/</a></p>
<p style="padding-left: 90px;"><a href="https://mde.tw/cmstemplate">https://mde.tw/cmstemplate</a></p>
<p style="padding-left: 30px;">Gitlab: <a href="https://gitlab.com/users/sign_up">https://gitlab.com/users/sign_up</a></p>
<p style="padding-left: 30px;">Bitbucket: <a href="https://id.atlassian.com/signup?application=bitbucket&amp;continue=https%3A//bitbucket.org/account/signin/%3Foptintocst%3D1%26next%3D/%3Faidsignup%3D1">Bitbucket sign up</a></p>
<p style="padding-left: 30px;">Heroku: <a href="https://www.heroku.com/">https://www.heroku.com/</a></p>
<h4>請分別取得下列網站的 Windows 版工具:</h4>
<p style="padding-left: 30px;">Fossil SCM: <a href="https://www.fossil-scm.org">https://www.fossil-scm.org</a></p>
<p style="padding-left: 30px;">GitExtension: <a href="https://github.com/gitextensions/gitextensions/releases/tag/v3.5.3">https://github.com/gitextensions/gitextensions/releases/tag/v3.5.3</a></p>
<p style="padding-left: 30px;">Zoomit: <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/zoomit">https://docs.microsoft.com/en-us/sysinternals/downloads/zoomit</a></p>
<p style="padding-left: 30px;">FFMpeg: <a href="https://ffmpeg.org/download.html">https://ffmpeg.org/download.html</a></p>
<p style="padding-left: 30px;">ShareX: <a href="https://github.com/ShareX/ShareX/releases">https://github.com/ShareX/ShareX/releases</a></p>
<p style="padding-left: 30px;">Wink: <a href="https://www.debugmode.com/wink/">https://www.debugmode.com/wink/</a></p>
<p></p>
<h2>程式練習題</h2>
<h4>Python 初學者的四小時課程:</h4>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/rfscVS0vtbw" title="YouTube video player" width="560"></iframe></p>
<h4>題目一練習目的:</h4>
<ol>
<li>練習 <a href="https://www.w3schools.com/python/python_functions.asp">Python 基本函式</a>設計與呼叫</li>
<li>練習 <a href="https://docs.python.org/3/tutorial/classes.html">Python 基本物件導向</a>程式設計</li>
<li>練習 <a href="https://brython.info/static_doc/en/html.html">Brython browser.html</a> 應用</li>
<li>了解 <a href="https://www.w3schools.com/js/js_htmldom.asp">HTML DOM</a> 基本概念</li>
<li>練習 <a href="https://developer.mozilla.org/zh-TW/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL">WebGL Canvas</a> 2d 繪圖</li>
<li>熟悉 Github 倉儲與 <a href="https://docs.github.com/en/github/writing-on-github/editing-and-sharing-content-with-gists/creating-gists">Gist</a> 應用</li>
<li>應用 <a href="https://www.geartechnology.com/articles/0615/The_Basics_of_Gear_Theory/">Gear Theory</a> 於 2D 繪圖</li>
<li>練習以 Brython 導入外部 <a href="https://brython.info/static_doc/en/javascript.html">Javasdript 程式庫</a></li>
</ol>
<h4>題目一:</h4>
<p>請以 <a href="https://mde.tw/cp2021/content/Gist.html">https://mde.tw/cp2021/content/Gist.html</a> (<a href="https://mde.tw/cp2021/content/run.html?src=https://gist.githubusercontent.com/mdecourse/626206cf3b2a9a9a69f7ce4bb4a116f0/raw/970e2653a7207828b3814c2c867892903734522a/spur_set_num.py">範例</a>) 中的 Spur 正齒輪輪廓繪圖為基礎, 將程式改為 Spur1 與 Spur2 等兩個按鈕:</p>
<ol>
<li>Spur1 按鈕可帶出三個水平排列的齒輪組囓合輪廓繪圖, 並且可由使用者分別從表單輸入三個齒輪的齒數與共同壓力角.</li>
<li>Spur2 按鈕則可帶出三個以 L 形排列的齒輪組囓合輪廓繪圖, 並且可由使用者分別從表單輸入三個齒輪的齒數與共同壓力角.</li>
<li>請利用 <a href="https://www.arc.id.au/GearDrawing.html">https://www.arc.id.au/GearDrawing.html</a> 中的 gearUtils-09.js 執行上述兩個題目的正齒輪繪圖 (<a href="https://mde.tw/cp2021/content/run.html?src=https://gist.githubusercontent.com/mdecourse/e896a4705a95ac8cc4147b355b0e87ef/raw/76c510c47d88c9c218130a4ebb2cadf59803a3c7/cango_gear1.py">範例</a>).</li>
<li>請在上述四個題目中各加上一個 Animation 按鈕, 使用者按下後, 各齒輪可以依照 input 轉速模擬囓合傳動 (<a href="https://mde.tw/cp2021/content/run.html?src=https://gist.githubusercontent.com/mdecourse/e896a4705a95ac8cc4147b355b0e87ef/raw/76c510c47d88c9c218130a4ebb2cadf59803a3c7/three_spur_rotating.py">範例</a>).</li>
</ol>
<hr/>
<h4>題目二練習目的:</h4>
<ol>
<li>練習 <a href="https://www.w3schools.com/python/python_functions.asp">Python 基本函式</a>設計與呼叫</li>
<li>練習<a href="https://zh.wikipedia.org/wiki/%E4%BA%8B%E4%BB%B6%E9%A9%85%E5%8B%95%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88">事件驅動程式設計</a></li>
<li>練習 <a href="https://brython.info/static_doc/en/html.html">Brython browser.html</a> 應用</li>
<li>了解 <a href="https://www.w3schools.com/js/js_htmldom.asp">HTML DOM</a> 基本概念</li>
<li>了解如何使用 <a href="https://docs.python.org/3/library/math.html">Python 數學程式庫</a></li>
</ol>
<h4>題目二:</h4>
<p>請利用 Brython 將 <a href="https://mde.tw/cp2021/content/Brython.html">https://mde.tw/cp2021/content/Brython.html</a> 中的計算機改為<a href="https://www.calculator.net/scientific-calculator.html">工程用計算機</a>.</p>
<p></p>
<p></p>
<p></p>
<p></p><h2>Stage1</h2>
<p>經過前面的課程說明, 我們已經知道, 學習計算機程式需要與電腦溝通, 而現階段機械設計工程師與電腦溝通的重要方式就是英文與中文的鍵盤輸入, 假如您對 <a href="https://www.ratatype.com/learn/">touch typing</a> 技巧還不是很熟練, 一定要自行找時間練習.</p>
<p>至於挑戰二所列出, 有關機械設計工程師希望利用電腦解決的問題可能太過廣泛, 因為下列這段敘述:</p>
<p>Computer programming is to learn how to formalize intuitions about process, how to do things, starting to develop a way to talk precisely about how-to knowledge.</p>
<p>其中的關鍵字是正式, 直覺, 流程, 做事, 開發, 精確與如何解題所牽涉的知識. 重新組合一下就成為:</p>
<p>將<span style="background-color: #ffff99;">直覺做事的過程</span>轉化為<span style="background-color: #ffff99;">利用正式且精確的知識解決問題</span>. 而計算機程式則是居中希望採用的工具與方法.</p>
<p>以下為一般工程師面對問題的解決流程:</p>
<ol>
<li>(資料收集與文獻探討) - 工程師在解決問題的過程, 都必須花時間先搜尋相關資料, 仔細研究各種文獻中是否已經有最佳解題方案, 然後再思考這些方案是否適合用來解決此刻所面對的問題.</li>
<li>(實作解題方案) - 一旦確定文獻中已經提供適合解題的方案, 就可以著手根據流程中的步驟, 逐一實作確定問題是否獲得解決.</li>
<li>(討論解題方案) - 若其他人所使用的方法, 必須配合時空背景與環境現實進行修改, 也必須逐一進行測試確認.</li>
<li>(發表解題歷程與結果) - 在上述解題過程中, 必須設法留下解題或思考的歷程資料, 並適時發布相關心得, 以便提供他人參考.</li>
</ol>
<p>一般來說採用計算機解決問題牽涉程式語言, 演算法與資料結構等三大類. 在這一門課程中:</p>
<ol>
<li>程式語言主要採用 Python, 但也會提到 Javascript 與其他相關程式語言.</li>
<li>演算法沒有特別指名, 而是逐步從直覺的解題方式進行推演, 針對比較複雜的問題, 再從<a href="http://mde.tw/cp2021/downloads/ProblemSolvingwithAlgorithmsandDataStructures.pdf">演算法與資料結構電子書</a>中尋找可能的解題方法.</li>
<li>至於資料結構或資料庫, 在這裡並不會深入探討, 但是隨著工程問題的複雜化, 最終仍必須將許多流程以 bot (例如: <a href="http://mde.tw/cp2021/content/RPA.html">RPA</a>) 的方式安排, 自然也就避不開要學習使用合適的資料結構進行檔案收集與儲存.</li>
</ol>
<p>接下來我們希望在 Stage1 的任務工作項目中, 將一方面練習 Python 程式語法, 並逐步導入使用可攜與分散式版次管理系統:</p>
<p>Task1: 在<a href="https://mde.tw/cp2021/content/%E8%A7%A3%E9%A1%8C%E7%B7%B4%E7%BF%92.html">解題練習</a>網頁上學習簡單的 Python</p>
<p>Task2: 下載客製化的可攜程式系統</p>
<p>Task3: 使用 git 分散式版次管理</p>
<h3>Task1</h3>
<p>在<a href="https://mde.tw/cp2021/content/%E8%A7%A3%E9%A1%8C%E7%B7%B4%E7%BF%92.html">解題練習</a>網頁上學習簡單的 Python</p>
<p style="padding-left: 30px;">在進入 Task1 之前, 可以先在<a href="https://mde.tw/cp2021/content/%E8%A7%A3%E9%A1%8C%E7%B7%B4%E7%BF%92.html">解題練習</a>網頁上, 跟著 <a href="/downloads/Non-Programmers_Tutorial_for_Python_3.pdf">Non-Programmers_Tutorial_for_Python_3.pdf</a> 的內容, 感受一下 Python 程式的用法.</p>
<p>Task1 將要開始利用"<a href="/get_page/%E8%A7%A3%E9%A1%8C%E7%B7%B4%E7%BF%92">解題練習</a>"頁面, 學習如何利用 Python 解決問題. 由於目前第一階段的學習希望利用網頁的方式執行 Python, 因此是透過 Brython 的程式庫達成, 使用者在網頁上編寫 Python 程式碼, 然後透過 Brython 即時將 Python 程式碼轉為 Javascript, 並且直接在網頁上執行.</p>
<p>我們希望解決的第一個問題是: 如何利用電腦畫圖, 比方說, 在螢幕上畫一個小紅色方塊, 大小為 20x20 pixel.</p>
<p>首先讓瀏覽器指向解題練習的頁面, 然後在程式表單中輸入下列程式碼, 第一次為了快速看到執行結果, 可以使用 Ctrl + C 與 Ctrl + V 將下列的程式碼複製貼上, 然後點擊 Run.</p>
<p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
</p>
<!-- for ggame -->
<p>
<script src="/static/jquery-3.3.1.min.js"></script>
<script src="/static/jquery-ui.1.12.1.min.js"></script>
<script src="/static/pixi-3.0.5.min.js"></script>
<script src="/static/buzz-1.2.1.js"></script>
<script src="/static/bs.js"></script>
<script src="/downloads/brython_modules.js"></script>
</p>
<!-- Cango 程式庫 -->
<p>
<script src="/static/Cango-13v08-min.js"></script>
<script src="/static/CangoAxes-4v01-min.js"></script>
<script src="/static/gearUtils-05.js"></script>
</p>
<!-- for Konva 程式庫 -->
<p>
<script src="/static/konva.min.js"></script>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
</p>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<p><!-- 印出程式1--></p>
<p>
<script type="text/python3">
from browser import document as doc
from browser import html
import ace
# 清除畫布
def clear_bd(ev):
    bd = doc["brython_div"]
    bd.clear()
# Brython 內建的 container 名稱為  'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id
Ace = ace.Editor(editor_id="kw_editor", console_id="kw_console", container_id="kw__container", storage_id="kw_py_src" )
Ace.editor.setValue("""from browser import html
from browser import document as doc

canvas = html.CANVAS(width = 400, height = 100)
canvas.id = "game-board"
brython_div = doc["brython_div"]
brython_div <= canvas

ctx = canvas.getContext("2d")
ctx.fillStyle = "black"
ctx.fillRect(0, 0, canvas.width, canvas.height)""")
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)
# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run'].bind('click', Ace.run)
doc['kw_show_console'].bind('click', Ace.show_console)
doc['kw_clear_console'].bind('click', Ace.clear_console)
doc['clear_bd'].bind('click', clear_bd)
</script>
</p>
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src', 'kw_filename');" type="submit" value="Save"/></form>
<p><button id="kw_run">Run</button> <button id="kw_show_console">Output</button> <button id="kw_clear_console">清除輸出區</button><button id="clear_bd">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console"></textarea></div>
<div id="brython_div"></div>
<!-- 結束列印程式 1 -->
<p>假如您看到畫面下方出現一片黑, 這就對了, 接下來我們來看, 為什麼幾行程式碼可以利用 <a href="https://developer.mozilla.org/en-US/docs/Glossary/HTML">html</a> webgl 規格中的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API">canvas</a> API在網頁中繪圖.</p>
<p>執行上面這個程式, 衍生出下列疑問:</p>
<p>什麼是 html?</p>
<p>什麼是 webgl?</p>
<p style="padding-left: 30px;"><a href="https://link.springer.com/book/10.1007/978-1-4302-3997-0">Beginning WebGL for HTML5</a> (從校園網路中下載電子書)</p>
<p>什麼是 canvas?</p>
<p>什麼是 Context?</p>
<p>什麼是 API?</p>
<p>說好的 Python  程式碼在哪裡?</p>
<p>Python 程式為什麼可以直接在網頁上畫圖? (其實不是直接, 而是透過 Brython 程式庫轉為 Javascript 後執行)</p>
<p>請試著摸索一下上面的原始碼, 您可以把它修改為, 讓它在網頁中劃出一個左上角座標位於 (100, 100) 且長寬為20x20 pixel (pixel 是什麼?) 大小的紅色區域嗎?</p>
<p>假如將上面的程式改為下列程式碼, 且按一下"清除繪圖區"以及"清除輸出區"等按鈕, 再按下 Run, 應該就可以在左上角座標位於 (100, 100) 的紅色方塊:</p>
<p><!-- 印出程式2--></p>
<p>
<script type="text/python3">
from browser import document as doc
from browser import html
import ace
# 清除畫布
def clear_bd2(ev):
    bd = doc["brython_div2"]
    bd.clear()
# Brython 內建的 container 名稱為  'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id
Ace2 = ace.Editor(editor_id="kw_editor2", console_id="kw_console2", container_id="kw__container2", storage_id="kw_py_src2" )
Ace2.editor.setValue("""from browser import html
from browser import document as doc

canvas = html.CANVAS(width = 400, height = 100)
canvas.id = "game-board2"
brython_div = doc["brython_div2"]
brython_div <= canvas

ctx = canvas.getContext("2d")
ctx.fillStyle = "red"
ctx.fillRect(200, 50, 20, 20)""")
Ace2.editor.scrollToRow(0)
Ace2.editor.gotoLine(0)
# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run2'].bind('click', Ace2.run)
doc['kw_show_console2'].bind('click', Ace2.show_console)
doc['kw_clear_console2'].bind('click', Ace2.clear_console)
doc['clear_bd2'].bind('click', clear_bd2)
</script>
</p>
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor2" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<form><label>Filename: <input id="kw_filename2" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src2', 'kw_filename2');" type="submit" value="Save"/></form>
<p><button id="kw_run2">Run</button> <button id="kw_show_console2">Output</button> <button id="kw_clear_console2">清除輸出區</button><button id="clear_bd2">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console2"></textarea></div>
<div id="brython_div2"></div>
<!--  結束列印程式 2 -->
<p>其中有關 fillRect() 函式的定義在<a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillRect">這裡</a>. 表示前兩個輸入變數為座標, 而後兩個輸入變數則分別為四邊形 (Rectangle) 的 width 與 height.</p>
<p>假如我們又學會使用 Brython 的 <a href="https://brython.info/static_doc/en/timer.html">browser.timer</a> 中 set_interval 的用法, 並且將顯示與抹除紅色方塊區域的程式寫入函式 (Function), 並且利用判斷式限制其運動範圍, 就可以讓紅色方塊動起來:</p>
<p><!-- 印出程式3--></p>
<p>
<script type="text/python3">
from browser import document as doc
from browser import html
import ace
# 清除畫布
def clear_bd3(ev):
    bd = doc["brython_div3"]
    bd.clear()
# Brython 內建的 container 名稱為  'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id
Ace3 = ace.Editor(editor_id="kw_editor3", console_id="kw_console3", container_id="kw__container3", storage_id="kw_py_src3" )
Ace3.editor.setValue("""from browser import html
from browser import document as doc
import browser.timer

canvas = html.CANVAS(width = 400, height = 100)
canvas.id = "game-board3"
brython_div = doc["brython_div3"]
brython_div <= canvas
ctx = canvas.getContext("2d")
px = 0
py = 50
width = 20
height = 20
speed = 2

def game():
    global px, py, width, height, speed
    ctx.clearRect(px, py, width, height)
    ctx.fillStyle = "red"
    px += speed
    if px < 0 or (px + width) > canvas.width:
        speed = -speed
    ctx.fillRect(px, py, width, height)
    
browser.timer.set_interval(game, 10)""")
Ace3.editor.scrollToRow(0)
Ace3.editor.gotoLine(0)
# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run3'].bind('click', Ace3.run)
doc['kw_show_console3'].bind('click', Ace3.show_console)
doc['kw_clear_console3'].bind('click', Ace3.clear_console)
doc['clear_bd3'].bind('click', clear_bd3)
</script>
</p>
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor3" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<form><label>Filename: <input id="kw_filename3" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src3', 'kw_filename3');" type="submit" value="Save"/></form>
<p><button id="kw_run3">Run</button> <button id="kw_show_console3">Output</button> <button id="kw_clear_console3">清除輸出區</button><button id="clear_bd3">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console3"></textarea></div>
<div id="brython_div3"></div>
<!-- 結束列印程式3 -->
<p>接下來假如我們更深入研究有關物體碰撞相關的演算法, 就可以設法安排更複雜的 2D 物體碰撞模擬, 而這種透過物理碰撞邏輯或運動模擬來編寫的電腦程式, 就可以用於機械工程設計, 在機構實作測試之前, 先進行各種可行性或特性分析, 以節省測試時間與成本.</p>
<h4>Bouncing algorithm:</h4>
<p style="padding-left: 30px;"><a href="https://www.101computing.net/bouncing-algorithm/">https://www.101computing.net/bouncing-algorithm/</a></p>
<p style="padding-left: 30px;"><a href="https://stackoverflow.com/questions/19472050/bouncing-ball-between-4-walls-destination-algorithm">https://stackoverflow.com/questions/19472050/bouncing-ball-between-4-walls-destination-algorithm</a></p>
<p style="padding-left: 30px;"><a href="https://stackoverflow.com/questions/8715592/bouncing-ball-logics">https://stackoverflow.com/questions/8715592/bouncing-ball-logics</a></p>
<h4>Brython:</h4>
<p style="padding-left: 30px;"><a href="https://brython.info/static_doc/en/intro.html">https://brython.info/static_doc/en/intro.html</a></p>
<p style="padding-left: 30px;"><a href="https://brython.info/static_doc/en/timer.html">https://brython.info/static_doc/en/timer.html</a></p>
<h3>HW_template</h3>
<p>cp2021 作業網站 template:<br/><br/><a href="https://github.com/mdecourse/cp2021_hw">https://github.com/mdecourse/cp2021_hw</a> <br/><br/>作業 template 網站: <a href="https://mde.tw/cp2021_hw">https://mde.tw/cp2021_hw</a> <br/><br/>由於遠端電腦擷取校內數位資源時必須使用 nfu 的 vpn, 因此各學員必須按照<a href="https://www.nfu.edu.tw/zh/approved-news-nfu/approved-news-adm/8102-110%E5%AD%B8%E5%B9%B4%E5%BA%A6ssl-vpn%E9%80%A3%E7%B7%9A%E9%96%8B%E9%80%9A%E7%94%B3%E8%AB%8B%E5%85%AC%E5%91%8A">說明</a>, 完成本學期的 vpn 使用申請.</p>
<p>在 cp2021 計算機程式所編寫的網際程式, 之後可以設法與遠端伺服器 (虛實主機或 Heroku 雲端主機) 結合應用. 假如其中一台遠端伺服器中可以配置 Solidworks, Inventor, NX 或 Solvespace (請參考 <a href="https://mde.tw/cad2021/content/HW_template.html">cad2021_hw 套件應用</a>), 將可以網際程式作為介面, 使用 AJAX 技術將需求送至遠端伺服器中執行. 也可透過分散式運算設法安排最佳化設計運算.</p>
<p>在電腦輔助設計實習課程中所使用的<a href="https://mde.tw/cad2021/content/run.html?src=https://gist.githubusercontent.com/mdecourse/6d0b8df27021529f910cbd0fde2222b6/raw/a56ead50390efaa47e1497286903feb8fb62d80d/distrubute_cad_combination.py">程式套件分配</a>, 即近端網際程式 (Brython) + Heroku 雲端主機 (Flask) + 學校教務伺服器 (PHP server) 結合應用範例.</p>
<p></p>
<p></p><h3>Task2</h3>
<h4>下載客製化的可攜程式系統</h4>
<p>客製化是一個希望讓每位客戶都能滿意的服務, 當需求變更時, 客戶可以自己調整安排每一個細節, 讓流程達到盡善盡美, 而在利用電腦與計算機程式解題的過程, 也是如此.</p>
<p>在此我們希望打造一個能夠客製化的可攜程式系統, 以便有效利用計算機程式方法解決問題.</p>
<p>而 Task1 這個工作任務希望解決下列問題:</p>
<ol>
<li>可以利用可攜 SSD 碟存放個人化的程式系統與隱私資料 (SSH private key)</li>
<li>可以設法保留每一個電腦工作階段 (Sessions) 所儲存的檔案版本</li>
<li>不用擔心近端 (Local) 電腦硬體毀損後, 丟失任何一個工作階段所儲存的資料內容</li>
</ol>
<p>現代人已經很熟悉利用數位裝置彼此之間的認證 (Certification) 傳遞重要資料, 其中包括金流與隱私資料 (例如:信件,線上對話與健保卡存取等), 身為一個機械設計工程師必須學會保護個人的身分 (Identity) 資料 (例如: 電子郵箱帳號以及手機實名登錄的各種 Apps 帳號), 只是當我們身為客戶 (Client) 時, 是使用別人所打造的系統服務. 而機械設計工程師則需要打造讓其他人使用的各種服務, 因為所有的實體製造零組件, 源頭都是從我們所建構的 3D 虛擬檔案逐一 realized 的.</p>
<p>以上這段文字有下列關鍵字:</p>
<ol>
<li>SSD</li>
<li>Private key</li>
<li>Sessions</li>
<li>Local</li>
<li>Certification</li>
<li>Identity</li>
<li>Apps</li>
<li>Client</li>
<li>Realized</li>
</ol>
<p>Task2 就是希望在打造客製化可攜程式系統的同時, 先了解與這些關鍵字有關的內容. 至於所謂的"客製化可攜程式系統", 可以直接從線上下載 <a href="https://drive.google.com/file/d/1hEGgONw8ahNs7JPAKOurc7JvGfhgO2zY/view?usp=sharing">compile_copsim_for_pj2022.7z</a> (download file size 4 GB, uncompressed file size 14 GB). 你可以先在電腦輔助設計室中的電腦桌面展開壓縮檔案. 但最終希望可以將可攜系統全部或部份資料存入個人的 USB 隨身碟.</p>
<ol>
<li>假如 USB 隨身碟存取速度夠快, 可以將 <a href="https://drive.google.com/file/d/1hEGgONw8ahNs7JPAKOurc7JvGfhgO2zY/view?usp=sharing">compile_copsim_for_pj2022.7z</a> 14GB 的檔案存入</li>
<li>但是假如 USB 隨身碟存取速度不夠快 (請參見<a href="https://www.tripplite.com/products/usb-connectivity-types-standards">相關規格</a>), 可以採用 <a href="https://mde.tw/wcmj2021/content/Hybrid%20System.html">Hybrid System</a> 的方式, 僅將啟動檔案與 home_ipv6 以及其他必要檔案存在 USB 隨身碟, 並透過 start.bat 取用存在 C 槽硬碟中的其他檔案.</li>
</ol>
<h4>Task2 實習內容:</h4>
<ol>
<li>下載 <a href="https://drive.google.com/file/d/1hEGgONw8ahNs7JPAKOurc7JvGfhgO2zY/view?usp=sharing">compile_copsim_for_pj2022.7z</a>, 在桌面解開壓縮檔案後,點擊 start.bat, 啟動隨身系統.</li>
<li>到 <a href="https://github.com/">https://github.com/</a> 建立一個帳號, 帳號名稱可以自選, 過程中必須要進入與 Github 帳號綁定的 Email 系統完成帳號驗證後, 該 Github 帳號才能使用.</li>
<li>完成 Github 帳號認證後, 請建立一個測試用的倉儲, 倉儲名稱可以自選.</li>
<li>接下來我們要直接在線上, 利用上一個步驟所建立的倉儲, 在線上編輯一個簡單的 Python 程式檔案 (可以是上個禮拜用 random 模組隨機產生整數的程式碼), 並改版三次 (可以利用 Task1 頁面中的三個程式碼).</li>
<li>最後一個步驟是, 學習如何在這個 Github 倉儲, 找出這個 Python 程式的三個改版前與改版後的內容.</li>
</ol>
<p></p>
<p></p>
<h3>Task3</h3>
<h4>使用 git 分散式版次管理</h4>
<p style="padding-left: 30px;"><a href="https://mde.tw/cad2021/downloads/Version%20Control%20(%20git_github).pdf">https://mde.tw/cad2021/downloads/Version%20Control%20(%20git_github).pdf</a></p>
<p style="padding-left: 30px;"><a href="https://www.nobledesktop.com/blog/what-is-git-and-why-should-you-use-it">https://www.nobledesktop.com/blog/what-is-git-and-why-should-you-use-it</a></p>
<p style="padding-left: 30px;"><a href="https://www.git-tower.com/learn/git/ebook/en/command-line/appendix/why-git/">https://www.git-tower.com/learn/git/ebook/en/command-line/appendix/why-git/</a></p>
<p style="padding-left: 30px;"><a href="https://www.freecodecamp.org/news/what-is-git-and-how-to-use-it-c341b049ae61/">https://www.freecodecamp.org/news/what-is-git-and-how-to-use-it-c341b049ae61/</a></p>
<p>請登入 @gm 帳號後, 下載 <a href="https://drive.google.com/file/d/1LW-UHAY9Hgvnfk14Cknt3PXFNr6huw9t/view?usp=sharing">cp2021_textbook.pdf</a> 課程教材.</p>
<p>在 Task3 工作項目中, 希望能將 Task1 與 Task2 已經練習過的 Python 程式碼, 存入 Github 倉儲管理 (可以放入自己倉儲中的 downloads 目錄以及 <a href="https://docs.github.com/en/github/writing-on-github/editing-and-sharing-content-with-gists/creating-gists">Gist</a>), 並逐步根據 <a href="https://drive.google.com/file/d/1LW-UHAY9Hgvnfk14Cknt3PXFNr6huw9t/view?usp=sharing">cp2021_textbook.pdf</a> 學習 Python 相關用法. 目的是有能力直接在 Brython 的環境中修改貪食蛇遊戲的程式碼.</p>
<p>以下為按下 Run 之後, 可以利用 i, j, l, m 等鍵盤上的 key 控制 snake 的移動方向:</p>
<!-- 導入 brython -->
<p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
</p>
<!-- for ggame -->
<p>
<script src="/static/jquery-3.3.1.min.js"></script>
<script src="/static/jquery-ui.1.12.1.min.js"></script>
<script src="/static/pixi-3.0.5.min.js"></script>
<script src="/static/buzz-1.2.1.js"></script>
<script src="/static/bs.js"></script>
<script src="/downloads/brython_modules.js"></script>
</p>
<!-- Cango 程式庫 -->
<p>
<script src="/static/Cango-13v08-min.js"></script>
<script src="/static/CangoAxes-4v01-min.js"></script>
<script src="/static/gearUtils-05.js"></script>
</p>
<!-- for Konva 程式庫 -->
<p>
<script src="/static/konva.min.js"></script>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
</p>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<p><!-- 印出程式1--></p>
<p>
<script type="text/python3">
from browser import document as doc
from browser import html
import ace
# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()
# Brython 內建的 container 名稱為  'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id
Ace1 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )
Ace1.editor.setValue("""# 從 browser 導入 document 並設為 doc
from browser import document as doc
# 使用者可以透過 window 當作介面使用其他 Javascript 功能
from browser import html, window
# 用於定時執行特定函式
import browser.timer
# 導入數學模組
import math
# 導入亂數模組
from random import random, randint

def update_score(new_score):
    global high_score
    score_doc.innerHTML = "Score: " + str(new_score)
    if new_score > high_score:
        high_score_doc.innerHTML = "High Score: " + str(new_score)
        high_score = new_score
    
def game():
    global px, py, tc, gs, ax, ay, trail, tail, score
    # px 為 snake 第一個點的 x 座標, 增量值為 xv
    px += xv
    py += yv
    # 允許穿越四面牆, 以 tc 表示牆面座標極限
    # 若 px 為負值則設定為 tc -1, 表示 tc 為 x 方向 limit
    # x 座標方向的穿牆設定
    if px < 0:
        px = tc-1
    if px > tc-1:
        px = 0
    # y 座標方向的穿牆設定
    if py < 0:
        py = tc-1
    if py > tc-1:
        py = 0
    ctx.fillStyle = "black"
    # 畫布填入黑色
    ctx.fillRect(0, 0, canvas.width, canvas.height)
    # snake 為 lime 色
    ctx.fillStyle = "lime"
    # trail 為數列, 代表 snake 各節 [x,y] 座標
    # trail = [[x0,y0], [x1, y1], [x2, y2]...]
    # gs 為方塊邊長 pixel 數
    for i in range(len(trail)):
        # https://developer.mozilla.org/zh-TW/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes
        # fillRect(x, y, width, height)
        ctx.fillRect(trail[i][0]*gs, trail[i][1]*gs, gs-2, gs-2)
        # 若 snake 第一節座標 (px, py)  穿過身體任一節, 則 score 歸零
        if trail[i][0] == px and trail[i][1] == py:
            score = score if paused else 0
            # snake reset 為五節
            tail = 5
    # trail 數列以碰到的 [px, py] 座標數列插入作為第一節
    trail.insert(0, [px, py])
    while len(trail) > tail:
        # pop() 內建移除數列最後一個 element
        trail.pop()
    # ax, ay 為紅點座標
    # 當 snake 第一節座標[px, py] 與紅色食物座標 [ax, ay] 重合
    # 則 tail 增量, 即多一節且得分加 1, 然後食物座標 [ax, ay] 重新以亂數定位
    if ax == px and ay == py:
        tail += 1
        ax = math.floor(random()*tc)
        ay = math.floor(random()*tc)
        score += 1
    # 更新計分顯示
    update_score(score)
    ctx.fillStyle = "red"
    ctx.fillRect(ax*gs, ay*gs, gs-2, gs-2)
  
def key_push1(evt):
    global xv, yv, pre_pause, paused
    key = evt.keyCode
    # 37 is left arrow key
    # 74 is j key
    if key == 74 and not paused:
        xv = -1
        yv = 0
    # 38 is up arrow key
    # 73 is i key
    elif key == 73 and not paused:
        xv = 0
        yv = -1
    # 39 is right arrow key
    # 76 is l key
    elif key == 76 and not paused:
        xv = 1
        yv = 0
    # 40 is down arrow key
    # 77 is m key
    elif key == 77 and not paused:
        xv = 0
        yv = 1
    # 32 is pause key
    # 80 is p key
    elif key == 80:
        temp = [xv, yv]
        xv = pre_pause[0]
        yv = pre_pause[1]
        pre_pause = [*temp]
        paused = not paused
  
def show_instructions1(evt):
        window.alert("keys to control: i=up, m=down, j=left, l=right, p=pause")
      
# 利用 html 建立 canvas 超文件物件
canvas = html.CANVAS(width = 600, height = 600)
canvas.id = "game-board1"
brython_div = doc["brython_div1"]
brython_div <= canvas
  
score_doc = html.DIV("score1")
score_doc.id = "score1"
brython_div <= score_doc
  
high_score_doc = html.DIV("high-score1")
high_score_doc.id = "high-score1"
brython_div <= high_score_doc
  
button = html.BUTTON("Keys to control1")
button.id = "instructions-btn1"
brython_div <= button
  
score = 0
high_score = 0
  
px = py = 10
# gs*tc = canvas width and height
gs = 20
tc = 30
ax = ay = 15
xv = yv = 0
trail = []
tail = 5
  
pre_pause = [0,0]
paused = False
ctx = canvas.getContext("2d")
doc.addEventListener("keydown", key_push1)
instructions_btn = doc["instructions-btn1"]
instructions_btn.addEventListener("click", show_instructions1)
browser.timer.set_interval(game, 1000/15)""")
Ace1.editor.scrollToRow(0)
Ace1.editor.gotoLine(0)
# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run1'].bind('click', Ace1.run)
doc['kw_show_console1'].bind('click', Ace1.show_console)
doc['kw_clear_console1'].bind('click', Ace1.clear_console)
doc['clear_bd1'].bind('click', clear_bd1)
</script>
</p>
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor1" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<form><label>Filename: <input id="kw_filename1" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src1', 'kw_filename1');" type="submit" value="Save"/></form>
<p><button id="kw_run1">Run</button> <button id="kw_show_console1">Output</button> <button id="kw_clear_console1">清除輸出區</button><button id="clear_bd1">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console1"></textarea></div>
<div id="brython_div1"></div>
<p><!-- 結束列印程式1 --></p>
<p>而下列程式的貪食蛇遊戲則是根據紅色球的位置, 自動導引 snake 前往吞食, 但有時會穿越自己身體而遭截斷, 因此希望能夠導入更好的導引模式, 找出此一遊戲可取得的最長 snake 紀錄.</p>
<p><!-- 印出程式2--></p>
<p>
<script type="text/python3">
from browser import document as doc
from browser import html
import ace
# 清除畫布
def clear_bd2(ev):
    bd = doc["brython_div2"]
    bd.clear()
# Brython 內建的 container 名稱為  'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id
Ace2 = ace.Editor(editor_id="kw_editor2", console_id="kw_console2", container_id="kw__container2", storage_id="kw_py_src2" )
Ace2.editor.setValue("""# 從 browser 導入 document 並設為 doc
from browser import document as doc
# 使用者可以透過 window 當作介面使用其他 Javascript 功能
from browser import html, window
# 用於定時執行特定函式
import browser.timer
# 導入數學模組
import math
# 導入亂數模組
from random import random, randint
 
def update_score2(new_score):
    global high_score
    score_doc.innerHTML = "Score: " + str(new_score)
    if new_score > high_score:
        high_score_doc.innerHTML = "High Score: " + str(new_score)
        high_score = new_score
        
def eat(px, py, ax, ay):
    global xv, yv, pre_pause, paused
    # (px, py) go to (ax, ay) through incremented xv, yv
    if ax != px or ay != py:
        if ax > px and not paused:
            xv = 1
            yv = 0
        if ax < px and not paused:
            xv = -1
            yv = 0
        if ay > py and not paused:
            xv = 0
            yv = 1
        if ay < py and not paused:
            xv = 0
            yv = -1
            
def game2():
    global px, py, tc, gs, ax, ay, trail, tail, score
    # px 為 snake 第一個點的 x 座標, 增量值為 xv
    px += xv
    py += yv
    # 允許穿越四面牆, 以 tc 表示牆面座標極限
    # 若 px 為負值則設定為 tc -1, 表示 tc 為 x 方向 limit
    # x 座標方向的穿牆設定
    if px < 0:
        px = tc-1
    if px > tc-1:
        px = 0
    # y 座標方向的穿牆設定
    if py < 0:
        py = tc-1
    if py > tc-1:
        py = 0
    ctx.fillStyle = "black"
    # 畫布填入黑色
    ctx.fillRect(0, 0, canvas.width, canvas.height)
    # snake 為 lime 色
    ctx.fillStyle = "lime"
    # trail 為數列, 代表 snake 各節 [x,y] 座標
    # trail = [[x0,y0], [x1, y1], [x2, y2]...]
    # gs 為方塊邊長 pixel 數
    for i in range(len(trail)):
        # https://developer.mozilla.org/zh-TW/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes
        # fillRect(x, y, width, height)
        ctx.fillRect(trail[i][0]*gs, trail[i][1]*gs, gs-2, gs-2)
        # 若 snake 第一節座標 (px, py)  穿過身體任一節, 則 score 歸零
        if trail[i][0] == px and trail[i][1] == py:
            score = score if paused else 0
            # snake reset 為五節
            tail = 5
    # trail 數列以碰到的 [px, py] 座標數列插入作為第一節
    trail.insert(0, [px, py])
    while len(trail) > tail:
        # pop() 內建移除數列最後一個 element
        trail.pop()
    # ax, ay 為紅點座標
    # 當 snake 第一節座標[px, py] 與紅色食物座標 [ax, ay] 重合
    # 則 tail 增量, 即多一節且得分加 1, 然後食物座標 [ax, ay] 重新以亂數定位
    if ax == px and ay == py:
        tail += 1
        ax = math.floor(random()*tc)
        ay = math.floor(random()*tc)
        score += 1
    # [ax, ay] is known here
    # [px, py] is where the head of the snake
    # xv needed to be incremented from px to ax first
    # and yv needed to be incremented from py to ay
    eat(px, py, ax, ay)
    # 更新計分顯示
    update_score2(score)
    ctx.fillStyle = "red"
    ctx.fillRect(ax*gs, ay*gs, gs-2, gs-2)
   
def key_push2(evt):
    global xv, yv, pre_pause, paused
    key = evt.keyCode
    # 37 is left arrow key
    # 74 is j key
    if key == 74 and not paused:
        xv = -1
        yv = 0
    # 38 is up arrow key
    # 73 is i key
    elif key == 73 and not paused:
        xv = 0
        yv = -1
    # 39 is right arrow key
    # 76 is l key
    elif key == 76 and not paused:
        xv = 1
        yv = 0
    # 40 is down arrow key
    # 77 is m key
    elif key == 77 and not paused:
        xv = 0
        yv = 1
    # 32 is pause key
    # 80 is p key
    elif key == 80:
        temp = [xv, yv]
        xv = pre_pause[0]
        yv = pre_pause[1]
        pre_pause = [*temp]
        paused = not paused
   
def show_instructions2(evt):
        window.alert("keys to control: i=up, m=down, j=left, l=right, p=pause")
       
# 利用 html 建立 canvas 超文件物件
canvas = html.CANVAS(width = 600, height = 600)
canvas.id = "game-board2"
brython_div = doc["brython_div2"]
brython_div <= canvas
   
score_doc = html.DIV("score2")
score_doc.id = "score2"
brython_div <= score_doc
   
high_score_doc = html.DIV("high-score2")
high_score_doc.id = "high-score2"
brython_div <= high_score_doc
   
button = html.BUTTON("Keys to control")
button.id = "instructions-btn2"
brython_div <= button
   
score = 0
high_score = 0
   
px = py = 10
# gs*tc = canvas width and height
gs = 20
tc = 30
ax = ay = 15
xv = yv = 0
trail = []
tail = 5
   
pre_pause = [0,0]
paused = False
ctx = canvas.getContext("2d")
doc.addEventListener("keydown", key_push2)
instructions_btn = doc["instructions-btn2"]
instructions_btn.addEventListener("click", show_instructions2)
browser.timer.set_interval(game2, 1000/15)""")
Ace2.editor.scrollToRow(0)
Ace2.editor.gotoLine(0)
# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run2'].bind('click', Ace2.run)
doc['kw_show_console2'].bind('click', Ace2.show_console)
doc['kw_clear_console2'].bind('click', Ace2.clear_console)
doc['clear_bd2'].bind('click', clear_bd2)
</script>
</p>
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor2" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<form><label>Filename: <input id="kw_filename2" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src2', 'kw_filename2');" type="submit" value="Save"/></form>
<p><button id="kw_run2">Run</button> <button id="kw_show_console2">Output</button> <button id="kw_clear_console2">清除輸出區</button><button id="clear_bd2">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console2"></textarea></div>
<div id="brython_div2"></div>
<p><!-- 結束列印程式2 --></p>
<p>其實當我們在計算機程式課程中推出利用網際上的 Python 來練習計算機程式的目的, 是希望能夠在機械設計工程師的數位養成教育流程中, 了解到最終利用電腦解決工程問題的時候, 必須逐步透過演算法與資料結構, 讓程式能夠具備"學習能力", 也就是採用所謂的機器學習或人工智慧的方法.</p>
<p>以下列這篇論文為例:</p>
<p style="padding-left: 30px;"><a href="/downloads/Greedy Best First Search in Automated Snake Game Solvers.pdf">Greedy Best First Search in Automated Snake Game Solvers.pdf</a> (<a href="https://informatika.stei.itb.ac.id/~rinaldi.munir/Stmik/2019-2020/Makalah/stima2020k3-032.pdf">Source</a>)</p>
<p style="padding-left: 30px;">原始碼位於: <a href="https://github.com/mdecourse/snake-bot">https://github.com/mdecourse/snake-bot</a></p>
<p style="padding-left: 30px;">這個程式需要 <a href="https://www.pygame.org">PyGame</a> 才能執行. 假如在 Linux 與 MacOS, 需要安裝 pygame 模組.</p>
<p style="padding-left: 60px;">pip3 install pygame</p>
<p style="padding-left: 30px;">假如是在 Windows, 則直接以 pip 安裝 pygame 模組.</p>
<p style="padding-left: 60px;">pip install pygame</p>
<p>本課程的進階練習, 就是希望將 Greedy Best First Search 搜尋方法套用到本頁的網頁 Python 架構中.</p>
<h4>參考資料:</h4>
<p style="padding-left: 30px;"><a href="https://www.mygreatlearning.com/blog/best-first-search-bfs/">https://www.mygreatlearning.com/blog/best-first-search-bfs/</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/topics/greedy-best-first-search?l=python">https://github.com/topics/greedy-best-first-search?l=python</a></p>
<p style="padding-left: 30px;"><a href="https://www.javatpoint.com/ai-informed-search-algorithms">https://www.javatpoint.com/ai-informed-search-algorithms</a></p>
<p style="padding-left: 30px;"><a href="https://en.wikipedia.org/wiki/Best-first_search">https://en.wikipedia.org/wiki/Best-first_search</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/mdecourse/snake">https://github.com/mdecourse/snake</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/mdecourse/snake-1">https://github.com/mdecourse/snake-1</a></p>
<p style="padding-left: 30px;"><a href="/downloads/graph_search_algorithm.pdf">graph_search_algorithm.pdf</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/mdecourse/snake-Q-Learning">https://github.com/mdecourse/snake-Q-Learning</a> 中所使用的 Pygame 可以 <a href="https://github.com/yakkomajuri/brython-snake">brython-snake</a> 取代, numpy 可以採 <a href="https://github.com/nicolaspanel/numjs">https://github.com/nicolaspanel/numjs</a> 取代.</p>
<p style="padding-left: 60px;"><a href="https://github.com/mdecourse/Snake-Q-Learning-1">https://github.com/mdecourse/Snake-Q-Learning-1</a></p>
<p style="padding-left: 60px;"><a href="https://github.com/mdecourse/simple-neural-network-js">https://github.com/mdecourse/simple-neural-network-js</a></p>
<p style="padding-left: 60px;"><a href="https://github.com/StratoDem/pandas-js">https://github.com/StratoDem/pandas-js</a></p>
<p style="padding-left: 30px;"><a href="https://towardsdatascience.com/teaching-a-computer-how-to-play-snake-with-q-learning-93d0a316ddc0">https://towardsdatascience.com/teaching-a-computer-how-to-play-snake-with-q-learning-93d0a316ddc0</a></p>
<p style="padding-left: 60px;"><a href="https://en.wikipedia.org/wiki/Bellman_equation">https://en.wikipedia.org/wiki/Bellman_equation</a></p>
<p style="padding-left: 60px;"><a href="https://www.youtube.com/watch?v=14BfO5lMiuk">https://www.youtube.com/watch?v=14BfO5lMiuk</a> </p>
<p style="padding-left: 60px;"><a href="https://towardsdatascience.com/the-bellman-equation-59258a0d3fa7">https://towardsdatascience.com/the-bellman-equation-59258a0d3fa7</a></p>
<h4 style="padding-left: 30px;">Hard coded vs. Dynamic programming:</h4>
<p style="padding-left: 30px;"><a href="https://davideliu.com/2020/01/24/teaching-ai-to-play-snake-with-reinforcement-learning/">https://davideliu.com/2020/01/24/teaching-ai-to-play-snake-with-reinforcement-learning/</a></p>
<p style="padding-left: 60px;"><a href="https://github.com/mdecourse/Snake-Battle-Royale">https://github.com/mdecourse/Snake-Battle-Royale</a> (opencv)</p>
<p style="padding-left: 30px;"><a href="https://github.com/mdecourse/q-learning-snake">https://github.com/mdecourse/q-learning-snake</a> (Javascript)</p>
<p style="padding-left: 30px;"><a href="https://github.com/mdecourse/Q-Snake">https://github.com/mdecourse/Q-Snake</a> (Javascript)</p>
<p style="padding-left: 60px;"><a href="https://sid-sr.github.io/Q-Snake/">https://sid-sr.github.io/Q-Snake/</a></p>
<p style="padding-left: 60px;"><a href="https://en.wikipedia.org/wiki/Q-learning">https://en.wikipedia.org/wiki/Q-learning</a> </p><h2>Stage2</h2>
<h4>期末專案:</h4>
<p style="padding-left: 30px;">請各學員登入 github.com 後, 連結至 <a href="https://github.com/mdecourse/webgame">https://github.com/mdecourse/webgame</a> 選擇將 webgame 倉儲作為 template 後新增網際程式倉儲. 利用 Github Pages 建立一個線上遊戲.</p>
<h4 style="padding-left: 30px;">範例:</h4>
<p style="padding-left: 60px;"><a href="https://github.com/D4rk1n/JS-Flappy-Bird">https://github.com/D4rk1n/JS-Flappy-Bird</a></p>
<p style="padding-left: 60px;"><a href="https://github.com/ondras/custom-tetris">https://github.com/ondras/custom-tetris</a></p>
<p style="padding-left: 60px;"><a href="https://github.com/MattSurabian/DuckHunt-JS">https://github.com/MattSurabian/DuckHunt-JS</a></p>
<p style="padding-left: 30px;">參考資料:</p>
<p style="padding-left: 60px;"><a href="https://link.springer.com/book/10.1007/978-1-4842-1094-9">2015 Learn Pixi.js</a> (在校園網路下載電子書)</p>
<p style="padding-left: 60px;"><a href="https://link.springer.com/book/10.1007/978-1-4842-0952-3">2015 uild Your Own 2D Game Engine and Create Great Web Games</a> (在校園網路下載電子書)</p>
<p style="padding-left: 60px;"><a href="https://link.springer.com/book/10.1007/978-1-4302-4717-3">2012 Foundation Game Design with HTML5 and JavaScript</a> (在校園網路下載電子書)</p>
<p style="padding-left: 60px;"><a href="https://link.springer.com/book/10.1007/978-1-4842-1097-0">2017 The Advanced Game Developer's Toolkit</a> (在校園網路下載電子書)</p>
<p style="padding-left: 60px;"><a href="https://link.springer.com/book/10.1007/978-1-4842-0952-3">2015 Build Your Own 2D Game Engine and Create Great Web Games</a> (在校園網路下載電子書)</p>
<h4>Brython tutorial</h4>
<p style="padding-left: 30px;"><a href="https://brython.info/static_tutorial/en/index.html">https://brython.info/static_tutorial/en/index.html</a></p>
<h4>WebGL</h4>
<p>以下內容取自 <a href="https://link.springer.com/book/10.1007/978-1-4302-3997-0">Beginning WebGL for HTML5</a> (從校園網路中下載電子書)</p>
<p>The HTML5 document in uses the shorter &lt;!doctype html&gt; and &lt;html&gt; declaration available <br/>in HTML5. In the &lt;head&gt; section, we set the browser title bar contents and then add some basic styling that will change the &lt;body&gt; background to gray and the &lt;canvas&gt; background to white. This is not necessary but helps us to easily see the canvas boundary. The content of the body is a single canvas element. If viewing the document with an old browser that does not support the HTML 5 canvas element, the message "Your browser does not support the HTML5 canvas element." will be displayed.</p>
<p>Getting Context</p>
<p>When we draw inside of a canvas element, we have more than one option of how we produce our image. Each option corresponds to a different application programming interface (API) with different available functionality and implementation details and is known as a particular context of the canvas. At the moment there are two canvas contexts: "2D" and "webgl". The canvas element does not really care which context we use, but it needs to explicitly know so that it can provide us with an appropriate object that exposes the desired API.</p>
<p>To obtain a context, we call the canvas method getContext. This method takes a context name as a first parameter and an optional second argument. The WebGL context name will be "webgl"</p>
<p>WebGL has a color buffer, depth buffer, and stencil buffer. A buffer is a block of memory that can be written to and read from, and temporarily stores data. The color buffer holds color information—red, green, and blue values—and optionally an alpha value that stores the amount of transparency/opacity. The depth buffer stores information on a pixel’s depth component (z-value). As the map from 3D world space to 2D screen space can result in several points being projected to the same (x,y) canvas value, the z-values are compared and only one point, usually the nearest, is kept and rendered.</p>
<p>The stencil buffer is used to outline areas to render or not render. When an area of an image is marked off to not render, it is known as masking that area. The entire image, including the masked portions, is known as a stencil. <br/>The stencil buffer can also be used in combination with the depth buffer to optimize performance by not attempting to render portions of a scene that are determined to be not viewable. By default, the color buffer’s alpha channel is enabled and so is the depth buffer, but the stencil buffer is disabled. As previously mentioned, these can be modified by specifying the second optional parameter when obtaining the WebGL context</p>
<h4>參考資料:</h4>
<p style="padding-left: 30px;"><a href="https://pypi.org/project/brip/">https://pypi.org/project/brip/</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/rayluo/easter">https://github.com/rayluo/easter</a></p><h2>Disqus</h2>
<p>試著將 <a href="https://mde.tw/eng/content/Disqus%20for%20fxxxtech.html">https://mde.tw/eng/content/Disqus%20for%20fxxxtech.html</a> 留言超文件加到這一頁.</p>
<div id="disqus_thread"></div>
<script>
/**
    *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
    *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables    */
    /*
    var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://https-mde-tw-eng.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<h2>Cango</h2>
<p>這裡所指的 Cango 為 <a href="https://www.arc.id.au/CanvasGraphics.html">https://www.arc.id.au/CanvasGraphics.html</a>, 也就是採用 Javascript 編寫的 Canvas 程式套件, 可以用來進行 2D 靜態與動態繪圖. 也有進階版的 3D 繪圖程式庫: <a href="https://www.arc.id.au/Canvas3DGraphics.html">https://www.arc.id.au/Canvas3DGraphics.html</a></p>
<p>除了 Cango 相關程式庫外, 本課程中的 <a href="https://brython.info/">Brython</a> 還會導入 <a href="https://github.com/mdecourse/sylvester">https://github.com/mdecourse/sylvester</a> 與 <a href="https://github.com/mdecourse/PrairieDraw.js">https://github.com/mdecourse/PrairieDraw.js</a>, 可以用來建構與機械設計流程相關的 2D 繪圖 (<a href="https://mde.tw/cp2021/content/run.html?src=https://gist.githubusercontent.com/mdecourse/e896a4705a95ac8cc4147b355b0e87ef/raw/76c510c47d88c9c218130a4ebb2cadf59803a3c7/cango_gear1.py">正齒輪繪圖</a>) 與動畫模擬 (<a href="https://mde.tw/cp2021/content/run.html?src=https://gist.githubusercontent.com/mdecourse/e896a4705a95ac8cc4147b355b0e87ef/raw/76c510c47d88c9c218130a4ebb2cadf59803a3c7/three_spur_rotating.py">正齒輪組囓合傳動</a>與<a href="https://mde.tw/cp2021/content/run.html?src=https://gist.githubusercontent.com/mdecourse/e896a4705a95ac8cc4147b355b0e87ef/raw/76c510c47d88c9c218130a4ebb2cadf59803a3c7/prairiedraw_fourbar.py">平面四連桿運動模擬</a>).</p>
<p>透過 <a href="https://brython.info/">Brython</a> 中的 <a href="https://brython.info/static_doc/en/javascript.html">https://brython.info/static_doc/en/javascript.html</a>, 可以試著將 Cango 程式導入 <a href="https://github.com/mdecourse/cmsimde">CMSiMDE</a> 頁面中, 學習目標是用來進行 2D/3D 機構模擬.</p>
<p>首先要在此頁導入 <a href="https://brython.info/">Brython</a>, 作法就是將 <a href="https://mde.tw/cp2021/content/Brythonsrc.html">Brythonsrc</a> 頁面的超文件碼放入本頁面.</p>
<p>接著就必須要注意有關 <a href="https://github.com/mdecourse/cmsimde">CMSiMDE</a> 程式庫的引用方式, 若採 submodule 方式引入 <a href="https://github.com/mdecourse/cmsimde">CMSiMDE</a>, 使用者並沒有修改子模組版本內容的權限, 因此若要修改 <a href="https://github.com/mdecourse/cmsimde">CMSiMDE</a> 程式庫的內容 (例如: 在此頁就是要更新 Cango 程式庫版本, 就必須進入 <a href="https://github.com/mdecourse/cmsimde">CMSiMDE</a> 的 static 目錄改版), 就必須採用不以 submodule 的方式導入 <a href="https://github.com/mdecourse/cmsimde">CMSiMDE</a>.</p>
<p>換言之, 自開學之初, 就必須要在各自的 Github 帳號下建立上述兩者採不同模式導入 <a href="https://github.com/mdecourse/cmsimde">CMSiMDE</a> 程式庫的倉儲 (一個倉儲採用 submodule 導入 <a href="https://github.com/mdecourse/cmsimde">CMSiMDE</a> (透過 <a href="https://github.com/mdecourse/cmstemplate">cmstemplate</a>), 而另一個倉儲則自行 git clone <a href="https://github.com/mdecourse/cmsimde">CMSiMDE</a> 後放入倉儲的 cmsimde 子目錄中) , 然後逐步跟著上課進度學習, 就可以逐步了解 Python, Javascript, html, css, Flask 等程式技術整合的架構與技巧, 並利用這些工具來解決機械設計問題.</p>
<p>另外, 必須要敏捷地關注與 computer programming 相關技術的發展, 目前我們正在使用 Python 與 Flask 構建的同時, 在 Windows 與 <a href="https://ubuntu.com/">Ubuntu</a> 上使用的模式並不相同. 在 Windows 我們主要是用近端動態網頁系統來維護 <a href="https://pages.github.com/">Github Pages</a> 上的靜態網頁. 若將 <a href="https://github.com/mdecourse/cmsimde">CMSiMDE</a> 放到 <a href="https://ubuntu.com/">Ubuntu</a>, 則是希望建立廣域網路上的協同主機 (如 <a href="https://github.com/mdecourse/cd2021pj1">https://github.com/mdecourse/cd2021pj1</a>), 所採用的伺服器啟動模式為 <a href="https://uwsgi-docs.readthedocs.io/en/latest/">uWSGI</a> (請參見 <a href="https://2019wcm.blogspot.com/2019/05/wcm-week-15.html">ref1</a>, <a href="https://mde.tw/cp2019/content/Ubuntu%20%E4%BC%BA%E6%9C%8D%E5%99%A8.html">ref2</a>).</p>
<p>至於目前的發展中的 <a href="https://fastapi.tiangolo.com/">FaskAPI</a> 與 <a href="https://asgi.readthedocs.io/en/latest/">ASGI</a> 正在崛起, <a href="https://flask.palletsprojects.com/en/2.0.x/">Flask</a> 與 <a href="https://uwsgi-docs.readthedocs.io/en/latest/">uWSGI</a> 在未來幾年將會逐步被這些新技術所取代. 但是大家也不用過度恐慌, 因為新技術的崛起雖然終究會取代舊技術, 但是這些舊技術就會與 IPv4 協定一樣, 還會在許多場合停留很久, 但採用舊技術所開發的解題方案, 大多只是為了除錯與維護運作, 新的解題方案大多會採用新技術, 除非條件不允許, 否則沒有理由受到舊技術的牽絆了.</p>
<p>以下的 Cango 範例採用 <a href="https://mde.tw/eng/cmsimde/static/Cango-24v03-min.js">https://mde.tw/eng/cmsimde/static/Cango-24v03-min.js</a> 因為目前 <a href="https://github.com/mdecourse/cmsimde">CMSiMDE</a> 仍使用舊版 Cango, 必須將所有範例全部改為 24v03 之後, 才會將 <a href="https://github.com/mdecourse/cmsimde">CMSiMDE</a> Cango 升級為 24v03 版.</p>
<p>根據 <a href="https://www.arc.id.au/GearDrawing.html">https://www.arc.id.au/GearDrawing.html</a> gearUtils 目前最新版仍為 09 版, 因此可以直接引用 <a href="https://github.com/mdecourse/cmsimde">CMSiMDE</a> 目前的版本.</p>
<p>根據 <a href="https://www.arc.id.au/CangoAnimationManual.html">https://www.arc.id.au/CangoAnimationManual.html</a> 取得 CangoAnimation 程式庫.</p>
<h4>以下讓使用者將 Python 範例程式存入 <a href="https://docs.github.com/en/github/writing-on-github/editing-and-sharing-content-with-gists/creating-gists">Github Gist</a> 後, 經由程式 pubic Gist URL 連結, 以按鈕放入編輯器中執行:</h4>
<!-- 導入 brython 程式庫 -->
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
<!-- 啟動 Brython -->
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<p><!-- 印出版次與關鍵字程式 --></p>
<p>
<script type="text/python3">
from browser import document as doc
from browser import html
import ace
# 清除畫布
def clear_bd(ev):
    bd = doc["brython_div"]
    bd.clear()
# Brython 3.3.4 內建的 container 名稱為  'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id
Ace = ace.Editor(editor_id="kw_editor", console_id="kw_console", container_id="kw__container", storage_id="kw_py_src" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
url = "https://gist.githubusercontent.com/mdecourse/379f02862e9dfd95dbc5241d4faa2ad4/raw/e3dc77e68bbfb8f00eef2e78d3c8d2323b0f17da/clock.py"
data = open(url).read()
Ace.editor.setValue(data)
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)
# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run'].bind('click', Ace.run)
doc['kw_show_console'].bind('click', Ace.show_console)
doc['kw_clear_console'].bind('click', Ace.clear_console)
doc['clear_bd'].bind('click', clear_bd)
</script>
</p>
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<!-- 存擋表單開始 --><form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src', 'kw_filename');" type="submit" value="Save"/></form><!-- 存擋表單結束 -->
<p></p>
<!-- 執行與清除按鈕開始 -->
<p><button id="kw_run">Run</button> <button id="kw_show_console">Output</button> <button id="kw_clear_console">清除輸出區</button><button id="clear_bd">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<!-- 執行與清除按鈕結束 -->
<p></p>
<!-- 程式編輯檔案 -->
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console"></textarea></div>
<!-- 程式輸入位置 -->
<div id="brython_div"></div>
<div class="col-md-0" height="1" id="graphics-column" width="1"></div>
<!-- 開始建立程式範例以及對應按鈕 -->
<p><button id="snake">Snake</button><button id="clock">Clock</button><button id="two_link_ik">Two link IK</button><button id="bezier">Bezier</button><button id="spur_num">Spur</button><button id="cango_spur1">Cango Spur 1</button><button id="spur_with_form">Spur with form</button><button id="four_bar">Fourbar</button><button id="cango_three_spurs">Cango three gears</button></p>
<!-- clock 開始 -->
<script type="text/python3">
# 導入 document 與 beditor
from browser import document
import beditor
# 設定按鈕 id 名稱 name 與 原始碼對應 url
name = "clock"
url = "https://gist.githubusercontent.com/mdecourse/379f02862e9dfd95dbc5241d4faa2ad4/raw/e3dc77e68bbfb8f00eef2e78d3c8d2323b0f17da/clock.py"
# 利用 open 與 read 取回原始碼
src = open(url).read()
# 將原始碼放入 editor
e = beditor.editor(src, "kw_editor", "kw_console", "kw__container", "kw_py_src")
# 設定 id 為 name 的元件按下後會執行 e.prog, 意即將原始碼放入 editor 中
document[name].bind('click', e.prog)
</script>
<!-- clock 結束 -->
<p><!-- snake 開始 -->
<script type="text/python3">
from browser import document as doc
# 導入位於 static 目錄下的 beditor.py 
import beditor
# 利用 beditor.py 中的 editor 類別建立案例, 對應到 snake
snake_url = "https://gist.githubusercontent.com/mdecourse/d306a1f57e53bfd6466eaae20bcb9439/raw/2160a12b9fec9707a120a383ed5d38b9b78a02cf/snake.py"
snake_src = open(snake_url).read()
snake = beditor.editor(snake_src, "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "snake" 的按鈕點按時, 執行 snake 物件中的 prog 方法
doc["snake"].bind('click', snake.prog)
</script>
</p>
<p><!-- snake 結束--></p>
<!-- two link robot ik starts -->
<script type="text/python3">
# based on https://mde.tw/cd2021/content/W14-W15.html
from browser import document as doc
import beditor
url = "https://gist.githubusercontent.com/mdecourse/b58d23e73ff57c9ab1334f2e01cdc6e0/raw/2a0393fff3f621bc0267f2102697e586f99b8282/two_link_ik.py"
src = open(url).read()
two_link_ik = beditor.editor(src, "kw_editor", "kw_console", "kw__container", "kw_py_src")
doc["two_link_ik"].bind('click', two_link_ik.prog)
</script>
<!-- two link robot ik ends -->
<p></p>
<!-- bezier 開始 -->
<script type="text/python3">
import beditor
from browser import document
url = "https://gist.githubusercontent.com/mdecourse/2089a943b8fc260c2ca3ce4d0c886b1f/raw/e70f973d0b58f9db5fc6932960ef633421792f35/bezier24v3.py"
src = open(url).read()
bezier = beditor.editor(src, "kw_editor", "kw_console", "kw__container", "kw_py_src")
document["bezier"].bind("click", bezier.prog)
</script>
<!-- bezier 結束 -->
<p></p>
<!-- canvas spur gear with num setting starts -->
<script type="text/python3">
from browser import document
import beditor
url = "https://gist.githubusercontent.com/mdecourse/626206cf3b2a9a9a69f7ce4bb4a116f0/raw/970e2653a7207828b3814c2c867892903734522a/spur_set_num.py"
src = open(url).read()
spur_num = beditor.editor(src, "kw_editor", "kw_console", "kw__container", "kw_py_src")
document["spur_num"].bind('click', spur_num.prog)
</script>
<!-- canvas spur gear with num setting ends -->
<p></p>
<!-- cango spur gear 1 starts -->
<script type="text/python3">
from browser import document
import beditor
url = "https://gist.githubusercontent.com/mdecourse/e896a4705a95ac8cc4147b355b0e87ef/raw/933b2c78778493c0360c2da82da6e59418557f66/cango_gear1.py"
src = open(url).read()
cango_spur1 = beditor.editor(src, "kw_editor", "kw_console", "kw__container", "kw_py_src")
document["cango_spur1"].bind("click", cango_spur1.prog)
</script>
<!-- cango spur gear 1 ends -->
<p></p>
<!-- spur with form starts -->
<script type="text/python3">
from browser import document
import beditor
url = "https://gist.githubusercontent.com/mdecourse/626206cf3b2a9a9a69f7ce4bb4a116f0/raw/970e2653a7207828b3814c2c867892903734522a/spur_set_num.py"
src = open(url).read()
spur_with_form = beditor.editor(src, "kw_editor", "kw_console", "kw__container", "kw_py_src")
document["spur_with_form"].bind("click", spur_with_form.prog)
</script>
<!-- spur with form ends -->
<p></p>
<!-- four bar starts -->
<script type="text/python3">
from browser import document
import beditor
url = "https://gist.githubusercontent.com/mdecourse/e896a4705a95ac8cc4147b355b0e87ef/raw/76c510c47d88c9c218130a4ebb2cadf59803a3c7/prairiedraw_fourbar.py"
src = open(url).read()
four_bar = beditor.editor(src, "kw_editor", "kw_console", "kw__container", "kw_py_src")
document["four_bar"].bind("click", four_bar.prog)
</script>
<!-- four bar ends -->
<p></p>
<!-- cango three spur gears starts -->
<script type="text/python3">
from browser import document
import beditor
url = "https://gist.githubusercontent.com/mdecourse/e896a4705a95ac8cc4147b355b0e87ef/raw/8954b8280c524c5781dc3c0b3565bc489d3aa3a3/three_spur_rotating.py"
src = open(url).read()
cango_three_spurs = beditor.editor(src, "kw_editor", "kw_console", "kw__container", "kw_py_src")
document["cango_three_spurs"].bind("click", cango_three_spurs.prog)
</script>
<!-- cango three spur gears ends -->
<p></p>
<!-- 導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫 -->
<script src="https://mde.tw/cp2021/cmsimde/static/Cango-24v03-min.js"></script>
<script src="https://mde.tw/cp2021/cmsimde/static/gearUtils-09.js"></script>
<script src="https://mde.tw/cp2021/cmsimde/static/SVGpathUtils-6v03-min.js"></script>
<script src="https://mde.tw/cp2021/cmsimde/static/sylvester.js"></script>
<script src="https://mde.tw/cp2021/cmsimde/static/PrairieDraw.js"></script>
<h2>rungist</h2>
<p>rungist 在頁面中採 Javascript 呼叫 Brython 函式的方式, 讓使用者可以直接以 URL Get 執行 Gist 上的 Brython 程式. 建構的目的是讓學員可以利用 URL 繳交統一格式的 Brython 作業程式. 只要在 rungist 頁面加上 ?src=gist_url, 就可以將靜態繪圖或 animation 呈現在畫面中.</p>
<p>以下連結左邊為 local 動態網頁編輯用, 而右邊的連結則為遠端 rungist 的 demo 範例.</p>
<p><a href="/get_page/rungist?src=https://gist.githubusercontent.com/mdecourse/e896a4705a95ac8cc4147b355b0e87ef/raw/8954b8280c524c5781dc3c0b3565bc489d3aa3a3/cango_gear1.py">Cango gear</a> (for local link only) (<a href="https://mde.tw/cp2021/content/rungist.html?src=https://gist.githubusercontent.com/mdecourse/e896a4705a95ac8cc4147b355b0e87ef/raw/8954b8280c524c5781dc3c0b3565bc489d3aa3a3/cango_gear1.py">Cango gear</a>)</p>
<p><a href="/get_page/rungist?src=https://gist.githubusercontent.com/mdecourse/626206cf3b2a9a9a69f7ce4bb4a116f0/raw/970e2653a7207828b3814c2c867892903734522a/spur_set_num.py">Spur with form input</a> (for local link only) (<a href="https://mde.tw/cp2021/content/rungist.html?src=https://gist.githubusercontent.com/mdecourse/626206cf3b2a9a9a69f7ce4bb4a116f0/raw/970e2653a7207828b3814c2c867892903734522a/spur_set_num.py">Spur with form input</a>)</p>
<p><a href="/get_page/rungist?src=https://gist.githubusercontent.com/mdecourse/e896a4705a95ac8cc4147b355b0e87ef/raw/8954b8280c524c5781dc3c0b3565bc489d3aa3a3/three_spur_rotating.py">local three gears</a> (<a href="https://mde.tw/cp2021/content/rungist.html?src=https://gist.githubusercontent.com/mdecourse/e896a4705a95ac8cc4147b355b0e87ef/raw/8954b8280c524c5781dc3c0b3565bc489d3aa3a3/three_spur_rotating.py">remote three gears</a>)</p>
<p><a href="/get_page/rungist?src=https://gist.githubusercontent.com/mdecourse/379f02862e9dfd95dbc5241d4faa2ad4/raw/e3dc77e68bbfb8f00eef2e78d3c8d2323b0f17da/clock.py">local clock</a> <a href="https://mde.tw/cp2021/content/rungist.html?src=https://gist.githubusercontent.com/mdecourse/379f02862e9dfd95dbc5241d4faa2ad4/raw/e3dc77e68bbfb8f00eef2e78d3c8d2323b0f17da/clock.py">remote clock</a></p>
<p><a href="/get_page/run?src=https://gist.githubusercontent.com/mdecourse/e896a4705a95ac8cc4147b355b0e87ef/raw/76c510c47d88c9c218130a4ebb2cadf59803a3c7/prairiedraw_fourbar.py">local fourbar</a> <a href="https://mde.tw/cp2021/content/run.html?src=https://gist.githubusercontent.com/mdecourse/e896a4705a95ac8cc4147b355b0e87ef/raw/76c510c47d88c9c218130a4ebb2cadf59803a3c7/prairiedraw_fourbar.py">remote fourbar</a> (準備納入: <a href="https://github.com/mdecourse/Wiper-Mechanism">https://github.com/mdecourse/Wiper-Mechanism</a>)</p>
<p style="padding-left: 30px;"><a href="https://prairielearn.readthedocs.io/en/latest/PrairieDraw/">https://prairielearn.readthedocs.io/en/latest/PrairieDraw/</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/mdecourse/PrairieDraw.js">https://github.com/mdecourse/PrairieDraw.js</a></p>
<p><a href="/get_page/rungist/1">rungist</a> (for local edit)</p>
<!-- 導入 brython 程式庫 -->
<p></p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
<!-- 啟動 Brython -->
<script>
window.onload=function(){
    brython();
}
</script>
<!-- 頁面載入後執行 brythonListener() -->
<script>
$(document).ready( function() {
    brythonListener();
});
</script>
<!-- 建立讓 Javascript 執行的 brython 程式 -->
<script type="text/python">
from browser import document
from browser import window

def run():
    prog = open(document.query["src"]).read()
    ns = {'__name__':'__main__'}
    exec(prog, ns)

# 透過 window 將 Brython 的 run() 函式與 Javascript 的  brythonListner 函式對應
window.brythonListener = run()
</script>
<!-- Brython 程式執行的結果, 都以 brython_div 作為切入位置 -->
<div id="brython_div"></div>
<!-- 導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫 -->
<script src="https://mde.tw/cp2021/cmsimde/static/Cango-24v03-min.js"></script>
<script src="https://mde.tw/cp2021/cmsimde/static/gearUtils-09.js"></script>
<script src="https://mde.tw/cp2021/cmsimde/static/SVGpathUtils-6v03-min.js"></script>
<script src="https://mde.tw/cp2021/cmsimde/static/sylvester.js"></script>
<script src="https://mde.tw/cp2021/cmsimde/static/PrairieDraw.js"></script>
<h3>rungist src</h3>
<p>以下為上一頁 rungist 的原始碼:</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;h2&gt;rungist&lt;/h2&gt;
&lt;p&gt;rungist 在頁面中採 Javascript 呼叫 Brython 函式的方式, 讓使用者可以直接以 URL Get 執行 Gist 上的 Brython 程式. 建構的目的是讓學員可以利用 URL 繳交統一格式的 Brython 作業程式. 只要在 rungist 頁面加上 ?src=gist_url, 就可以將靜態繪圖或 animation 呈現在畫面中.&lt;/p&gt;
&lt;p&gt;以下連結左邊為 local 動態網頁編輯用, 而右邊的連結則為遠端 rungist 的 demo 範例.&lt;/p&gt;
&lt;p&gt;&lt;a href="/get_page/rungist?src=https://gist.githubusercontent.com/mdecourse/e896a4705a95ac8cc4147b355b0e87ef/raw/8954b8280c524c5781dc3c0b3565bc489d3aa3a3/cango_gear1.py"&gt;Cango gear&lt;/a&gt; (for local link only) (&lt;a href="https://mde.tw/cp2021/content/rungist.html?src=https://gist.githubusercontent.com/mdecourse/e896a4705a95ac8cc4147b355b0e87ef/raw/8954b8280c524c5781dc3c0b3565bc489d3aa3a3/cango_gear1.py"&gt;Cango gear&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;a href="/get_page/rungist?src=https://gist.githubusercontent.com/mdecourse/626206cf3b2a9a9a69f7ce4bb4a116f0/raw/970e2653a7207828b3814c2c867892903734522a/spur_set_num.py"&gt;Spur with form input&lt;/a&gt; (for local link only) (&lt;a href="https://mde.tw/cp2021/content/rungist.html?src=https://gist.githubusercontent.com/mdecourse/626206cf3b2a9a9a69f7ce4bb4a116f0/raw/970e2653a7207828b3814c2c867892903734522a/spur_set_num.py"&gt;Spur with form input&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;a href="/get_page/rungist?src=https://gist.githubusercontent.com/mdecourse/e896a4705a95ac8cc4147b355b0e87ef/raw/8954b8280c524c5781dc3c0b3565bc489d3aa3a3/three_spur_rotating.py"&gt;local three gears&lt;/a&gt; (&lt;a href="https://mde.tw/cp2021/content/rungist.html?src=https://gist.githubusercontent.com/mdecourse/e896a4705a95ac8cc4147b355b0e87ef/raw/8954b8280c524c5781dc3c0b3565bc489d3aa3a3/three_spur_rotating.py"&gt;remote three gears&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;a href="/get_page/rungist?src=https://gist.githubusercontent.com/mdecourse/379f02862e9dfd95dbc5241d4faa2ad4/raw/e3dc77e68bbfb8f00eef2e78d3c8d2323b0f17da/clock.py"&gt;local clock&lt;/a&gt; &lt;a href="https://mde.tw/cp2021/content/rungist.html?src=https://gist.githubusercontent.com/mdecourse/379f02862e9dfd95dbc5241d4faa2ad4/raw/e3dc77e68bbfb8f00eef2e78d3c8d2323b0f17da/clock.py"&gt;remote clock&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="/get_page/rungist/1"&gt;rungist&lt;/a&gt; (for local edit)&lt;/p&gt;
&lt;!-- 導入 brython 程式庫 --&gt;
&lt;p&gt;&lt;/p&gt;
&lt;script src="./../cmsimde/static/brython.js"&gt;&lt;/script&gt;
&lt;script src="./../cmsimde/static/brython_stdlib.js"&gt;&lt;/script&gt;
&lt;!-- 啟動 Brython --&gt;
&lt;script&gt;// &lt;![CDATA[
window.onload=function(){
    brython();
}
// ]]&gt;&lt;/script&gt;
&lt;!-- 頁面載入後執行 brythonListener() --&gt;
&lt;script&gt;// &lt;![CDATA[
$(document).ready( function() {
    brythonListener();
});
// ]]&gt;&lt;/script&gt;
&lt;!-- 建立讓 Javascript 執行的 brython 程式 --&gt;
&lt;script type="text/python"&gt;// &lt;![CDATA[
from browser import document
from browser import window

def run():
    prog = open(document.query["src"]).read()
    ns = {'__name__':'__main__'}
    exec(prog, ns)

# 透過 window 將 Brython 的 run() 函式與 Javascript 的  brythonListner 函式對應
window.brythonListener = run()
// ]]&gt;&lt;/script&gt;
&lt;!-- Brython 程式執行的結果, 都以 brython_div 作為切入位置 --&gt;
&lt;div id="brython_div"&gt;&lt;/div&gt;
&lt;!-- 導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫 --&gt;
&lt;script src="https://mde.tw/cp2021/cmsimde/static/Cango-24v03-min.js"&gt;&lt;/script&gt;
&lt;script src="https://mde.tw/cp2021/cmsimde/static/gearUtils-09.js"&gt;&lt;/script&gt;
&lt;script src="https://mde.tw/cp2021/cmsimde/static/SVGpathUtils-6v03-min.js"&gt;&lt;/script&gt;</pre>
<h2>run</h2>
<!-- 導入 brython 程式庫 -->
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
<!-- 啟動 Brython -->
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<p><!-- 印出版次與關鍵字程式 --></p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd(ev):
    bd = doc["brython_div"]
    bd.clear()
# Brython 3.3.4 內建的 container 名稱為  'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id
Ace = ace.Editor(editor_id="kw_editor", console_id="kw_console", container_id="kw__container", storage_id="kw_py_src" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src"]
    except:
        url = "https://gist.githubusercontent.com/mdecourse/e896a4705a95ac8cc4147b355b0e87ef/raw/8954b8280c524c5781dc3c0b3565bc489d3aa3a3/cango_gear1.py"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace.editor.setValue(prog)
    Ace.editor.scrollToRow(0)
    Ace.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run'].bind('click', Ace.run)
doc['kw_show_console'].bind('click', Ace.show_console)
doc['kw_clear_console'].bind('click', Ace.clear_console)
doc['clear_bd'].bind('click', clear_bd)
# 呼叫函式執行
run()
</script>
</p>
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<!-- 存擋表單開始 --><form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src', 'kw_filename');" type="submit" value="Save"/></form><!-- 存擋表單結束 -->
<p></p>
<!-- 執行與清除按鈕開始 -->
<p><button id="kw_run">Run</button> <button id="kw_show_console">Output</button> <button id="kw_clear_console">清除輸出區</button><button id="clear_bd">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<!-- 執行與清除按鈕結束 -->
<p></p>
<!-- 程式執行 ouput 區 -->
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console"></textarea></div>
<!-- Brython 程式執行的結果, 都以 brython_div 作為切入位置 -->
<div id="brython_div"></div>
<!-- 導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫 -->
<script src="https://mde.tw/cp2021/cmsimde/static/Cango-24v03-min.js"></script>
<script src="https://mde.tw/cp2021/cmsimde/static/gearUtils-09.js"></script>
<script src="https://mde.tw/cp2021/cmsimde/static/SVGpathUtils-6v03-min.js"></script>
<script src="https://mde.tw/cp2021/cmsimde/static/sylvester.js"></script>
<script src="https://mde.tw/cp2021/cmsimde/static/PrairieDraw.js"></script>
<h3>run src</h3>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;h2&gt;run&lt;/h2&gt;
&lt;!-- 導入 brython 程式庫 --&gt;
&lt;script src="/static/brython.js"&gt;&lt;/script&gt;
&lt;script src="/static/brython_stdlib.js"&gt;&lt;/script&gt;
&lt;!-- 啟動 Brython --&gt;
&lt;script&gt;// &lt;![CDATA[
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
// ]]&gt;&lt;/script&gt;
&lt;p&gt;&lt;!-- 導入 FileSaver 與 filereader --&gt;&lt;/p&gt;
&lt;p&gt;
&lt;script type="text/javascript" src="/static/ace/FileSaver.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/static/ace/filereader.js"&gt;&lt;/script&gt;
&lt;/p&gt;
&lt;p&gt;&lt;!-- 導入 ace --&gt;&lt;/p&gt;
&lt;p&gt;
&lt;script type="text/javascript" src="/static/ace/ace.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/static/ace/ext-language_tools.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/static/ace/mode-python3.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/static/ace/snippets/python.js"&gt;&lt;/script&gt;
&lt;/p&gt;
&lt;p&gt;&lt;!-- 請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--&gt;&lt;/p&gt;
&lt;p&gt;
&lt;script type="text/javascript"&gt;// &lt;![CDATA[
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
// ]]&gt;&lt;/script&gt;
&lt;/p&gt;
&lt;p&gt;&lt;!-- 印出版次與關鍵字程式 --&gt;&lt;/p&gt;
&lt;p&gt;
&lt;script type="text/python3"&gt;// &lt;![CDATA[
from browser import document as doc
import ace
# 清除畫布
def clear_bd(ev):
    bd = doc["brython_div"]
    bd.clear()
# Brython 3.3.4 內建的 container 名稱為  'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id
Ace = ace.Editor(editor_id="kw_editor", console_id="kw_console", container_id="kw__container", storage_id="kw_py_src" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src"]
    except:
        url = "https://gist.githubusercontent.com/mdecourse/e896a4705a95ac8cc4147b355b0e87ef/raw/8954b8280c524c5781dc3c0b3565bc489d3aa3a3/cango_gear1.py"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace.editor.setValue(prog)
    Ace.editor.scrollToRow(0)
    Ace.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run'].bind('click', Ace.run)
doc['kw_show_console'].bind('click', Ace.show_console)
doc['kw_clear_console'].bind('click', Ace.clear_console)
doc['clear_bd'].bind('click', clear_bd)
# 呼叫函式執行
run()
// ]]&gt;&lt;/script&gt;
&lt;/p&gt;
&lt;p&gt;&lt;!-- 用來顯示程式碼的 editor 區域 --&gt;&lt;/p&gt;
&lt;div id="kw_editor" style="width: 600px; height: 300px;"&gt;&lt;/div&gt;
&lt;p&gt;&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;&lt;/p&gt;
&lt;!-- 存擋表單開始 --&gt;&lt;form&gt;&lt;label&gt;Filename: &lt;input id="kw_filename" placeholder="input file name" type="text"&gt;.py&lt;/label&gt; &lt;input onclick="doSave('kw_py_src', 'kw_filename');" type="submit" value="Save"&gt;&lt;/form&gt;&lt;!-- 存擋表單結束 --&gt;
&lt;p&gt;&lt;/p&gt;
&lt;!-- 執行與清除按鈕開始 --&gt;
&lt;p&gt;&lt;button id="kw_run"&gt;Run&lt;/button&gt; &lt;button id="kw_show_console"&gt;Output&lt;/button&gt; &lt;button id="kw_clear_console"&gt;清除輸出區&lt;/button&gt;&lt;button id="clear_bd"&gt;清除繪圖區&lt;/button&gt;&lt;button onclick="window.location.reload()"&gt;Reload&lt;/button&gt;&lt;/p&gt;
&lt;!-- 執行與清除按鈕結束 --&gt;
&lt;p&gt;&lt;/p&gt;
&lt;!-- 程式執行 ouput 區 --&gt;
&lt;div style="width: 100%; height: 100%;"&gt;&lt;textarea autocomplete="off" id="kw_console"&gt;&lt;/textarea&gt;&lt;/div&gt;
&lt;!-- Brython 程式執行的結果, 都以 brython_div 作為切入位置 --&gt;
&lt;div id="brython_div"&gt;&lt;/div&gt;
&lt;!-- 導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫 --&gt;
&lt;script src="https://mde.tw/cp2021/cmsimde/static/Cango-24v03-min.js"&gt;&lt;/script&gt;
&lt;script src="https://mde.tw/cp2021/cmsimde/static/gearUtils-09.js"&gt;&lt;/script&gt;
&lt;script src="https://mde.tw/cp2021/cmsimde/static/SVGpathUtils-6v03-min.js"&gt;&lt;/script&gt;
&lt;script src="https://mde.tw/cp2021/cmsimde/static/sylvester.js"&gt;&lt;/script&gt;
&lt;script src="https://mde.tw/cp2021/cmsimde/static/PrairieDraw.js"&gt;&lt;/script&gt;</pre>
<h1>線上課程</h1>
<p><span style="background-color: #ffff99;"><a href="https://drive.google.com/file/d/1bXjhpwj75Gq_x4XSNAwWxZgdD6QvS-Dp/view?usp=sharing" style="background-color: #ffff99;">1a w1_1 線上課程</a></span> (課程簡介) - 請注意: 說明影片中代理主機的連線密碼已經更改, 將在課堂上口頭告知.</p>
<p style="padding-left: 30px;">09:19 才提到 gitter 的免費服務可能會有所變化, 沒想到 2021.09.27 中午 gitter 就出現大當機. 因此接下來將利用 <a href="https://kmolab.zulipchat.com">https://kmolab.zulipchat.com</a> (第一優先) 或 <a href="https://github.com/mdecourse/cp2021/discussions/7">https://github.com/mdecourse/cp2021/discussions/7</a> (第二優先) 發布訊息.</p>
<p><span style="background-color: #ffff99;"><a href="https://drive.google.com/file/d/1M1oRg_Tw4IV-fLsiV_8eRUQz957imuZg/view?usp=sharing" style="background-color: #ffff99;">1b w1_1 線上補充課程</a></span></p>
<p><span style="background-color: #ffff99;"><a href="https://drive.google.com/file/d/1HF14TWQcOF9ES62gZxGvOyuZWLYv3GdK/view?usp=sharing" style="background-color: #ffff99;">1a w1_2 線上課程</a></span> (Brython 與 Canvas 簡介)</p>
<p><span style="background-color: #ffff99;"><a href="https://drive.google.com/file/d/1hDU9otLQhIGCq8nAFkMu_9IDx-ofbqeb/view?usp=sharing" style="background-color: #ffff99;">1b_w1_2 線上補充課程</a></span></p>
<p><span style="background-color: #ffff99;"><a href="https://drive.google.com/file/d/15MA1p9BQ3f436KPbjbp4iry5rsvRci3S/view?usp=sharing" style="background-color: #ffff99;">1a_w1_3 線上課程</a> </span>(課程網頁瀏覽簡介)</p>
<hr/>
<p><span style="background-color: #ffff99;"><a href="https://drive.google.com/file/d/1ero2VdtAwcLnV8l6Bd60p9uFBOmLWoWa/view?usp=sharing" style="background-color: #ffff99;">1a_w2_1 線上課程</a></span> (說明如何建立可攜程式系統)</p>
<p><span style="background-color: #ffff99;"><a href="https://drive.google.com/file/d/1GrH8qTrtPv0NK2dbnvhJY9CJ08-nh24J/view?usp=sharing" style="background-color: #ffff99;">1a_w2_2 線上課程</a></span> (說明如何建立 cp2021_hw 倉儲與網站)</p>
<p><span style="background-color: #ffff99;"><a href="https://drive.google.com/file/d/1Q_uD9o8-7AUjPs348XACtUxhB-qBVmq0/view?usp=sharing" style="background-color: #ffff99;">1a_w2_3 線上課程</a></span> (說明如何維護個人的 cp2021_hw 網站)</p>