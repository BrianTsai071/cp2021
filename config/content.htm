<h1>About</h1>
<p>這裡是國立虎尾科技大學-機械設計工程系-計算機程式課程網站.</p>
<p>Repository: <a href="https://github.com/mdecourse/cp2021">https://github.com/mdecourse/cp2021</a></p>
<p>Github Pages: <a href="https://mde.tw/cp2021">https://mde.tw/cp2021</a></p>
<p>Github 簡介: <a href="https://docs.microsoft.com/zh-tw/learn/modules/introduction-to-github/">https://docs.microsoft.com/zh-tw/learn/modules/introduction-to-github/</a></p>
<p>Github Actions: <a href="https://docs.microsoft.com/zh-tw/learn/modules/github-actions-automate-tasks/">https://docs.microsoft.com/zh-tw/learn/modules/github-actions-automate-tasks/</a></p>
<p>LaTeX 教學: <a href="https://wdv4758h.github.io/notes/documentation/latex.html">https://wdv4758h.github.io/notes/documentation/latex.html</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/marketplace/actions/latex-action">https://github.com/marketplace/actions/latex-action</a></p>
<p>Zulipchat: <a href="https://kmolab.zulipchat.com">https://kmolab.zulipchat.com</a></p>
<p>RoboDK: <a href="https://robodk.com">https://robodk.com</a></p>
<p>RoboDK API: <a href="https://robodk.com/doc/en/PythonAPI/">https://robodk.com/doc/en/PythonAPI/</a> (<a href="https://github.com/RoboDK/RoboDK-API">RoboDK-API on Github</a>)</p>
<h4>電腦輔助設計室與協同設計室行事曆</h4>
<p><a href="https://calendar.google.com/calendar/embed?src=mde.nfu.edu.tw_3439313938333136353439%40resource.calendar.google.com&amp;ctz=Asia%2FTaipei&amp;mode=week&amp;src=mde.nfu.edu.tw_35303530373431313438%40resource.calendar.google.com&amp;ctz=Asia%2FTaipei&amp;src=yen%40gm.nfu.edu.tw&amp;ctz=Asia%2FTaipei">全頁檢視</a></p>
<p><iframe height="600" src="https://calendar.google.com/calendar/embed?src=mde.nfu.edu.tw_3439313938333136353439%40resource.calendar.google.com&amp;ctz=Asia%2FTaipei&amp;mode=week&amp;src=mde.nfu.edu.tw_35303530373431313438%40resource.calendar.google.com&amp;ctz=Asia%2FTaipei&amp;src=yen%40gm.nfu.edu.tw&amp;ctz=Asia%2FTaipei" width="800"></iframe></p><h3>Python</h3>
<p><span style="background-color: #ccffcc;">Web Browser &lt;-&gt; Client </span>&lt;-&gt; Brython &lt;-&gt; Flask &lt;-&gt; <span style="background-color: #ccffcc;">Server &lt;-&gt; RoboDK, CoppeliaSim and Webots</span></p>
<h4>Examples:</h4>
<p style="padding-left: 30px;"><a href="https://medium.com/@patrickbfuller/a-simple-flask-app-edeed75dbee2">https://medium.com/@patrickbfuller/a-simple-flask-app-edeed75dbee2</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/Patrickbfuller/simple_flask">https://github.com/Patrickbfuller/simple_flask</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/mileserickson/flask-brython-example">https://github.com/mileserickson/flask-brython-example</a></p>
<p style="padding-left: 30px;"><a href="https://pypi.org/project/brython-server/">https://pypi.org/project/brython-server/</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/andy31lewis/brySVG">https://github.com/andy31lewis/brySVG</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/dunossauro/todo_list_flask_brython">https://github.com/dunossauro/todo_list_flask_brython</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/DarthBayo/Encrypt">https://github.com/DarthBayo/Encrypt</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/chfw/brython-pack">https://github.com/chfw/brython-pack</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/rayluo/brip">https://github.com/rayluo/brip</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/rayluo/brython-project-template">https://github.com/rayluo/brython-project-template</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/rayluo/draggable-svg">https://github.com/rayluo/draggable-svg</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/Shohrab-Hossain/Tic-Tac-Toe-web">https://github.com/Shohrab-Hossain/Tic-Tac-Toe-web</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/denisecase/chapstack">https://github.com/denisecase/chapstack</a></p>
<p style="padding-left: 30px;"><a href="https://gitlab.com/sammdu/bot-tac-toe/">https://gitlab.com/sammdu/bot-tac-toe/</a> </p>
<h4>Python 語法</h4>
<p>由於 Github Pages 不允許伺服 __init__.py 檔案, 因此下列範例中需要導入 ggame 的部分, 將無法在 Github Pages 網站中執行.</p>
<p>Python 3 官方教材: <a href="https://docs.python.org/3/index.html">https://docs.python.org/3/index.html</a></p>
<p>Python tutorial: <a href="https://docs.python.org/3/tutorial/index.html">https://docs.python.org/3/tutorial/index.html</a> (英文)</p>
<p>Python tutorial: <a href="https://docs.python.org/zh-tw/3/tutorial/">https://docs.python.org/zh-tw/3/tutorial/</a> (中文)</p>
<p>網頁上的 Python - Brython: <a href="https://www.brython.info/static_doc/en/intro.html">https://www.brython.info/static_doc/en/intro.html</a> (解譯式)</p>
<p>網頁上的 Python GUI- Flexx: <a href="https://flexx.readthedocs.io/en/stable/">https://flexx.readthedocs.io/en/stable/</a> (轉譯式)</p>
<p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
<!-- for ggame -->
<script src="/static/jquery-3.3.1.min.js"></script>
<script src="/static/jquery-ui.1.12.1.min.js"></script>
<script src="/static/pixi-3.0.5.min.js"></script>
<script src="/static/buzz-1.2.1.js"></script>
<script src="/static/bs.js"></script>
<!-- Cango 程式庫 -->
<script src="/static/Cango-13v08-min.js"></script>
<script src="/static/CangoAxes-4v01-min.js"></script>
<script src="/static/gearUtils-05.js"></script>
<!-- for Konva 程式庫 -->
<script src="/static/konva.min.js"></script>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/']});
}
</script>
</p>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<h4>開始練習 print() 用法, 並著手建立函式</h4>
<p><!-- 印出版次與關鍵字程式 --></p>
<p>
<script type="text/python3">
from browser import document as doc
from browser import html
import ace
# 清除畫布
def clear_bd(ev):
    bd = doc["brython_div"]
    bd.clear()
# Brython 3.3.4 內建的 container 名稱為  'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id
Ace = ace.Editor(editor_id="kw_editor", console_id="kw_console", container_id="kw__container", storage_id="kw_py_src" )
Ace.editor.setValue("""# 導入 sys 模組
import sys
# 導入 keyword 模組
import keyword
def helloWorld():
    print("Hello World!")
helloWorld()
# 利用 sys 模組中的 version_info 印出 Python 版次
print("Python version: ", sys.version_info)
# 利用 keyword 模組中的 kwlist 印出關鍵字
print("Python keywords: ", keyword.kwlist)
""")
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)
# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run'].bind('click', Ace.run)
doc['kw_show_console'].bind('click', Ace.show_console)
doc['kw_clear_console'].bind('click', Ace.clear_console)
doc['clear_bd'].bind('click', clear_bd)
</script>
</p>
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src', 'kw_filename');" type="submit" value="Save"/></form>
<p><button id="kw_run">Run</button> <button id="kw_show_console">Output</button> <button id="kw_clear_console">清除輸出區</button><button id="clear_bd">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console"></textarea></div>
<div id="brython_div"></div>
<div class="col-md-0" height="1" id="graphics-column" width="1"></div>
<p><!-- ****************************** keyword start -->
<script type="text/python3">
from browser import document as doc
# 導入位於 static 目錄下的 beditor.py 
import beditor
# 利用 beditor.py 中的 editor 類別建立案例, 對應到 kw1
kw1 = beditor.editor("""# 導入 sys 模組
import sys
# 導入 keyword 模組
import keyword
# 利用 sys 模組中的 version_info 印出 Python 版次
print("Python version: ", sys.version_info)
# 利用 keyword 模組中的 kwlist 印出關鍵字
print("Python keywords: ", keyword.kwlist)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "keyword" 的按鈕點按時, 執行 kw1 物件中的 prog 方法
doc["keyword"].bind('click', kw1.prog)
</script>
</p>
<p><!-- ****************************** keyword end --></p>
<p><!-- ***************************** slide ex1 start --></p>
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Ex1 = beditor.editor("""# 導入 Ex1 原始碼
a = 0
def my_print(n, input_str):
    print("以下將重覆列印 '", input_str + "' " + str(n) + "次")
    for i in range(n):
        print(i, input_str)
my_print(5, "Hello World!")
the_str = "開始學習 Python"
num = input("請輸入要列印的次數!")
my_print(int(num), the_str)
a = a + 1
print("(" + str(a) + ")", "_" * 25)
def myfun():
    yield 1
    yield 2
    yield 3
for i in myfun():
    print(i)
x = iter(myfun())
y = list(myfun())
a = a + 1
print("(" + str(a) + ")", "_" * 25)
print(x.__next__())
print(x.__next__())
print(x.__next__())
print(y)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "ex1" 的按鈕點按時, 執行 Ex1 物件中的 prog 方法
doc["ex1"].bind('click', Ex1.prog)
</script>
</p>
<p><!-- ***************************** slide ex1 end --></p>
<p><!-- ***************************** slide ex2 start --></p>
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Ex2 = beditor.editor("""# Python 的內建資料型別
import math
def f():
    print("This is a user-defined function")
    return 42
print("Some basic types in Python:")
print(type(2))           # int
print(type(2.2))         # float
print(type("2.2"))       # str  (string)
print(type(2 < 2.2))     # bool (boolean)
print(type(math))        # module
print(type(math.tan))    # builtin_function_or_method ("function" in Brython)
print(type(f))           # function (user-defined function)
print(type(type(42)))    # type
print("#####################################################")
print("And some other types we will see later in the course...")
print(type(Exception())) # Exception
print(type(range(5)))    # range
print(type([1,2,3]))     # list
print(type((1,2,3)))     # tuple
print(type({1,2}))       # set
print(type({1:42}))      # dict (dictionary or map)
print(type(2+3j))        # complex  (complex number) (we may not see this type)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "ex2" 的按鈕點按時, 執行 Ex2 物件中的 prog 方法
doc["ex2"].bind('click', Ex2.prog)
</script>
</p>
<p><!-- ***************************** slide ex2 end --></p>
<p><!-- ***************************** slide ex3 start --></p>
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Ex3 = beditor.editor("""# Python 的內建常數與函式
# 內建常數
print("Some builtin constants:")
print(True)
print(False)
print(None)
print("And some more constants in the math module:")
import math
print(math.pi)
print(math.e)
# 內建函式
print("Type conversion functions:")
print(bool(0))   # convert to boolean (True or False)
print(float(42)) # convert to a floating point number
print(int(2.8))  # convert to an integer (int)
print("And some basic math functions:")
print(abs(-5))   # absolute value
print(max(2,3))  # return the max value
print(min(2,3))  # return the min value
print(pow(2,3))  # raise to the given power (pow(x,y) == x**y)
print(round(2.354, 1)) # round with the given number of digits
# other examples
print(3 * 2)
print(3 * "abc")
print(3 + 2)
print("abc" + "def")
print(3 + "def")
# Type Affect Semantics
print(3 * 2)
print(3 * "abc")
print(3 + 2)
print("abc" + "def")
print(3 + "def")
# Integer Division
print("The / operator does 'normal' float division:")
print(" 5/3  =", ( 5/3))
print()
print("The // operator does integer division:")
print(" 5//3 =", ( 5//3))
print(" 2//3 =", ( 2//3))
print("-1//3 =", (-1//3))
print("-4//3 =", (-4//3))
# Modulus or Remainder Operator (%)
print(" 6%3 =", ( 6%3))
print(" 5%3 =", ( 5%3))
print(" 2%3 =", ( 2%3))
print(" 0%3 =", ( 0%3))
print("-4%3 =", (-4%3))
print(" 3%0 =", ( 3%0))
# Verify that (a%b) is equivalent to (a-(a//b)*b)
def mod(a, b):
  return a - (a//b)*b
print(41%14, mod(41,14))
print(14%41, mod(14,41))
print(-32%9, mod(-32,9))
print(32%-9, mod(32,-9))
# Operator Order (Precedence and Associativity)
print("Precedence:")
print(2+3*4)  # prints 14, not 20
print(5+4%3)  # prints  6, not 0 (% has same precedence as *, /, and //)
print(2**3*4) # prints 32, not 4096 (** has higher precedence than *, /, //, and %)
print()
print("Associativity:")
print(5-4-3)   # prints -2, not 4 (- associates left-to-right)
print(4**3**2) # prints 262144, not 4096 (** associates right-to-left)
# Approximate Values of Floating-Point Numbers
print(0.1 + 0.1 == 0.2)        # True, but...
print(0.1 + 0.1 + 0.1 == 0.3)  # False!
print(0.1 + 0.1 + 0.1)         # prints 0.30000000000000004 (uh oh)
print((0.1 + 0.1 + 0.1) - 0.3) # prints 5.55111512313e-17 (tiny, but non-zero!)
# Equality Testing with math.isclose
print("The problem....")
d1 = 0.1 + 0.1 + 0.1
d2 = 0.3
print(d1 == d2)                # False (never use == with floats!)
print()
print("The solution...")
import math
print(math.isclose(d1, d2))  # True!
# math.isclose checks if the two numbers are ALMOST equal, within a small error
# Short-Circuit Evaluation
def yes():
    return True
def no():
    return False
def crash():
    return 1/0 # crashes!
print(no() and crash()) # Works!
print(crash() and no()) # Crashes!
print (yes() and crash()) # Never runs (due to crash), but would also crash (without short-circuiting)
# Or operator
def yes():
    return True
def no():
    return False
def crash():
    return 1/0 # crashes!
print(yes() or crash()) # Works!
print(crash() or yes()) # Crashes!
print(no() or crash())  # Never runs (due to crash), but would also crash (without short-circuiting)
# more examples
def isPositive(n):
    result = (n > 0)
    print("isPositive(",n,") =", result)
    return result
def isEven(n):
    result = (n % 2 == 0)
    print("isEven(",n,") =", result)
    return result
print("Test 1: isEven(-4) and isPositive(-4))")
print(isEven(-4) and isPositive(-4)) # Calls both functions
print("----------")
print("Test 2: isEven(-3) and isPositive(-3)")
print(isEven(-3) and isPositive(-3)) # Calls only one function!
# type vs isinstance
# Both type and isinstance can be used to type-check
# In general, (isinstance(x, T)) will be more robust than (type(x) == T)
print(type("abc") == str)
print(isinstance("abc", str))
# We'll see better reasons for this when we cover OOP + inheritance later
# in the course.  For now, here is one reason:  say you wanted to check
# if a value is any kind of number (int, float, complex, etc). 
# You could do:
def isNumber(x):
    return ((type(x) == int) or
            (type(x) == float)) # are we sure this is ALL kinds of numbers?
print(isNumber(1), isNumber(1.1), isNumber(1+2j), isNumber("wow"))
# But this is cleaner, and works for all kinds of numbers, including
# complex numbers for example:
import numbers
def isNumber(x):
    return isinstance(x, numbers.Number) # works for any kind of number
print(isNumber(1), isNumber(1.1), isNumber(1+2j), isNumber("wow"))
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "ex3" 的按鈕點按時, 執行 Ex3 物件中的 prog 方法
doc["ex3"].bind('click', Ex3.prog)
</script>
</p>
<p><!-- ***************************** slide ex3 end --></p>
<p><!-- ***************************** slide ex4 start --></p>
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Ex4 = beditor.editor("""# Python 函式
# Vocabulary
x = 5
def f(y, z):
    result = x + y + z
    return result
print(f(1, 2)) # 8
print(f(3, 4)) # 12
# Vocabulary:
#   variables: global vs. local
#   statements vs. expressions
#   function definitions vs. function calls
#   parameters vs. arguments
# Return Statements
# Basic example
def isPositive(x):
    return (x > 0)
print(isPositive(5))  # True
print(isPositive(-5)) # False
print(isPositive(0))  # False
# Return ends the function immediately
def isPositive(x):
    print("Hello!")   # runs
    return (x > 0)
    print("Goodbye!") # does not run ("dead code")
print(isPositive(5))  # prints Hello, then True
# No return statement --> return None
def f(x):
    x + 42
print(f(5)) # None
def f2(x):
    result = x + 42
print(f2(5)) # None
# Print versus Return
# This is a common early mistake (confusing print and return):
def cubed(x):
    print(x**3) # Here is the error!
cubed(2)          # seems to work!
print(cubed(3))   # sort of works (but prints None, which is weird)
print(2*cubed(4)) # Error!
# Once again (correctly)
def cubed2(x):
    return (x**3) # That's better!
cubed2(2)          # seems to be ignored (why?)
print(cubed2(3))   # works!
print(2*cubed2(4)) # works!
# Different Parameter and Return Types
def hypotenuse(a, b):
    return ((a**2) + (b**2))**0.5
print(hypotenuse(3, 4)) # 5.0 (not 5)
print("---------------------")
def xor(b1, b2):
    return ((b1 and (not b2)) or (b2 and (not b1)))  # same as (b1 != b2)
print(xor(True,  True))  # False
print(xor(True,  False)) # True
print(xor(False, True))  # True
print(xor(False, False)) # False
print("---------------------")
def isPositive(n):
    return (n > 0)
print(isPositive(10))     # True
print(isPositive(-1.234)) # False
# Function Composition
def f(w):
    return 10*w
def g(x, y):
    return f(3*x) + y
def h(z):
    return f(g(z, f(z+1)))
print(h(1)) # hint: try the "visualize" feature
# Helper Functions 
def onesDigit(n):
    return n%10
def largerOnesDigit(x, y):
    return max(onesDigit(x), onesDigit(y))
print(largerOnesDigit(134, 672)) # 4
print(largerOnesDigit(132, 674)) # Still 4
# Test Functions
# A broken test function
def onesDigit(n):
    return n%10
def testOnesDigit():
    print("Testing onesDigit()...", end="")
    assert(onesDigit(5) == 5)
    assert(onesDigit(123) == 3)
    assert(onesDigit(100) == 0)
    assert(onesDigit(999) == 9)
    print("Passed!")
testOnesDigit() # Passed!  Why is this bad?
# A better version
def onesDigit2(n):
    return n%10
def testOnesDigit2():
    print("Testing onesDigit()...", end="")
    assert(onesDigit2(5) == 5)
    assert(onesDigit2(123) == 3)
    assert(onesDigit2(100) == 0)
    assert(onesDigit2(999) == 9)
    assert(onesDigit2(-123) == 3) # Added this test
    print("Passed!")
testOnesDigit2() # Crashed!  So the test function worked!
# Local Variable Scope
def f(x):
    print("In f, x =", x)
    x += 5
    return x
def g(x):
    return f(x*2) + f(x*3)
print(g(2))
# Another example
def f(x):
    print("In f, x =", x)
    x += 7
    return round(x / 3)
def g(x):
    x *= 10
    return 2 * f(x)
def h(x):
    x += 3
    return f(x+4) + g(x)
print(h(f(1)))
# Global Variable Scope
# In general, you should avoid using global variables.
# You will even lose style points if you use them!
# Still, you need to understand how they work, since others
# will use them, and there may also be some very few occasions
# where you should use them, too!
g = 100
def f(x):
    return x + g
print(f(5)) # 105
print(f(6)) # 106
print(g)    # 100
# Another exampl
g = 100
def f(x):
    # If we modify a global variable, we must declare it as global.
    # Otherwise, Python will assume it is a local variable.
    global g
    g += 1
    return x + g
print(f(5)) # 106
print(f(6)) # 108
print(g)    # 102
# Default arguments
# Sometimes, a function has a parameter that has a natural default
# We can specify that default value in the function definition,
# then choose whether or not to include it in the function call.
def f(x, y=10):
    return x + y
print(f(5))   # 15
print(f(5,1)) # 6
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "ex4" 的按鈕點按時, 執行 Ex4 物件中的 prog 方法
doc["ex4"].bind('click', Ex4.prog)
</script>
</p>
<p><!-- ***************************** slide ex4 end --></p>
<!-- line drawing start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Draw = beditor.editor("""# Line drawing
# 導入 doc
from browser import document as doc
from browser import html
import math
canvas = html.CANVAS(width = 300, height = 200)
canvas.id = "line_drawing"
brython_div = doc["brython_div"]
brython_div <= canvas
# 準備繪圖畫布
canvas = doc["line_drawing"]
ctx = canvas.getContext("2d")
# 進行座標轉換, x 軸不變, y 軸反向且移動 canvas.height 單位光點
# ctx.setTransform(1, 0, 0, -1, 0, canvas.height)
# 以下採用 canvas 原始座標繪圖
# 設定填圖顏色
ctx.fillStyle = "rgb(200,0,0)"
# 設定畫筆顏色
ctx.strokeStyle = "rgb(0,0,200)"
# 乘上 deg 可轉為徑度單位
deg = math.pi / 180
# 建立多邊形定點位置畫線函式
def star(radius, xc, yc, n):
    #radius = 100
    #xc = 200
    #yc = 200
    xi = xc + radius*math.cos((360/n)*deg+90*deg)
    yi = yc - radius*math.sin((360/n)*deg+90*deg)
    ctx.beginPath()
    ctx.moveTo(xi,yi)
    for i in range(2, n+1):
        x = xc + radius*math.cos((360/n)*deg*i+90*deg)
        y = yc - radius*math.sin((360/n)*deg*i+90*deg)
        ctx.lineTo(x,y)
# 以下利用多邊形畫線函式呼叫執行畫框線或填入顏色
# 畫五邊形框線
star(50, 50, 50, 5)
ctx.closePath()
ctx.stroke()
    
# 填三角形色塊
star(50, 150, 50, 3)
ctx.closePath()
ctx.fill()
    
# 改變畫線顏色後, 畫七邊形框線
ctx.strokeStyle = "rgb(0,200,20)"
star(50, 250, 50, 7)
ctx.closePath()
ctx.stroke()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "draw" 的按鈕點按時, 執行 Draw 物件中的 prog 方法
doc["draw"].bind('click', Draw.prog)
</script>
</p>
<!-- line drawing ends -->
<p></p>
<!-- flag ex start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Flag = beditor.editor("""# 畫中華民國國旗
# 導入 doc
from browser import document as doc
from browser import html
import math
canvas = html.CANVAS(width = 300, height = 200)
canvas.style = {"width": "100%"}
canvas.id = "taiwan_flag"
brython_div = doc["brython_div"]
brython_div <= canvas
# 準備繪圖畫布
canvas = doc["taiwan_flag"]
ctx = canvas.getContext("2d")
# 進行座標轉換, x 軸不變, y 軸反向且移動 canvas.height 單位光點
# ctx.setTransform(1, 0, 0, -1, 0, canvas.height)
# 以下採用 canvas 原始座標繪圖
flag_w = canvas.width
flag_h = canvas.height
circle_x = flag_w/4
circle_y = flag_h/4
# 先畫滿地紅
ctx.fillStyle='rgb(255, 0, 0)'
ctx.fillRect(0,0,flag_w,flag_h)
# 再畫青天
ctx.fillStyle='rgb(0, 0, 150)'
ctx.fillRect(0,0,flag_w/2,flag_h/2)
# 畫十二道光芒白日
ctx.beginPath()
star_radius = flag_w/8
angle = 0
for i in range(24):
    angle += 5*math.pi*2/12
    toX = circle_x + math.cos(angle)*star_radius
    toY = circle_y + math.sin(angle)*star_radius
    # 只有 i 為 0 時移動到 toX, toY, 其餘都進行 lineTo
    if (i):
        ctx.lineTo(toX, toY)
    else:
        ctx.moveTo(toX, toY)
ctx.closePath()
# 將填色設為白色
ctx.fillStyle = '#fff'
ctx.fill()
# 白日:藍圈
ctx.beginPath()
ctx.arc(circle_x, circle_y, flag_w*17/240, 0, math.pi*2, True)
ctx.closePath()
# 填色設為藍色
ctx.fillStyle = 'rgb(0, 0, 149)'
ctx.fill()
# 白日:白心
ctx.beginPath()
ctx.arc(circle_x, circle_y, flag_w/16, 0, math.pi*2, True)
ctx.closePath()
# 填色設為白色
ctx.fillStyle = '#fff'
ctx.fill()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "flag" 的按鈕點按時, 執行 Flag 物件中的 prog 方法
doc["flag"].bind('click', Flag.prog)
</script>
</p>
<!-- flag ex ends -->
<p></p>
<!-- bunny start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Bunny = beditor.editor("""# Ggame
from ggame import App, ImageAsset, Sprite, MouseEvent
from random import random, randint
from browser import document as doc
from browser import html
import math
# 引入既有的id="graphics-column" 標註
graphics_column = doc["graphics-column"]
# 建立內定名稱為 "ggame-canvas" 的 canvas 標註
canvas = html.CANVAS(width = 600, height = 400)
canvas.id = "ggame-canvas"
# 將 canvas 插入 gc 標註中
graphics_column <= canvas
class Bunny(Sprite):
    
    asset = ImageAsset("/images/bunny.png")
    
    def __init__(self, position):
        super().__init__(Bunny.asset, position)
        # register mouse events
        App.listenMouseEvent(MouseEvent.mousedown, self.mousedown)
        App.listenMouseEvent(MouseEvent.mouseup, self.mouseup)
        App.listenMouseEvent(MouseEvent.mousemove, self.mousemove)
        self.dragging = True
        self.deltax = 0
        self.deltay = 0
    
    def step(self):
        # Every now and then a bunny hops...
        if random() < 0.01:
            self.x += randint(-20,20)
            self.y += randint(-20,20)
        
        
    def mousedown(self, event):
        # capture any mouse down within 50 pixels
        self.deltax = event.x - (self.x + self.width//2) 
        self.deltay = event.y - (self.y + self.height//2)
        if abs(self.deltax) < 50 and abs(self.deltay) < 50:
            self.dragging = True
            # only drag one bunny at a time - consume the event
            event.consumed = True
            
    def mousemove(self, event):
        if self.dragging:
            self.x = event.x - self.deltax - self.width//2
            self.y = event.y - self.deltay - self.height//2
            event.consumed = True
            
    def mouseup(self, event):
        if self.dragging:
            self.dragging = False
            event.consumed = True
            
        
class DemoApp(App):
    
    def __init__(self):
        super().__init__()
        for i in range(5):
            Bunny((randint(50, 600), randint(50, 400)))
        
    def step(self):
        # Override step to perform action on each frame update
        for bunny in self.spritelist:
            bunny.step()
# Create the app
app = DemoApp()  
# Run the app
app.run()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "bunny" 的按鈕點按時, 執行 Bunny 物件中的 prog 方法
doc["bunny"].bind('click', Bunny.prog)
</script>
</p>
<!-- bunny ends -->
<p></p>
<!-- clear canvas start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Clear = beditor.editor("""# 清除畫布
from browser import document, html
brython_div = document["brython_div"] 
brython_div.clear()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "clear" 的按鈕點按時, 執行 Clear 物件中的 prog 方法
doc["clear"].bind('click', Clear.prog)
</script>
</p>
<!-- clear canvas ends -->
<p></p>
<!-- cango spur gears start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Spur = beditor.editor("""# Cango Spur Gears
from browser import document as doc
from browser import html
import math
canvas = html.CANVAS(width = 600, height = 400)
canvas.id = "cango_gear"
brython_div = doc["brython_div"]
brython_div <= canvas
from browser import document as doc
from browser import window
import math
canvas = doc["cango_gear"]
# 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx
#ctx = canvas.getContext("2d")
cango = window.Cango.new
# 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換
shapedefs = window.shapeDefs
shape = window.Shape.new
path = window.Path.new
creategeartooth = window.createGearTooth.new
tweener = window.Tweener.new
# 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id="cango_gear" 的 canvas 上
cgo = cango("cango_gear")
######################################
# 畫正齒輪輪廓
#####################################
def cangoGear(n, m, pa):
    # n 為齒數
    #n = 17
    # pa 為壓力角
    #pa = 25
    # m 為模數, 根據畫布的寬度, 計算適合的模數大小
    # Module = mm of pitch diameter per tooth
    #m = 0.8*canvas.width/n
    # pr 為節圓半徑
    pr = n*m/2 # gear Pitch radius
    # generate gear
    data = creategeartooth(m, n, pa)
    # Brython 程式中的 print 會將資料印在 Browser 的 console 區
    #print(data)
    gearTooth = path(data, {
      "fillColor":"#ddd0dd",
      "border": True,
      "strokeColor": "#606060" })
    gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh
    # 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中
    gear = gearTooth.dup()
    # gear 為單一齒的輪廓資料
    #cgo.render(gearTooth)
    # 利用單齒輪廓旋轉, 產生整個正齒輪外形
    for i in range(1, n):
        # 將 gearTooth 中的資料複製到 newTooth
        newTooth = gearTooth.dup()
        # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear
        newTooth.rotate(360*i/n)
        gear.appendPath(newTooth)
    # 建立軸孔
    # add axle hole, hr 為 hole radius
    hr = 0.6*pr # diameter of gear shaft
    shaft = path(shapedefs.circle(hr), {
      "fillColor":"#ddd0dd",
      "border": True,
      "strokeColor": "#606060" })
    gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path
    return gear
# 設定兩齒齒數
n1 = 17
n2 = 11
n3 = 13
reduced_ratio = 0.5
# 使用 80% 的畫布寬度
m = 0.8*canvas.width/((n1+n2+n3)*reduced_ratio)
# 設定共同的壓力角
pa = 25
# n 齒輪的節圓半徑
pr1 = n1*m/2
# n2 齒輪的節圓半徑
pr2 = n2*m/2
pr3 = n3*m/2
cx = canvas.width/2
cy = canvas.height/2
# 建立 gears
gear1 = cangoGear(n1, m, pa)
gear2 = cangoGear(n2, m, pa)
gear3 = cangoGear(n3, m, pa)
from browser.timer import set_interval
deg = math.pi/180
rotate_speed = 12*deg
def draw():
    cgo.clearCanvas()
    gear1.transform.translate(cx-(pr1+pr2)*reduced_ratio, cy)
    gear1.transform.scale(reduced_ratio)
    gear1.transform.rotate(0)
    gear1.rotate(rotate_speed)
    cgo.render(gear1)
    
    gear2.transform.translate(cx, cy)
    gear2.transform.scale(reduced_ratio)
    gear2.transform.rotate(180+(360/n2/2))
    gear2.rotate(-(rotate_speed)*n1/n2)
    cgo.render(gear2)
    
    gear3.transform.translate(cx+(pr2+pr3)*reduced_ratio, cy)
    gear3.transform.scale(reduced_ratio)
    gear3.transform.rotate(180+(360/n3/2)+(180+(360/n2/2))*n2/n3)
    gear3.rotate((rotate_speed*n1/n2)*(n2/n3))
    cgo.render(gear3)
set_interval(draw, 2)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "spur" 的按鈕點按時, 執行 Spur 物件中的 prog 方法
doc["spur"].bind('click', Spur.prog)
</script>
</p>
<!-- cango spur gears ends -->
<p></p>
<!-- temp convert start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Temp = beditor.editor("""# Temperature Conversion
# Temperature Conversion
'''
C to F: Celsius to Fahrenheit Conversion Formula. To convert temperatures in degrees Celsius to Fahrenheit, multiply by 1.8 (or 9/5) and add 32.
To convert temperatures in degrees Fahrenheit to Celsius, subtract 32 and multiply by .5556 (or 5/9).
Fahrenheit = Celsius*9/5 + 32
Celsium = (Fahrenheit - 32)*5/9
'''
from browser import document, html
brython_div = document["brython_div"]
def c2f(c):
    f = round(c*9/5 + 32, 3)
    return "Celsiusc: "+ str(c) +         " degrees = Fahrenheit: " + str(f) + " degrees"
    
def f2c(f):
    c = round((f - 32)*5/9, 3)
    return "Fahrenheit: "+ str(f) +         " degrees = Celsiusc: " + str(c) + " degrees"
    
choice = input("c2f or f2c")
if choice == "c2f":
    '''
    c = float(input("input Celsius in degrees"))
    print(c2f(c))
    '''
    for deg in range(100):
        brython_div <= c2f(deg)
        brython_div <= html.BR()
else:
    '''
    f = float(input("input Fahrenheit in degrees"))
    print(f2c(f))
    '''
    for deg in range(100):
        brython_div <= f2c(deg)
        brython_div <= html.BR()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "temp" 的按鈕點按時, 執行 Temp 物件中的 prog 方法
doc["temp"].bind('click', Temp.prog)
</script>
</p>
<!-- temp convert ends -->
<p></p>
<!-- forloop start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Forloop = beditor.editor("""# For loop
for i in range(5):
    print(i)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "forloop" 的按鈕點按時, 執行 Forloop 物件中的 prog 方法
doc["forloop"].bind('click', Forloop.prog)
</script>
</p>
<!-- forloop ends -->
<p></p>
<!-- guess start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Guess = beditor.editor("""# 猜數字遊戲
from browser import document, html, alert
import random
# 跳出文字說明視窗
alert("開始玩猜數字遊戲")
# 利用 random 模組中的 randint 取 1~100 間的亂數
標準答案 = random.randint(1, 100)
# 利用 input 函式視窗, 取使用者所猜的數字, 轉為整數
你猜的數字 = int(input("請輸入您所猜 1~100 間的整數:"))
# 猜測次數起始值設為 1
猜測次數 = 1
# 進入重複迴圈, 直到猜對數字
while 標準答案 != 你猜的數字:
    # 根據使用者所猜的數字, 與答案比較後, 給出提示
    if 標準答案 < 你猜的數字:
        alert("猜第" + str(猜測次數) + "次, 太大了，再猜 :)加油")
    else:
        alert("猜第" + str(猜測次數) + "次, 太小了，再猜 :)加油")
    你猜的數字 = int(input("請輸入您所猜 1~100 間的整數:"))
    # 猜測次數累加
    猜測次數 += 1
# 跳出迴圈表示猜對, 給出最後文字說明視窗
alert("猜對了！答案為" + str(標準答案) + ", 總共猜了" + str(猜測次數) + "次")
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "guess" 的按鈕點按時, 執行 Guess 物件中的 prog 方法
doc["guess"].bind('click', Guess.prog)
</script>
</p>
<!-- guess ends -->
<p></p>
<!-- autoguess start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Autoguess = beditor.editor("""# 程式自動猜數字遊戲
from browser import document, html, alert
import random
 
id4 = document["brython_div"]
執行次數 = 100
總猜測次數 = 0
for i in range(執行次數):
    id4 <= "第" + str(i+1) + "次玩:" + html.BR()
    下限 = 1
    上限 = 100
    標準答案 = random.randint(下限, 上限)
    pc猜的數字 = random.randint(下限, 上限)
    #print(標準答案, pc猜的數字)
    #integer int()
    #string str()
    #float float()
    #你猜的數字 = int(input("請輸入您所猜的整數:"))
    猜測次數 = 1
    while 標準答案 != pc猜的數字:
        if 標準答案 < pc猜的數字:
            #print("太大了，再猜一次 :)加油")
            # 因此已經確定"pc猜的數字"不是答案, 因此 - 1
            id4 <= "電腦猜的數字:" + str(pc猜的數字) + " 太大了!" + html.BR()
            上限 = pc猜的數字 - 1
        else:
            #print("太小了，再猜一次 :)加油")
            # 因此已經確定"pc猜的數字"不是答案, 因此 + 1
            id4 <= "電腦猜的數字:" + str(pc猜的數字) + " 太小了!" + html.BR()
            下限 = pc猜的數字 + 1
        #pc猜的數字 = int(input("請輸入您所猜的整數:"))
        pc猜的數字 = random.randint(下限, 上限)
        猜測次數 += 1
    #print("猜對了！總共猜了", 猜測次數, "次")
    id4 <= "電腦猜對了, 答案為: " + str(標準答案) + ", 總共猜了 "+ str(猜測次數) + "次" + html.BR()
    總猜測次數 += 猜測次數
平均猜測次數 = int(總猜測次數/執行次數)
#print("平均次數", 平均猜測次數)
id4 <= "平均次數: " + str(平均猜測次數)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "autoguess" 的按鈕點按時, 執行 Autoguess 物件中的 prog 方法
doc["autoguess"].bind('click', Autoguess.prog)
</script>
</p>
<!-- autoguess ends -->
<p></p>
<!-- lottery start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Lottery = beditor.editor("""# 大樂透電腦選號
# lottery
from browser import document, html, alert
import random
try:
    total = int(input("請問要出幾張大樂透彩卷號碼?"))
except:
    alert("請輸入要選擇大樂透電腦選號數量的'整數'")
    total = int(input("請問要出幾張大樂透彩卷號碼?"))
# 準備將電腦選出的號碼, 輸出到內定 id="brython_div" 的標註區域
output_div = document["brython_div"]
output_div <= "以下將出 " + str(total) + " 張電腦選號彩卷:" + html.BR()
for i in range(1, total + 1):
    # 利用 list(range()) 產生 1 到 49 的 population list
    # 然後再透過 random.sample(population, k) 
    # 從 population, 產生 k 個不同的數字
    numbers = random.sample(list(range(1, 49)), 6)
    output_div <= str(i) + ". 電腦選號為: " + str(numbers) + html.BR()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "lottery" 的按鈕點按時, 執行 Lottery 物件中的 prog 方法
doc["lottery"].bind('click', Lottery.prog)
</script>
</p>
<!-- lottery ends -->
<p></p>
<!-- 台灣威力彩 start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Weleadlottery = beditor.editor("""# 威力彩電腦選號
# weleadlottery
from browser import document, html, alert
import random
try:
    total = int(input("請問要出幾張威力彩卷號碼?"))
except:
    alert("請輸入要選擇威力彩電腦選號數量的'整數'")
    total = int(input("請問要出幾張威力彩卷號碼?"))
# 準備將電腦選出的號碼, 輸出到內定 id="brython_div" 的標註區域
output_div = document["brython_div"]
output_div <= "以下將出 " + str(total) + " 張威力彩電腦選號彩卷:" + html.BR()
for i in range(1, total + 1):
    # 利用 list(range()) 產生第一區 1 到 38 , 第二區 1 到 8 的 population list
    # 然後再透過 random.sample(population, k) 
    # 從 population, 產生 k 個不同的數字
    section1_numbers = random.sample(list(range(1, 38)), 6)
    section2_number = random.sample(list(range(1, 8)), 1)
    output_div <= str(i) + ". 電腦選號第一區為: " + str(section1_numbers) + html.BR()
    output_div <= ". 電腦選號第二區為: " + str(section2_number) + html.BR()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "lottery" 的按鈕點按時, 執行 Lottery 物件中的 prog 方法
doc["weleadlottery"].bind('click', Weleadlottery.prog)
</script>
</p>
<!-- 台灣威力彩 ends -->
<p></p>
<!-- bezier starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Bezier = beditor.editor("""# Cango Bezier 繪圖
from browser import window, html
from browser import document as doc
canvas = html.CANVAS(width = 600, height = 400)
canvas.id = "canvas"
brython_div = doc["brython_div"]
brython_div <= canvas
# Javascript 物件
cango = window.Cango.new
path = window.Path.new
shape = window.Shape.new
group = window.Group.new
# Javascript 變數
shapedefs = window.shapeDefs
g1 = cango("canvas")
g1.clearCanvas()
g1.gridboxPadding(10, 10, 5, 7)
g1.fillGridbox("lightgreen")
g1.setWorldCoordsRHC(-100, -100, 400)
x1 = 40
y1 = 20
cx1 = 90
cy1 = 120
x2 = 120
y2 = 100
cx2 = 130
cy2 = 20
cx3 = 150
cy3 = 120
x3 = 180
y3 = 60
def dragC1(mousePos):
    global cx1, cy1
    cx1 = mousePos.x
    cy1 = mousePos.y
    drawCurve()
def dragC2(mousePos):
    global cx2, cy2
    cx2 = mousePos.x
    cy2 = mousePos.y
    drawCurve()
def dragC3(mousePos):
    global cx3, cy3
    cx3 = mousePos.x
    cy3 = mousePos.y
    drawCurve()
def drawCurve():
    qbez = path(['M', x1, y1, 'Q', cx1, cy1, x2, y2], {
      'strokeColor':'blue'})
    cbez = path(['M', x2, y2, 'C', cx2, cy2, cx3, cy3, x3, y3], {
      'strokeColor':'green'})
    L1 = path(['M', x1, y1, 'L', cx1, cy1, x2, y2], {
      'strokeColor':"rgba(0, 0, 0, 0.2)",
      'dashed':[4]})
    L2 = path(['M', x2, y2, 'L', cx2, cy2], {
      'strokeColor':"rgba(0, 0, 0, 0.2)",
      'dashed':[4]})
    L3 = path(['M', x3, y3, 'L', cx3, cy3], {
      'strokeColor':"rgba(0, 0, 0, 0.2)",
      'dashed':[4]})
    c1.transform.translate(cx1, cy1)
    c2.transform.translate(cx2, cy2)
    c3.transform.translate(cx3, cy3)
    grp = group(qbez, cbez, L1, L2, L3, c1, c2, c3)
    g1.render(grp, True)
g1.clearCanvas("lightyellow")
g1.deleteAllLayers()
g1.setWorldCoordsRHC(0, 0, 200)
c1 = shape(shapedefs.circle(6), {'fillColor':'red'})
c1.enableDrag(None, dragC1, None)
c2 = shape(shapedefs.circle(6), {'fillColor':'red'})
c2.enableDrag(None, dragC2, None)
c3 = shape(shapedefs.circle(6), {'fillColor':'red'})
c3.enableDrag(None, dragC3, None);
drawCurve()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "bezier" 的按鈕點按時, 執行 Bezier 物件中的 prog 方法
doc["bezier"].bind('click', Bezier.prog)
</script>
</p>
<!-- bezier ends -->
<p></p>
<!-- turtle1 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Turtle1 = beditor.editor("""# Turtle1 繪圖
from browser import window, html
from browser import document as doc
import turtle
turtle.set_defaults(
    turtle_canvas_wrapper = doc['brython_div']
)
t = turtle.Turtle()
t.width(5)
for c in ['red', '#00ff00', '#fa0', 'rgb(0,0,200)']:
    t.color(c)
    t.forward(100)
    t.left(90)
# dot() and write() do not require the pen to be down
t.penup()
t.goto(-30, -100)
t.dot(40, 'rgba(255, 0, 0, 0.5')
t.goto(30, -100)
t.dot(40, 'rgba(0, 255, 0, 0.5')
t.goto(0, -70)
t.dot(40, 'rgba(0, 0, 255, 0.5')
t.goto(0, 125)
t.color('purple')
t.write("這就是 Brython, 網頁上的 Python", font=("Arial", 15, "normal"))
turtle.done()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "turtle1" 的按鈕點按時, 執行 Turtle1 物件中的 prog 方法
doc["turtle1"].bind('click', Turtle1.prog)
</script>
</p>
<!-- turtle1 ends -->
<p></p>
<!-- turtle2 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Turtle2 = beditor.editor("""# Turtle2 繪圖
from browser import document as doc
import turtle
turtle.set_defaults(
    turtle_canvas_wrapper = doc['brython_div']
)
star = turtle.Turtle()
for i in range(5):
    star.forward(250)
    star.right(144)
    
turtle.done()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "turtle2" 的按鈕點按時, 執行 Turtle2 物件中的 prog 方法
doc["turtle2"].bind('click', Turtle2.prog)
</script>
</p>
<!-- turtle2 ends -->
<p></p>
<!-- turtle3 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Turtle3 = beditor.editor("""# Turtle3 繪圖
# https://michael0x2a.com/blog/turtle-examples
from browser import document as doc
import turtle
turtle.set_defaults(
    turtle_canvas_wrapper = doc['brython_div']
)
painter = turtle.Turtle()
painter.pencolor("blue")
for i in range(50):
    painter.forward(50)
    painter.left(123) # Let's go counterclockwise this time 
    
painter.pencolor("red")
for i in range(50):
    painter.forward(100)
    painter.left(123)
    
turtle.done()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "turtle3" 的按鈕點按時, 執行 Turtle3 物件中的 prog 方法
doc["turtle3"].bind('click', Turtle3.prog)
</script>
</p>
<!-- turtle3 ends -->
<p></p>
<!-- turtle4 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Turtle4 = beditor.editor("""# Turtle4 繪圖
# https://docs.python.org/3.7/library/turtle.html?highlight=turtle
# https://fiftyexamples.readthedocs.io/en/latest/turtle.html
from browser import document as doc
import turtle
turtle.set_defaults(
    turtle_canvas_wrapper = doc['brython_div']
)
# 輸入 "turtle" 字串, 表示要使用內建的烏龜圖示
t = turtle.Turtle("turtle")
# 設定繪圖尺寸
screen_x = 500-20
screen_y = 300
# 提筆, 將烏龜移動到畫布中心
t.penup()
t.home()
# 內定方向為右, 前進 screen_x/2
t.forward(screen_x / 2)
# 將方向往右轉 90 度
t.right(90)
# 此時方向向下, 前進 screen_y/2
t.forward(screen_y / 2)
# 令烏龜方向轉絕對角度 180, 等同轉相對角度 90 度, 即 t.right(90)
t.setheading(180)
# 將畫筆顏色設為紅色
t.pencolor('red')
# 下筆準備繪圖
t.pendown()
# 設筆寬度為 10
t.pensize(10)
# 進入重複迴圈, 此時方向向右, 分別
# 前進 screen_x, 之後轉 90 度, 方向朝上
# 再前進 screen_y, 之後再轉 90 度, 方向朝右
# 再前進 screen_x, 之後轉 90 度, 方向朝下
# 最後再前進 screen_y 後, 將方向轉為向左
for distance in (screen_x, screen_y, screen_x, screen_y):
    t.forward(distance)
    t.right(90)
# 提筆後, 將烏龜轉回內定方向回到畫布中心
t.penup()
t.home()
# 完成 turtle 繪圖
turtle.done()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "turtle4" 的按鈕點按時, 執行 Turtle4 物件中的 prog 方法
doc["turtle4"].bind('click', Turtle4.prog)
</script>
</p>
<!-- turtle4 ends -->
<p></p>
<!-- turtle5 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Turtle5 = beditor.editor("""# Turtle5 繪圖
# https://brython.info/gallery/turtle.html
from browser import document as doc
import turtle
import math
turtle.set_defaults(
    turtle_canvas_wrapper = doc['brython_div']
)
t = turtle.Turtle("turtle")
t.speed(1)
t.forward(50)
print("Should be (50, 0):", t.position())
print("Should be 50: ", t.xcor())
print("Should be 0: ", t.ycor())
t.left(90)
t.color("blue")
t.speed(2)
t.fd(50)
print("Should be (50, 50):", t.pos())
print("Should be 225: ", t.towards(0, 0))
print("Should be 90: ", t.heading())
print("Should be approximately 71:", t.distance(0, 0))
# Draw the same square in three different angle modes
t.width(4)
print("Drawing using degrees - the default")
print("Heading should be 90: ", t.heading())
for i in range(4):
    t.forward(100)
    t.left(90)
print("Drawing using radians")
t.radians()
print("Heading should be pi/2: ", t.heading())
for i in range(4):
    t.forward(100)
    t.left(math.pi/2)
print("Drawing using gradients")
t.degrees(400)
print("Heading should be 100: ", t.heading())
for i in range(4):
    t.forward(100)
    t.left(100)
t.degrees()
t.width(1)
t.lt(90)
t.color("orange")
t.backward(50)
t.right(90)
t.color("green")
t.back(50)
t.rt(90)
t.color("red")
t.bk(50)
t.stamp()
t.speed(4)
t.color("black", "white")
t.goto(-100, 100)
t.stamp()
t.color("blue", "yellow")
t.setposition(0, 100)
t.stamp()
t.color("green", "white")
t.setpos(100, 100)
t.stamp()
t.speed(10)
t.color("orange")
t.sety(-100)
t.setx(-100)
t.stamp()
t.color("cyan")
t.home()
t.stamp()
t.color("green")
t.width(4)
t.setheading(180)
t.forward(150)
t.seth(90)
t.fd(20)
t.dot(30, "rgba(255, 0, 0, 0.2)")
t.color("red")
t.speed(0)
t.forward(30)
t.left(90)
t.circle(30)
turtle.done()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "turtle5" 的按鈕點按時, 執行 Turtle5 物件中的 prog 方法
doc["turtle5"].bind('click', Turtle5.prog)
</script>
</p>
<!-- turtle5 ends -->
<p></p>
<!-- turtle6 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Turtle6 = beditor.editor("""# Turtle6 繪圖
from browser import document as doc
import turtle
import math
turtle.set_defaults(
    turtle_canvas_wrapper = doc['brython_div']
)
t = turtle.Turtle("turtle")
t.speed(10)
colors = ['red', 'purple', 'blue', 'green', 'orange']
for x in range(150):
    t.pencolor(colors[x % 5])
    t.width(x/10 + 1)
    t.forward(x)
    t.left(59)
turtle.done()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "turtle6" 的按鈕點按時, 執行 Turtle6 物件中的 prog 方法
doc["turtle6"].bind('click', Turtle6.prog)
</script>
</p>
<!-- turtle6 ends -->
<p></p>
<!-- turtle7 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Turtle7 = beditor.editor("""# Turtle7 繪圖
from browser import document as doc
import turtle
import math
turtle.set_defaults(
    turtle_canvas_wrapper = doc['brython_div']
)
screen=turtle.Screen()    #making a canvas for drawing
screen.bgcolor('black')    #making canvas black
trtl=turtle.Turtle()  #making a turtle
trtl.pencolor('red')    #making colour of the pen red
trtl.pensize(5)    #choosing the size of pen nib 
trtl.speed(10)    #choosing the speed of drawing
# shape should be ‘arrow’, ‘classic’, ‘turtle’ or ‘circle’
trtl.shape('turtle')   #choosing the shape of pen nib
trtl.forward(150)    #drawing a line of 150 pixels
trtl.right(90)    #asking turtle to turn 90 degrees
trtl.forward(150)    #drawing a line of 150 pixels
trtl.penup()    # preparing for moving pen without drawing
trtl.setpos(-140,-120)    # making the new position of the turtle
trtl.pendown()   # bringing the pen down for drawing again
trtl.pencolor('green')    # choosin the pen colour as green
trtl.write('Brython 烏龜繪圖', font=("Arial", 20, "bold"))    # chosing the font
trtl.penup()
trtl.ht()    # hiding the turtle from the screen
turtle.done()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "turtle7" 的按鈕點按時, 執行 Turtle7 物件中的 prog 方法
doc["turtle7"].bind('click', Turtle7.prog)
</script>
</p>
<!-- turtle7 ends -->
<p></p>
<!-- turtle8 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Turtle8 = beditor.editor("""# Turtle8 繪圖
from browser import document as doc
import turtle
import math
turtle.set_defaults(
    turtle_canvas_wrapper = doc['brython_div']
)
wn = turtle.Screen() 
wn.bgcolor("black") 
skk = turtle.Turtle() 
skk.speed(10)
skk.shape("circle")
skk.color("blue") 
  
def sqrfunc(size): 
    for i in range(4): 
        skk.fd(size) 
        skk.left(90) 
        size = size-5
  
sqrfunc(146) 
sqrfunc(126) 
sqrfunc(106) 
sqrfunc(86) 
sqrfunc(66) 
sqrfunc(46) 
sqrfunc(26) 
turtle.done()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "turtle8" 的按鈕點按時, 執行 Turtle8 物件中的 prog 方法
doc["turtle8"].bind('click', Turtle8.prog)
</script>
</p>
<!-- turtle8 ends -->
<p></p>
<!-- konva1 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Konva1 = beditor.editor("""# Konva1 繪圖
# 引用 https://konvajs.github.io/ 繪圖
from browser import document, html, window
width = 600
height = 400
konva = window.Konva
# Konva 必須在 canvas 繪圖, 從上方設定,  canvas id 為 "container"
stage = konva.Stage.new({
        "container": 'brython_div',
        "width": width,
        "height": height
    })
layer = konva.Layer.new()
rectX = stage.getWidth() / 2 - 50
rectY = stage.getHeight() / 2 - 25
box = konva.Rect.new({
        "x": rectX,
        "y": rectY,
        "width": 100,
        "height": 50,
        "fill": '#00D2FF',
        "stroke": 'black',
        "strokeWidth": 4,
        "draggable": True
    })
def f1():
    document.body.style.cursor = 'pointer'
    
def f2():
    document.body.style.cursor = 'default'
# add cursor styling
box.on('mouseover', f1())
box.on('mouseout', f2())
layer.add(box)
stage.add(layer)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "konva1" 的按鈕點按時, 執行 Konva1 物件中的 prog 方法
doc["konva1"].bind('click', Konva1.prog)
</script>
</p>
<!-- konva1 ends -->
<p></p>
<!-- ycqsort starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Ycqsort = beditor.editor("""# Ycombinator quicksort example
Y = lambda f: lambda *args: f(Y(f))(*args)
quicksort = Y(lambda f:
    lambda x: (
        f([item for item in x if item < x[0]])
        + [y for y in x if x[0] == y]
        + f([item for item in x if item > x[0]])
    ) if x else [])
    
print(quicksort([1, 3, 5, 4, 1, 3, 2]))
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "ycqsort" 的按鈕點按時, 執行 Ycqsort 物件中的 prog 方法
doc["ycqsort"].bind('click', Ycqsort.prog)
</script>
</p>
<!-- ycqsort ends -->
<p></p>
<!-- ball starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Ball = beditor.editor("""# Ggame ball example
from ggame import (
    App, 
    Color, 
    LineStyle, 
    Sprite, 
    RectangleAsset, 
    ImageAsset,
    CircleAsset, 
    EllipseAsset, 
    PolygonAsset,
)
from browser import document as doc
from browser import html
# 引入既有的id="graphics-column" 標註
graphics_column = doc["graphics-column"]
# 建立內定名稱為 "ggame-canvas" 的 canvas 標註
canvas = html.CANVAS(width = 600, height = 100)
canvas.id = "ggame-canvas"
# 將 canvas 插入 gc 標註中
graphics_column <= canvas
# reverse - change the ball direction
def reverse(b):
    b.direction *= -1
# Set up function for handling screen refresh
def step():
    if ball.go:
        ball.x += ball.direction
        if ball.x + ball.width > myapp.width or ball.x < 0:
            ball.x -= ball.direction
            reverse(ball)
myapp = App()
# Three primary colors with no transparency (alpha = 1.0)
red = Color(0xff0000, 1.0)
green = Color(0x00ff00, 1.0)
blue = Color(0x0000ff, 1.0)
black = Color(0x000000, 1.0)
# define colors and line style
green = Color(0x00ff00, 1)
black = Color(0, 1)
noline = LineStyle(0, black)
# a rectangle asset and sprite to use as background
bg_asset = RectangleAsset(canvas.width, canvas.height, noline, green)
bg = Sprite(bg_asset, (0,0))
ball_asset = ImageAsset("/images/orb-150545_640.png")
ball = Sprite(ball_asset, (0, 0))
# Original image is too big. Scale it to 1/10 its original size
ball.scale = 0.1
# custom attributes
ball.direction = 7
ball.go = True
myapp.run(step)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "ball" 的按鈕點按時, 執行 Ball 物件中的 prog 方法
doc["ball"].bind('click', Ball.prog)
</script>
</p>
<!-- ball ends -->
<p></p>
<!-- nfulist starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Nfulist = beditor.editor("""# nfulist
url = "https://nfulist.herokuapp.com/?semester=1092&courseno=2384&column=True"
data = open(url).read()
print(data)
'''
2021 spring:
0741 1a
0764 2a
0776 2b
2384 5j
'''
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "nfulist" 的按鈕點按時, 執行 Nfulist 物件中的 prog 方法
doc["nfulist"].bind('click', Nfulist.prog)
</script>
</p>
<!-- nfulist ends -->
<p></p>
<!-- clock1 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Clock1 = beditor.editor("""# clock1 in Brython
'''Code for the clock'''
# Line drawing
# 導入 doc
from browser import document as doc
from browser import html
import math
import time
import browser.timer
canvas = html.CANVAS(width = 300, height = 200)
canvas.id = "line_drawing"
brython_div = doc["brython_div"]
brython_div <= canvas
# 準備繪圖畫布
canvas = doc["line_drawing"]
ctx = canvas.getContext("2d")

sin, cos = math.sin, math.cos
width, height = 200, 200 # canvas dimensions
ray = 100 # clock ray

background = "SteelBlue"
digits = "#fff"
border = "blue"

def needle(angle, r1, r2):
    '''Draw a needle at specified angle in specified color.
    r1 and r2 are percentages of clock ray.
    '''
    x1 = width / 2 - ray * cos(angle) * r1
    y1 = height / 2 - ray * sin(angle) * r1
    x2 = width / 2 + ray * cos(angle) * r2
    y2 = height / 2 + ray * sin(angle) * r2
    ctx.beginPath()
    ctx.strokeStyle = "#fff"
    ctx.moveTo(x1, y1)
    ctx.lineTo(x2, y2)
    ctx.stroke()

def set_clock():
    # erase clock
    ctx.beginPath()
    ctx.fillStyle = background
    ctx.arc(width / 2, height / 2, ray * 0.89, 0, 2 * math.pi)
    ctx.fill()

    # redraw hours
    show_hours()

    # print day
    now_time = time.time()
    now = time.localtime(now_time)
    microsecs = now_time - int(now_time)
    day = now.tm_mday
    ctx.font = "bold 14px Arial"
    ctx.textAlign = "center"
    ctx.textBaseline = "middle"
    ctx.fillStyle = "#000"
    ctx.fillText(day, width * 0.7, height * 0.5)

    # draw needles for hour, minute, seconds
    ctx.lineWidth = 2
    hour = now.tm_hour % 12 + now.tm_min / 60
    angle = hour * 2 * math.pi / 12 - math.pi / 2
    needle(angle, 0.05, 0.45)
    minute = now.tm_min
    angle = minute * 2 *math.pi / 60 - math.pi / 2
    needle(angle, 0.05, 0.7)
    ctx.lineWidth = 1
    second = now.tm_sec + microsecs
    angle = second * 2 * math.pi / 60 - math.pi / 2
    needle(angle, 0.05, 0.8)

def show_hours():
    ctx.beginPath()
    ctx.arc(width / 2, height / 2, ray * 0.05, 0, 2 * math.pi)
    ctx.fillStyle = digits
    ctx.fill()
    for i in range(1, 13):
        angle = i * math.pi / 6 - math.pi / 2
        x3 = width / 2 + ray * cos(angle) * 0.82
        y3 = height / 2 + ray * sin(angle) * 0.82
        ctx.font = "18px Arial"
        ctx.textAlign = "center"
        ctx.textBaseline = "middle"
        ctx.fillText(i, x3, y3)
    # cell for day
    ctx.fillStyle = "#fff"
    ctx.fillRect(width * 0.65, height * 0.47, width * 0.1, height * 0.06)

    ctx.beginPath()
ctx.arc(width / 2, height / 2, ray, 0, 2 * math.pi)
ctx.fillStyle = background
ctx.fill()

browser.timer.set_interval(set_clock, 100)
show_hours()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "clock1" 的按鈕點按時, 執行 Clock1 物件中的 prog 方法
doc["clock1"].bind('click', Clock1.prog)
</script>
</p>
<!-- clock1 ends -->
<p><button id="keyword">Keyword</button><button id="ex1">Ex1</button><button id="ex2">Ex2</button><button id="ex3">Ex3</button><button id="ex4">Ex4</button><button id="forloop">Ex5</button><button id="guess">Guess</button><button id="autoguess">Autoguess</button><button id="lottery">大樂透</button><button id="weleadlottery">威力彩</button><button id="temp">Temp</button><button id="draw">Draw</button><button id="flag">Flag</button><button id="bezier">Bezier</button><button id="clock1">clock1</button><button id="turtle1">Turtle1</button><button id="turtle2">Turtle2</button><button id="turtle3">Turtle3</button><button id="turtle4">Turtle4</button><button id="turtle5">Turtle5</button><button id="turtle6">Turtle6</button><button id="turtle7">Turtle7</button><button id="turtle8">Turtle8</button><button id="konva1">Konva1</button><button id="bunny">Bunny</button><button id="ball">Ball</button><button id="spur">Spur</button><button id="ycqsort">Ycqsort</button><button id="nfulist">nfulist</button><button id="clear">Clear</button></p>
<h4>參考資料:</h4>
<p><a href="/downloads/turtle_intro.pdf">turtle_intro.pdf</a></p>
<p><a href="/downloads/turtle_intro2.pdf">turtle_intro2.pdf</a></p>
<p>其他擷取程式的方式: <a href="http://mde.tw/2017springvcp/blog/web-based-python.html">http://mde.tw/2017springvcp/blog/web-based-python.html</a></p>
<h4>Qt for Python</h4>
<p><a href="https://www.qt.io/qt-for-python">https://www.qt.io/qt-for-python</a></p>
<p><a href="https://build-system.fman.io/python-qt-tutorial">https://build-system.fman.io/python-qt-tutorial</a></p>
<p><a href="https://build-system.fman.io/pyqt-exe-creation/">https://build-system.fman.io/pyqt-exe-creation/</a></p>
<p><a href="https://github.com/mherrmann/fbs-tutorial">https://github.com/mherrmann/fbs-tutorial</a></p>
<p><a href="https://www.ics.com/blog/we-ported-qt-app-c-python-heres-what-happened">https://www.ics.com/blog/we-ported-qt-app-c-python-heres-what-happened</a></p>
<p>
<script src="/static/konva.min.js"></script>
</p>
<div id="container"></div>
<p>
<script>
var width = window.innerWidth;
    var height = window.innerHeight;
    // globals
    var curveLayer, lineLayer, anchorLayer, quad, bezier;
    function updateDottedLines() {
        var q = quad;
        var b = bezier;
        var quadLine = lineLayer.get('#quadLine')[0];
        var bezierLine = lineLayer.get('#bezierLine')[0];
        quadLine.setPoints([q.start.attrs.x, q.start.attrs.y, q.control.attrs.x, q.control.attrs.y, q.end.attrs.x, q.end.attrs.y]);
        bezierLine.setPoints([b.start.attrs.x, b.start.attrs.y, b.control1.attrs.x, b.control1.attrs.y, b.control2.attrs.x, b.control2.attrs.y, b.end.attrs.x, b.end.attrs.y]);
        lineLayer.draw();
    }
    function buildAnchor(x, y) {
        var anchor = new Konva.Circle({
            x: x,
            y: y,
            radius: 20,
            stroke: '#666',
            fill: '#ddd',
            strokeWidth: 2,
            draggable: true
        });
        // add hover styling
        anchor.on('mouseover', function() {
            document.body.style.cursor = 'pointer';
            this.setStrokeWidth(4);
            anchorLayer.draw();
        });
        anchor.on('mouseout', function() {
            document.body.style.cursor = 'default';
            this.setStrokeWidth(2);
            anchorLayer.draw();
        });
        anchor.on('dragend', function() {
            drawCurves();
            updateDottedLines();
        });
        anchorLayer.add(anchor);
        return anchor;
    }
    function drawCurves() {
        var context = curveLayer.getContext();
        context.clear();
        // draw quad
        context.beginPath();
        context.moveTo(quad.start.attrs.x, quad.start.attrs.y);
        context.quadraticCurveTo(quad.control.attrs.x, quad.control.attrs.y, quad.end.attrs.x, quad.end.attrs.y);
        context.setAttr('strokeStyle', 'red');
        context.setAttr('lineWidth', 4);
        context.stroke();
        // draw bezier
        context.beginPath();
        context.moveTo(bezier.start.attrs.x, bezier.start.attrs.y);
        context.bezierCurveTo(bezier.control1.attrs.x, bezier.control1.attrs.y, bezier.control2.attrs.x, bezier.control2.attrs.y, bezier.end.attrs.x, bezier.end.attrs.y);
        context.setAttr('strokeStyle', 'blue');
        context.setAttr('lineWidth', 4);
        context.stroke();
    }
    var stage = new Konva.Stage({
        container: 'container',
        width: width,
        height: height
    });
    anchorLayer = new Konva.Layer();
    lineLayer = new Konva.Layer();
    // curveLayer just contains a canvas which is drawn
    // onto with the existing canvas API
    curveLayer = new Konva.Layer();
    var quadLine = new Konva.Line({
        dash: [10, 10, 0, 10],
        strokeWidth: 3,
        stroke: 'black',
        lineCap: 'round',
        id: 'quadLine',
        opacity: 0.3,
        points: [0, 0]
    });
    var bezierLine = new Konva.Line({
        dash: [10, 10, 0, 10],
        strokeWidth: 3,
        stroke: 'black',
        lineCap: 'round',
        id: 'bezierLine',
        opacity: 0.3,
        points: [0, 0]
    });
    // add dotted line connectors
    lineLayer.add(quadLine);
    lineLayer.add(bezierLine);
    quad = {
        start: buildAnchor(60, 30),
        control: buildAnchor(240, 110),
        end: buildAnchor(80, 160)
    };
    bezier = {
        start: buildAnchor(280, 20),
        control1: buildAnchor(530, 40),
        control2: buildAnchor(480, 150),
        end: buildAnchor(300, 150)
    };
    // keep curves insync with the lines
    anchorLayer.on('beforeDraw', function() {
        drawCurves();
        updateDottedLines();
    });
    stage.add(curveLayer);
    stage.add(lineLayer);
    stage.add(anchorLayer);
    drawCurves();
    updateDottedLines();
</script>
</p><h3>Brython</h3>
<p>上一頁的網際 Python 是透過 <a href="https://brython.info/">https://brython.info/</a> 完成, 當使用者在網頁中執行 Python 程式時, 透過 Brython 即時轉為 Javascript 後執行.</p>
<p>Brython Google Group: <a href="https://groups.google.com/g/brython">https://groups.google.com/g/brython</a></p>
<p>Introduction guide to Brython: <a href="https://stackabuse.com/an-introductory-guide-to-brython">https://stackabuse.com/an-introductory-guide-to-brython</a></p>
<h4>Calculator in Brython:</h4>
<p><a href="https://codehs.com/tutorial/zach/Intro_to_Brython_-_Calculator">https://codehs.com/tutorial/zach/Intro_to_Brython_-_Calculator</a></p>
<p><a href="/downloads/calculator.html">calculator.html</a></p>
<p><iframe height="300" src="/downloads/calculator.html" width="640"></iframe></p>
<h4>calculator.html 原始碼:</h4>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;!-- 直接從 cdn 導入 brython 程式庫 --&gt;
        &lt;script type="text/javascript" src="https://cdn.jsdelivr.net/npm/brython@3.8.8/brython.min.js"&gt;&lt;/script&gt;
&lt;!-- 設定適合用於 calculator 的 table td 格式 --&gt;
&lt;style&gt;
*{
    font-family: sans-serif;
    font-weight: normal;
    font-size: 1.1em;
}
td{
    width: 80px;
    background-color: #ccc;
    padding: 10px 30px 10px 30px;
    border-radius: 0.2em;
    text-align: center;
    cursor: default;
}
#result{
    border-color: #000;
    border-width: 1px;
    border-style: solid;
    padding: 10px 30px 10px 30px;
    text-align: right;
}
&lt;/style&gt;
    &lt;/head&gt;

    &lt;body onload="brython()"&gt;
        &lt;script type="text/python"&gt;
            from browser import document, html
            # calc 為 html table
            calc = html.TABLE()
            calc &lt;= html.TR(html.TH(html.DIV("0", id="result"), colspan=3) +
                            html.TD("C"))
            lines = ["789/", "456*", "123-", "0.=+"]
            
            calc &lt;= (html.TR(html.TD(x) for x in line) for line in lines)
            
            document &lt;= calc
            
            result = document["result"] # direct acces to an element by its id
            
            def action(event):
                """Handles the "click" event on a button of the calculator."""
                # The element the user clicked on is the attribute "target" of the
                # event object
                element = event.target
                # The text printed on the button is the element's "text" attribute
                value = element.text
                if value not in "=C":
                    # update the result zone
                    if result.text in ["0", "error"]:
                        result.text = value
                    else:
                        result.text = result.text + value
                elif value == "C":
                    # reset
                    result.text = "0"
                elif value == "=":
                    # execute the formula in result zone
                    try:
                        result.text = eval(result.text)
                    except:
                        result.text = "error"
            
            # Associate function action() to the event "click" on all buttons
            for button in document.select("td"):
                button.bind("click", action)
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre>
<h4>延伸練習:</h4>
<p style="padding-left: 30px;">請將上述網際加減乘除計算機, 以 Brython(Browser Python) 改為<a href="https://www.eeweb.com/tools/online-scientific-calculator/">網際工程用計算機</a>.</p>
<h3>Flask</h3>
<p>Server 端 (Flask):</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from flask import Flask, render_template, request, jsonify
 
# Initialize the Flask application
app = Flask(__name__)
 
@app.route('/')
def index():
    return render_template('index.html')
 
@app.route('/add_numbers', methods=['POST'])
def add_numbers():
    a = request.form.get('a', 0, type=int)
    b = request.form.get('b', 0, type=int)
    #return jsonify(result = a+b)
    # 必須傳回字串?
    return str(a+b)
 
if __name__ == '__main__':
    app.run(debug=True)</pre>
<p>Client 端 (Brython):</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"&gt;&lt;/script&gt;
    &lt;link href="//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css" rel="stylesheet"&gt;
    &lt;script src="http://brython.info/src/brython_dist.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body onload="brython()"&gt;
  &lt;script type="text/python"&gt;
    from browser import document
    from browser import ajax
    # https://www.brython.info/static_doc/en/ajax.html
     
    def on_complete(req):
        document["txt_area"] .clear()
        if req.status==200 or req.status==0:
            document["txt_area"] &lt;= req.text
        else:
            document["txt_area"] &lt;= "error "+req.text
             
    def get(url):  
        # req 從 ajax 模組中的 ajax 類別建立案例, 為一個 ajax 物件        
        req = ajax.ajax()
        # a 為 id="A" 輸入欄位中所輸入的值
        a = document['A'].value
        # b 為 id="B" 輸入欄位中所輸入的值        
        b = document['B'].value
        # ajax 物件中的 bind 方法, 第一個輸入變數為 evt, 'complete' 表示 ajax 從伺服器取值完成後, 執行 on_complete 函式
        req.bind('complete', on_complete)
        req.open('POST', url, True)
        req.set_header('content-type','application/x-www-form-urlencoded')
        req.send({"a": a, "b":b}) 
     
    # 使用者按下 id="calculate" 按鈕, 將會執行上述 get("/add_numbers") 函式
    document['calculate'].bind('click',lambda ev:get('/add_numbers'))
 
&lt;/script&gt;
   
    &lt;div class="container"&gt;
      &lt;div class="header"&gt;
        &lt;h3 class="text-muted"&gt;Brython ajax example&lt;/h3&gt;
      &lt;/div&gt;
      &lt;div&gt;
    &lt;input type="text" id="A" size="5" name="a"&gt; +
    &lt;input type="text" id ="B" size="5" name="b"&gt; =
    &lt;div id="txt_area"&gt;&lt;/div&gt;
    &lt;p&gt;&lt;button id="calculate"&gt;calculate server side&lt;/button&gt;
      &lt;/form&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>
<p></p><h2>RoboDK</h2>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/nv7mOBDA_Z8" title="YouTube video player" width="560"></iframe></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/dkRaf5n3OKs" title="YouTube video player" width="560"></iframe></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/3EqzMzszMV0" title="YouTube video player" width="560"></iframe></p><h2>開發範例</h2>
<h4>平面機構分析與合成:</h4>
<p style="padding-left: 30px;"><a href="https://github.com/mdecourse/ps2020">https://github.com/mdecourse/ps2020</a></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/YOnLdzrLivM" title="YouTube video player" width="560"></iframe></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/ZAGrFV1jCdk" title="YouTube video player" width="560"></iframe></p>
<h4>Python GUI with Serial port communication:</h4>
<p style="padding-left: 30px;"><a href="https://github.com/mdecourse/Pyquino">https://github.com/mdecourse/Pyquino</a></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/R26R_07rkIc" title="YouTube video player" width="560"></iframe></p>
<p></p><h1>可攜系統</h1>
<p><a href="https://drive.google.com/file/d/1hTvN4mCk2b_enIK204HA0AVPsd3GPlh5/view?usp=sharing">portablekmol_base.7z</a> (下載 118MB, 解開壓縮後 148MB)</p>
<p style="padding-left: 30px;">包括 data 目錄與 start_ipv6.bat, start_ipv4.bat, stop.bat</p>
<p style="padding-left: 30px;">功能: 啟動後可以啟動 SciTE 編輯器, 可用於類解譯 ANSI C 程式, 以及 <a href="https://solvespace.com">Solvespace</a>.</p>
<p><a href="https://drive.google.com/file/d/1BGfN5R6Yw1e9Unm4u8GCRP4xcSuYfCSE/view?usp=sharing">Python395.7z</a> (下載 123MB, 解開壓縮後 495MB)</p>
<p style="padding-left: 30px;">功能: 與 <a href="https://drive.google.com/file/d/1hTvN4mCk2b_enIK204HA0AVPsd3GPlh5/view?usp=sharing">portablekmol_base.7z</a> 結合後, 可以利用 SciTE 編輯器執行 Python 程式.</p>
<p><a href="https://drive.google.com/file/d/1RW51wCJ056TdWvjharBKOl6FM9iewpHI/view?usp=sharing">portablegit_2.31.1.7z</a> (下載 60MB, 解開壓縮後 286MB)</p>
<p style="padding-left: 30px;">功能: 與 <a href="https://drive.google.com/file/d/1hTvN4mCk2b_enIK204HA0AVPsd3GPlh5/view?usp=sharing">portablekmol_base.7z</a> 結合後, 可以利用可攜程式系統的命令列視窗執行 git 指令.</p>
<p><a href="https://drive.google.com/file/d/1JDmc_b4BLwGh4hQ7Tatq02EXmiPLrNZV/view?usp=sharing">lua-5.4.3.7z</a> (下載 662KB, 解開壓縮後 4MB)</p>
<p style="padding-left: 30px;">功能: 與 <a href="https://drive.google.com/file/d/1hTvN4mCk2b_enIK204HA0AVPsd3GPlh5/view?usp=sharing">portablekmol_base.7z</a> 結合後, 可以利用 SciTE 編輯器執行 Lua 程式.</p>
<p><a href="https://drive.google.com/file/d/1u-Efwoizvqn9WJdcL0fez7a2d0ulGBcs/view?usp=sharing">PUTTY.7z</a> (下載 940KB, 解開壓縮後 4MB)</p>
<p style="padding-left: 30px;">功能: plink.exe 可以與 git 結合, 利用 Putty.exe 中所設定的 session 名稱進行 SSH 連線.</p>
<p><a href="https://drive.google.com/file/d/1m6cmWu9AZhkBj6wFn9IiJlShcpGbz05g/view?usp=sharing">msys64_20210419.7z</a> (下載 3.5GB, 解開壓縮後 12GB)</p>
<p style="padding-left: 30px;">功能: <a href="https://www.msys2.org/">Msys2</a> 安裝</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">pacman -S mingw-w64-x86_64-toolchain
pacman -Sy mingw-w64-x86_64-qt5
pacman -Sy mingw-w64-x86_64-qt5-static
pacman -Sy mingw-w64-x86_64-ffmpeg
pacman -Sy mingw-w64-x86-64-cmake</pre>
<p><a href="https://drive.google.com/file/d/17M7Ro9NO2mmycvwOuK-10yYgs2oxFwEB/view?usp=sharing">msys64_20210419_clean.7z</a> (下載 87MB , 解開壓縮後 374MB)</p>
<p style="padding-left: 30px;">功能: 尚未安裝任何 Package 的 <a href="https://www.msys2.org/">Msys2</a> 系統.</p>
<p><a href="https://drive.google.com/file/d/1BIDn3pn-qQRF0L7rZMNbh43HXyFLhiPj/view?usp=sharing">CoppeliaSimEdu_4.1.0_rev1.7z</a> (下載 183MB, 解開壓縮後 438MB)</p>
<p style="padding-left: 30px;">功能: 可免費提供大學機電資整合課程使用, 且開放原始碼, 可用於機電資控制系統設計與模擬 (InfoMechaTronic control system design and simulation).</p>
<p><a href="https://drive.google.com/file/d/1ih24k0G-vKnB1OjOIxHV4Gyz-bmlxeCU/view?usp=sharing">robodk_522.7z</a> (下載 364MB, 解開壓縮後 1GB)</p>
<p style="padding-left: 30px;">功能: 提供限縮功能版本 Free Trial, 只可模擬但無法存檔, 可用於工業級機械手臂在線與離線控制系統設計與模擬.</p>
<p><a href="https://drive.google.com/file/d/1uDJCaxDsed_5ZTdsHNOfGQ51JnT3aNP0/view?usp=sharing">Range3.7z</a> (下載 27MB, 解開壓縮後 109MB)</p>
<p style="padding-left: 30px;">功能: 開放源 FEM (Finite Element Method) 分析套件.</p>
<p><a href="https://drive.google.com/file/d/1ITHNrhemifHloS_x3BAchyQxMUKma0AI/view?usp=sharing">webots-R2021a.7z</a> (下載 1.5GB, 解開壓所後 2.9GB)</p>
<p style="padding-left: 30px;">功能: 採 Apache 2.0 使用授權的開放源套件, 可用於機電資控制系統設計與模擬.</p><h2>Lua 解譯</h2>
<p></p>
<p>網際 Lua 解譯: <a href="http://mde.tw/lab/downloads/lua/index.html">http://mde.tw/lab/downloads/lua/index.html</a></p>
<p>SciTE 編輯器中的 Lua.properties 設定:</p>
<p>選擇利用 y:\lua-5.4.3\luac 與 lua 編譯或解譯 .lua 程式檔案.</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">command.compile.*.lua=y:\lua-5.4.3\luac -o "$(FileName).luc" "$(FileNameExt)"
# Lua 5.1
command.go.*.lua=y:\lua-5.4.3\lua "$(FileNameExt)"</pre>
<p></p><h1>CMSiMDE</h1>
<p>CMSiMDE (<a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a>) 是一套以 Python 與 Flask 框架編寫的網際內容管理系統,</p>
<p>使用 CMSiMDE 建議使用者安裝 flask flask_cors bs4 lxml pelican markdown leo 等模組. 其中的 flask flask_cors bs4 lxml pelican markdown為啟動 CMSiMDE 的必要模組, 而 leo 則是 CMSMDE 開發者所使用的大綱管理工具, 可以用於與 CMSiMDE 整合的 Pelican blog 及 Reveal.js 網際簡報編輯之用.</p>
<h2>基本操作</h2>
<p>當使用者利用 cms.bat 啟用動態網站後, 即可利用瀏覽器 <a>https://localhost:9443</a> 在近端維護網站內容, 由於此時動態網站僅在 localhost 啟動, 因此可以使用內建的管理者密碼 "admin" 登入管理網站內容.</p>
<p>假如使用者修改 init.py 中的 ip 或 uwsgi 設定, 讓動態網站在外部 IP 啟動, 則必須自行透過動態網站中的 <span style="background-color: #ffff99;">config</span> 指令修改管理者密碼.</p>
<p>動態網站編輯表單中的 <span style="background-color: #ffff99;">config</span> 除了可更改網站管理者密碼外, 也可以更改網站的頁面內容標題 (外部標題可以透過 init.py 中的 site_title 更改).</p>
<h3>客製化</h3>
<p>假如利用 <a href="https://github.com/mdecourse/cmstemplate">https://github.com/mdecourse/cmstemplate</a> 作為 template 所建立的 Github Pages 網站, 倉儲根目錄中的 cms.bat 可以在執行動態網站系統之後, 利用 pipe 讓 cms.bat 同時開啟 Firefox <a>https://localhost:9443</a></p>
<p>修改後的 cms.bat 如下:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">python cmsimde/wsgi.py 1&gt; nul | "C:\Program Files (x86)\Mozilla Firefox\firefox" https://localhost:9443</pre>
<p>前面 python cmsimde/wsgi.py 加上 1&gt; nul 的目的是因為 pipe 執行時會將前面指令執行結果轉為隨後執行指令的輸入, 而 1&gt; nul 則會將標準輸出的任何資料移除, 任何輸出不會影響 Firefox 執行.</p>
<h3>編輯網頁內容</h3>
<p>編輯 CMSiMDE 動態網站中的內容, 可以透過表單中的 <span style="background-color: #ffff99;">Edit All</span> 或 <span style="background-color: #ffff99;">Edit</span> 按鈕進行. <span style="background-color: #ffff99;">Edit</span> 可用於單頁編輯, 操作時先選擇左側的頁面標題, 等系統顯示該頁面內容後, 再點擊上方的 <span style="background-color: #ffff99;">Edit</span> 按鈕即可進入該頁面的編輯模式.</p>
<p><span style="background-color: #ffff99;">Edit All</span> 通常用於單次刪除所有頁面內容或者只保留特定頁面用, 點擊後會將所有頁面內容置於編輯器中.</p>
<h3>上傳與引用檔案</h3>
<p><span style="background-color: #000000; color: #ffffff;">File Upload</span> 可以讓使用者選擇近端多個檔案上傳至動態系統中的 downloads 目錄.</p>
<p>引用使用者上傳的檔案</p>
<p style="padding-left: 30px;"><a href="/downloads/python_book_01.pdf">python_book_01.pdf</a></p>
<h3>上傳與引用圖片</h3>
<p><span style="background-color: #000000; color: #ffffff;">Image Upload</span> 可以讓使用者選擇近端多個檔案上傳至動態系統中的 downloads 目錄.</p>
<p>引用使用者上傳的檔案</p>
<p style="padding-left: 30px;"><img caption="false" class="add_border" height="227" src="/images/nfu_logo_mde.png" width="200"/></p>
<p style="padding-left: 30px;"></p>
<h3>嵌入程式碼</h3>
<p>利用 Insert/Edit code 功能, 可以嵌入各種程式碼:</p>
<pre class="brush:dart;auto-links:false;toolbar:false" contenteditable="false">// 下列 Dart 程式, 利用 Runge Kutta 迭代運算法, 解常微分方程式
// 設 t 為時間, x 則設為物體的位移
// dx / dt = (t - x)/2, 起始值 t0=0, x0=1, 求 t=2 時的 x 值
//
// 已知起始值 t0 與 x0 後, 可以利用下列 rungeKutta 函式, 以
// h 為每步階增量值, 求 dxdt 常微分方程式任一 t 的對應值 x
// 定義函式 rungeKutta, 共有四個輸入變數
rungeKutta(t0, x0, t, h) {
  // 利用步階增量值 h 與 t 的起始及終點值
  // 計算需要迭代的次數 n
  int n = ((t - t0) / h).toInt();
  // 宣告 x 為雙浮點數, 且設為起始值 x0
  double x = x0;
  // 利用已知的 t0, x0, t 終點值與步階增量值 h, 迭代求 x 對應值
  // 索引值 i 將每次增量 1, 從 i=1 執行 for 環圈至 i=n
  for (int i = 1; i &lt;= n; i++) {
    // 將此階段的 t 與 x 值代入 dxdt 函式求下列四個浮點變數值
    double k1 = h * dxdt(t0, x);
    double k2 = h * dxdt(t0 + 0.5 * h, x + 0.5 * k1);
    double k3 = h * dxdt(t0 + 0.5 * h, x + 0.5 * k2);
    double k4 = h * dxdt(t0 + h, x + k3);
    // 利用上述四個變數值求此步階增量後的對應 x 值
    x = x + (1.0 / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4);
    // 每次 for 迴圈執行最後, 準備計算下一個步階增量後的 x 對應值
    // t 起始值配合步階增量值 h, 進行增量
    t0 = t0 + h;
  }
  // 完成 for 迴圈迭代後, 傳回與 t 終點值對應的 x 值
  return x;
}

// 將微分方程式 "dx / dt = (t - x)/2" 定義為 dxdt 函式
dxdt(t, x) {
  return ((t - x) / 2);
}

// 定義 main() 主函式內容, 目的在利用 rungeKutta 函式
// 解常微分方程式
main() {
// Driver method
// num 資料型別可以是整數或雙浮點數
  num t0 = 0;
  num x = 1;
  num t = 2;
  double h = 0.2;
  print('The value of x at t=$t is: ${rungeKutta(t0, x, t, h)}');
}
</pre>
<p></p>
<h3>嵌入影片檔</h3>
<p>直接利用 Source code 功能, 將影片檔案的 iframe 標註放入後存檔:</p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/bZupkkT4T5c" width="560"></iframe></p>
<h3>檢視 STL</h3>
<p>使用 Github 所提供的 STL viewer 嵌入 github.com/mdecourse/cmstemplate main branch 中 downloads 目錄中的 spikeball.stl</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;script src="https://embed.github.com/view/3d/mdecourse/cmstemplate/main/downloads/spikeball.stl"&gt;&lt;/script&gt;</pre>
<p>將上列 script 標註放入頁面 HTML 內容後, 可以檢視 STL 零件檔案.</p>
<p></p>
<p>
<script src="https://embed.github.com/view/3d/mdecourse/cmstemplate/main/downloads/spikeball.stl"></script>
</p>
<p>以 CMSiMDE 內建的 static/viewstl.html 檢視 STL 檔案:</p>
<p>使用 iframe 其 src 指向 STL 檔案的絕對 URL 路徑:</p>
<p>/static/viewstl.html?src=https://mde.tw/cmstemplate/downloads/spikeball.stl</p>
<p>就可以如下檢視 downloads/spikeball.stl</p>
<p><iframe height="400" src="/static/viewstl.html?src=https://mde.tw/cmstemplate/downloads/spikeball.stl" width="600"></iframe></p>
<h2>Gitlab 同步</h2>
<p>利用 git remote add gitlab <a href="https://gitlab.com/user/repository.git">https://gitlab.com/user/repository.git</a> 可以在近端倉儲中的 .git/config 中新增一個名稱為 gitlab, 且與 <a href="https://gitlab.com/user/repository.git">https://gitlab.com/user/repository.git</a> 倉儲對應的設定. 使用者可以將此倉儲改版內容以 git push gitlab 推向 Gitlab.</p>
<p>至於 Gitlab Pages 額外需要下列 .yml 檔案進行轉換設定:</p>
<p>.gitlab-ci.yml</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">pages:
  stage: deploy
  script:
  - mkdir .public
  - cp -r * .public
  - mv .public public
  artifacts:
    paths:
    - public
  only:
  - master
variables:
  GIT_SUBMODULE_STRATEGY: recursive</pre>
<p></p>
<h2>Heroku 部署</h2>
<p>與 Heroku 部署有關資訊請參考: <a href="https://mde.tw/cp2020/content/Heroku.html">https://mde.tw/cp2020/content/Heroku.html</a></p>
<h2>Fossil SCM</h2>
<p>在 Github 之外, 可以同步將各倉儲資料存放至 Gitlab, Heroku (有 500 MB 容量限制) 與 Fossil SCM.</p>
<p>希望整合 Github 與 Fossil SCM 倉儲步驟說明如下:</p>
<p>針對 Github 中已經有 <a href="https://github.com/mdecourse/cmstemplate">https://github.com/mdecourse/cmstemplate</a> 倉儲, 希望同步建 <a href="https://fossil.kmol.info/cmstemplate">https://fossil.kmol.info/cmstemplate</a> 與之內容同步.</p>
<p>登入 fossil.kmol.info 主機, 在 /home/user/repository 目錄中, 以 fossil init cmstemplate.fossil 建立空倉儲. 此時 Fossil SCM 將會列出以登入帳號作為帳號的管理者密碼.</p>
<p>管理者利用 <a href="https://fossil.kmol.info/cmstemplate">https://fossil.kmol.info/cmstemplate</a> 連結, 以 user 登入, 並利用上列管理者密碼進入管理區, 先行透過 Setup/users 變更 user 對應密碼.</p>
<p>回到 Windows 以 <span style="background-color: #ffff99;">fossil clone https://user@fossil.kmol.info/cmstemplate cmstemplate.fossil</span> 取下倉儲資料, 過程中將需要輸入與 user 對應的密碼, 並被詢問是否儲存密碼, 若選擇儲存密碼則隨後的 fossil commit 將回自動提交推送.</p>
<p>接著在近端必須開啟空 cmstemplate.fossil 倉儲, 主要目的是取得 __FOSSIL__, 並且以 git pull 完整拉下位於 <a href="https://github.com/mdecourse/cmstemplate">https://github.com/mdecourse/cmstemplate</a> 中的資料並與空 __FOSSIL__ 進行整合. 其中在 Fossil SCM 端必須將 Setup/Settings 中的 default-csp 設為: <a href="https://fonts.googleapis.com">https://fonts.googleapis.com</a> (讓 CMSiMDE 靜態網頁可以在 Fossil SCM doc 頁面中正常顯示), 且勾選 dotfiles (讓 Fossil SCM 可以儲存 .git 中的版本資料).</p>
<p></p>
<h4>參考資料:</h4>
<p>編譯 Fossil SCM:</p>
<p style="padding-left: 30px;"> <a href="http://project.mde.tw/blog/zai-msys2-huan-jing-bian-yi-fossil-scm.html">http://project.mde.tw/blog/zai-msys2-huan-jing-bian-yi-fossil-scm.html</a></p>
<h1>建立網頁</h1>
<p>由於 CMSiMDE 帶有動態網頁與靜態網頁等兩個部分, 動態網頁執行時需要該伺服器能夠執行 Python 3, 以及 flask flask_cors bs4 lxml pelican markdown 等模組. 而靜態網頁的伺服則只需要 WWW Server 即可.</p>
<p>若使用者在 Github 使用 CMSiMDE 建立網頁, 可以透過 <a href="https://github.com/mdecourse/cmstemplate">https://github.com/mdecourse/cmstemplate</a> template 建立, 步驟與兩種設定方式如下:</p>
<ol>
<li>使用者登入 Github</li>
<li>將瀏覽器連線至 <a href="https://github.com/mdecourse/cmstemplate">https://github.com/mdecourse/cmstemplate</a> 頁面後, 點擊 Use this template 按鈕後, 選擇所要採用的 repository 名稱後, 就可以建立以 CMSiMDE 作為子模組的 Github 倉儲.</li>
<li>假如使用者所選擇的倉儲名稱為: 帳號.github.io, 則 Github 會自動設定該倉儲的 main 分支為 Github Pages 根目錄, 意即一旦 Github Pages 完成轉檔 (提交訊息之後會出現綠勾), 則該倉儲的對應網頁將為: https://帳號.github.io</li>
<li>若使用利用 <a href="https://github.com/mdecourse/cmstemplate">https://github.com/mdecourse/cmstemplate</a> 作為 template 所建立的倉儲名稱並非 帳號.github.io, 則使用者必須自行至該倉儲的 settings/Github Pages 選項中將 main branch 設為 Github Pages 對應的 root 目錄. 之後, Github 將會採用: 帳號.github.io/倉儲名稱 作為與該倉儲對應的 Github Pages 網址.</li>
</ol>
<h1>注意事項</h1>
<p>因為 <a href="https://github.com/mdecourse/cmstemplate">https://github.com/mdecourse/cmstemplate</a> 將 CMSiMDE 倉儲作為 submodule, 因此使用者利用 cmstemplate 作為 template 後, 必須使用 git clone --recurse-submodules 取下遠端倉儲.</p>
<p>例如:</p>
<p style="padding-left: 30px;">若使用者的倉儲 URL 為 <a href="https://github.com/mdecourse/cmstemplate">https://github.com/mdecourse/cmstemplate</a></p>
<p style="padding-left: 30px;">則可以在近端利用:</p>
<p style="padding-left: 30px;">git clone --recurse-submodules <a href="https://github.com/mdecourse/cmstemplate.git">https://github.com/mdecourse/cmstemplate.git</a></p>
<p style="padding-left: 30px;">將遠端倉儲資料存入 cmstemplate 目錄中.</p>
<p>目前的 cmstemplate 內建 cms.bat 與 acp.bat 等兩個 batch 檔案, 可以協助使用者直接在倉儲根目錄啟動 CMSiMDE 動態網頁, 以及單一指令式即可完成 git add, git commit 以及 git push, 但是前提是使用者必須設定以 ssh 方式與 Github 倉儲進行驗證.</p>
<p>例如:</p>
<p style="padding-left: 30px;">若使用者已經將倉儲內容 clone 至近端, 且已經帶有 cmsimde 子模組的內容.</p>
<p style="padding-left: 30px;">則可以在近端命令列進入 cmstemplate 倉儲目錄執行:</p>
<p style="padding-left: 30px;">cms.bat</p>
<p style="padding-left: 30px;">開啟動態網頁系統. 並以 <a>https://localhost:9443</a> 開啟.</p>
<p style="padding-left: 30px;">一旦完成動態網頁的編輯, 利用 Generate Pages 可以轉為靜態網站, 且各 html 檔案將位於 content 目錄中.</p>
<p style="padding-left: 30px;">若使用者希望檢查近端靜態網頁的內容, 可以利用 SciTE 開啟倉儲中的 http-server.py, 並利用瀏覽器以 <a href="https://localhost:8444">https://localhost:8444</a> 檢查靜態網頁內容.</p>
<p style="padding-left: 30px;">一旦使用者要將近端倉儲的動態與靜態網頁內容推向 Github, 則必須將倉儲中 .git/config 的 url, 從 https 改為 ssh 的連線格式:</p>
<p style="padding-left: 30px;">例如:</p>
<p style="padding-left: 60px;">原先 .git/config origin 的 url 為 url = <a href="https://github.com/mdecourse/cmstemplate.git,">https://github.com/mdecourse/cmstemplate.git,</a> 則必須改為:</p>
<p style="padding-left: 60px;">url = <a href="mailto:git@github.com:mdecourse/cmstemplate.git">git@github.com:mdecourse/cmstemplate.git</a></p>
<p style="padding-left: 60px;">之後假如使用者要以 "add some files" 字串當作提交說明訊息, 則可以在命令列中的倉儲目錄執行:</p>
<p style="padding-left: 60px;">acp.bat "add some files"</p>
<h2>標題選擇</h2>
<p>由於 CMSiMDE 中的動態網站透過 config/content.htm 的 H1~H3 超文件標註進行分頁, 因此使用者利用 cms.bat 開啟動態網站後, 必須注意各頁面標題文字的選擇:</p>
<ol>
<li><span style="background-color: #ffff99;">頁面標題文字儘量簡短</span> - 頁面標題就有如文章的章節標題, 只要該標題具有該頁面內容的代表性即可, 越簡短越好.</li>
<li><span style="background-color: #ffff99;">頁面標題文字不要使用標點符號</span> - 因為標點符號中的 "/" 會造成頁面擷取時 URL 指令分段上的誤判, 至於標題文字中若有 ":" 則會在動態內容轉靜態內容時, 因 Windows 不允許檔案名稱帶有 ":" 而無法轉檔.</li>
<li><span style="background-color: #ffff99;">頁面標題中不可以有超文件標註</span> - 由於 CMSiMDE 動態網站編輯器採用 GUI 進行, 採用滑鼠標修頁面標題時, 可能無意中將 HTML 標註放入 H1~H3 標題文字中, 如此可能會造成 CMSiMDE 分頁錯誤而無法開啟動態網站. 當使用者要檢查所使用的頁面標題是否帶有 html 標註, 可以透過編輯功能中的 Source Code 檢查.</li>
<li><span style="background-color: #ffff99;">H1 標題數量不可過多</span> - 由於 CMSiMDE 的靜態網站支援手機模式, 當頁面 H1 標題數量超過 10 個之後, 頁面標題可能無法在螢幕上最上方以一列顯示, 而是必須出現在第二行, 結果將會導致頁面展開時的 Javascript 程式產生錯亂, 結果為無法直接以滑鼠點擊進入特定頁面.</li>
</ol>
<p></p>
<p></p>
<h2>靜態網頁 404</h2>
<p>當使用者將近端網頁倉儲資料推向 Github 後, commit 提交訊息之後若沒有出現綠勾, 表示靜態網頁無法轉檔成功, 這時連接靜態網頁時, 將會出現 404, 通常情況下是因為倉儲中 cmsimde 子模組的版次無法與遠端 <a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> 中的版本對應.</p>
<p>上述靜態網頁出現 404 錯誤訊息的處理方式如下:</p>
<ol>
<li>從 <a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> 倉儲中複製最新版本的版次號, 以 <a href="https://github.com/mdecourse/cmsimde/commit/1c3aeec1f5d26b421743d2f5ef8bb7d5b99292af">2021/03/03 的版次</a>為例, 版次號為 1c3aeec1f5d26b421743d2f5ef8bb7d5b99292af, 使用者只需要最前面的 7 個字元, 也就是 1c3aeec.</li>
<li>然後在近端倉儲中, 以命令列進入 cmsimde 目錄後執行: <span style="background-color: #ffff99;">git checkout 1c3aeec</span></li>
<li>接著退回倉儲目錄, 以 git add, git commit 及 git push 將倉儲改版內容推向 Github 後應該就可以將倉儲正確轉為靜態網站內容.</li>
</ol>
<h2>動態網站錯誤</h2>
<p>CMSiMDE 動態網站經常出現的錯誤是無法對 config/content.htm 分頁, 這時可以利用 SCiTE 編輯 content.htm, 找尋是否 H1~H3 標註中是否帶有特殊符號, 如 "/" 或 ":" 等.</p>
<h1>延伸開發</h1>
<p>為了建立 responsive site:</p>
<p>靜態網頁:</p>
<p style="padding-left: 30px;">Javascript 程式庫:</p>
<p style="padding-left: 60px;"><a href="https://getbootstrap.com/">https://getbootstrap.com/</a></p>
<p>動態系統:</p>
<p style="padding-left: 30px;">Javascript editor</p>
<p style="padding-left: 60px;">TinyMCE: <a href="https://www.tiny.cloud/">https://www.tiny.cloud/</a></p>
<p style="padding-left: 30px;">Syntax highlighter: <a href="https://prismjs.com/">https://prismjs.com/</a></p>
<p style="padding-left: 30px;">Ajax bit by bit file uploader:</p>
<p style="padding-left: 30px;">Flask</p>
<p style="padding-left: 30px;">Flask_cors</p>
<p style="padding-left: 30px;">bs4</p>
<p style="padding-left: 30px;">lxml</p>
<p style="padding-left: 30px;">markdown</p>
<h2>已知問題</h2>
<p>cmsimde 是一套始終修改中的機械設計工程導向網際內容管理系統, 由於自 2013 年底開發至今, Python 已經從 3.6 進展到 3.9, 網際發展方向也從 html editor 趨向 markdown editor, WebGL 相關技術與 three.js 的整合也越發成熟.</p>
<p>因此面對</p>
<p><a href="https://github.com/mdecourse/virtualkossel">https://github.com/mdecourse/virtualkossel</a></p>
<p style="padding-left: 30px;"><a href="http://mde.tw/virtualkossel/">http://mde.tw/virtualkossel/</a></p>
<p>cmsimde 應該要導入更多動態零組件展示與互動相關的機械設計功能.</p>
<p>可以著力的方向:</p>
<p style="padding-left: 30px;"><a href="http://help.autodesk.com/view/fusion360/ENU/?guid=GUID-1C665B4D-7BF7-4FDF-98B0-AA7EE12B5AC2">Fusion 360 </a></p>
<p style="padding-left: 60px;"><a href="https://github.com/AutodeskFusion360">https://github.com/AutodeskFusion360</a></p>
<p style="padding-left: 30px;"><a href="https://stromberg.dnsalias.org/~strombrg/pybrowser/python-browser.html">https://stromberg.dnsalias.org/~strombrg/pybrowser/python-browser.html</a></p>
<p style="padding-left: 30px;"><a href="https://vpython.org/">https://vpython.org/</a></p>
<p style="padding-left: 30px;"><a href="https://www.glowscript.org/">https://www.glowscript.org/</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/slembcke/Chipmunk2D">https://github.com/slembcke/Chipmunk2D</a></p>
<p style="padding-left: 60px;"><a href="http://www.pymunk.org/en/latest/">http://www.pymunk.org/en/latest/</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/mrjleo/python-physics-demos">https://github.com/mrjleo/python-physics-demos</a></p>
<p style="padding-left: 30px;">cango3d library: <a href="https://www.arc.id.au/Canvas3DGraphics.html">https://www.arc.id.au/Canvas3DGraphics.html</a></p>
<h3>IPv6</h3>
<p>參考: <a href="https://github.com/tinymce/tinymce/issues/4409">https://github.com/tinymce/tinymce/issues/4409</a> 中的 <a href="https://github.com/tinymce/tinymce/issues/4409#issuecomment-680282550">url parsing 修改</a>後, 目前已經可以在 local 與 IPv6 網路連線中啟用 tinymce4 editor.</p>
<h3>MathJax</h3>
<p>MathJax 引用問題:</p>
<p style="padding-left: 30px;"><a href="https://www.mathjax.org/">https://www.mathjax.org/</a></p>
<h3>html 分頁</h3>
<p>分頁失敗時會意外抹除 config\content.htm 中的所有內容</p>
<p>分頁失敗並不會提供 debug 建議</p>
<h3>template</h3>
<p>cmsimde 針對利用 Flask 產生頁面並未使用 Template, 為了讓程式更加模組化可以考慮納入 <a href="https://www.makotemplates.org/">Mako</a> template engine.</p>
<p></p>